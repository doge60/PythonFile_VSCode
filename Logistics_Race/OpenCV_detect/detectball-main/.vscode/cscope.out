cscope 15 $HOME/Code_Workspace/test/opencv_cpptest -c               0000370321
	@CMakeFiles/3.27.1/CompilerIdC/CMakeCCompilerId.c

1 #ifdef 
__cplusplus


5 #if 
defined
(
__18CXX
)

6 #define 
	#ID_VOID_MAIN


	)

8 #if 
defined
(
__CLASSIC_C__
)

10 #define const

	)

11 #define volatile

	)

14 #if !
defined
(
__has_include
)

17 #define 
	#__has_include
(
x
) 0

	)

24 #if 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_C
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_C
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

160 #elif 
defined
(
__HP_cc
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_cc
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_cc
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_cc
 % 100)

	)

167 #elif 
defined
(
__DECC
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECC_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECC_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECC_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMC__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

181 #elif 
defined
(
__open_xl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "IBMClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__open_xl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__open_xl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__open_xl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__open_xl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

190 #define 
	#COMPILER_ID
 "XLClang"

	)

191 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

192 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

193 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

194 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

197 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ >= 800

198 #define 
	#COMPILER_ID
 "XL"

	)

200 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

201 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

202 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

204 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ < 800

205 #define 
	#COMPILER_ID
 "VisualAge"

	)

207 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

208 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

209 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

211 #elif 
defined
(
__NVCOMPILER
)

212 #define 
	#COMPILER_ID
 "NVHPC"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

215 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

219 #elif 
defined
(
__PGI
)

220 #define 
	#COMPILER_ID
 "PGI"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

223 #if 
defined
(
__PGIC_PATCHLEVEL__
)

224 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

227 #elif 
defined
(
_CRAYC
)

228 #define 
	#COMPILER_ID
 "Cray"

	)

229 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

230 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

232 #elif 
defined
(
__TI_COMPILER_VERSION__
)

233 #define 
	#COMPILER_ID
 "TI"

	)

235 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

236 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

237 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

239 #elif 
defined
(
__CLANG_FUJITSU
)

240 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

241 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

242 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

243 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

244 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

247 #elif 
defined
(
__FUJITSU
)

248 #define 
	#COMPILER_ID
 "Fujitsu"

	)

249 #if 
defined
(
__FCC_version__
)

250 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

251 #elif 
defined
(
__FCC_major__
)

252 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

253 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

254 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

256 #if 
defined
(
__fcc_version
)

257 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

258 #elif 
defined
(
__FCC_VERSION
)

259 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

263 #elif 
defined
(
__ghs__
)

264 #define 
	#COMPILER_ID
 "GHS"

	)

266 #ifdef 
__GHS_VERSION_NUMBER


267 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

268 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

269 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

272 #elif 
defined
(
__TASKING__
)

273 #define 
	#COMPILER_ID
 "Tasking"

	)

274 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSION__
/1000)

	)

275 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSION__
 % 100)

	)

276 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__VERSION__
)

	)

278 #elif 
defined
(
__TINYC__
)

279 #define 
	#COMPILER_ID
 "TinyCC"

	)

281 #elif 
defined
(
__BCC__
)

282 #define 
	#COMPILER_ID
 "Bruce"

	)

284 #elif 
defined
(
__SCO_VERSION__
)

285 #define 
	#COMPILER_ID
 "SCO"

	)

287 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

288 #define 
	#COMPILER_ID
 "ARMCC"

	)

289 #if 
__ARMCC_VERSION
 >= 1000000

291 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

292 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

293 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

296 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

297 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

298 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

302 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

303 #define 
	#COMPILER_ID
 "AppleClang"

	)

304 #if 
defined
(
_MSC_VER
)

305 #define 
	#SIMULATE_ID
 "MSVC"

	)

307 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

308 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

309 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

310 #if 
defined
(
_MSC_VER
)

312 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

313 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

315 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

317 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

318 #define 
	#COMPILER_ID
 "ARMClang"

	)

319 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

320 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

321 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
/100 % 100)

	)

322 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

324 #elif 
defined
(
__clang__
)

325 #define 
	#COMPILER_ID
 "Clang"

	)

326 #if 
defined
(
_MSC_VER
)

327 #define 
	#SIMULATE_ID
 "MSVC"

	)

329 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

330 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

331 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

332 #if 
defined
(
_MSC_VER
)

334 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

335 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

338 #elif 
defined
(
__LCC__
) && (defined(
__GNUC__
) || defined(
__GNUG__
) || defined(
__MCST__
))

339 #define 
	#COMPILER_ID
 "LCC"

	)

340 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__LCC__
 / 100)

	)

341 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__LCC__
 % 100)

	)

342 #if 
defined
(
__LCC_MINOR__
)

343 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__LCC_MINOR__
)

	)

345 #if 
defined
(
__GNUC__
) && defined(
__GNUC_MINOR__
)

346 #define 
	#SIMULATE_ID
 "GNU"

	)

347 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

348 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

349 #if 
defined
(
__GNUC_PATCHLEVEL__
)

350 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

354 #elif 
defined
(
__GNUC__
)

355 #define 
	#COMPILER_ID
 "GNU"

	)

356 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

357 #if 
defined
(
__GNUC_MINOR__
)

358 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

360 #if 
defined
(
__GNUC_PATCHLEVEL__
)

361 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

364 #elif 
defined
(
_MSC_VER
)

365 #define 
	#COMPILER_ID
 "MSVC"

	)

367 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

368 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

369 #if 
defined
(
_MSC_FULL_VER
)

370 #if 
_MSC_VER
 >= 1400

372 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

375 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

378 #if 
defined
(
_MSC_BUILD
)

379 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

382 #elif 
defined
(
_ADI_COMPILER
)

383 #define 
	#COMPILER_ID
 "ADSP"

	)

384 #if 
defined
(
__VERSIONNUM__
)

386 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSIONNUM__
 >> 24 & 0xFF)

	)

387 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSIONNUM__
 >> 16 & 0xFF)

	)

388 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__VERSIONNUM__
 >> 8 & 0xFF)

	)

389 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__VERSIONNUM__
 & 0xFF)

	)

392 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

393 #define 
	#COMPILER_ID
 "IAR"

	)

394 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

395 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

396 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

397 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

398 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

399 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

400 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

401 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

402 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

403 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

406 #elif 
defined
(
__SDCC_VERSION_MAJOR
) || defined(
SDCC
)

407 #define 
	#COMPILER_ID
 "SDCC"

	)

408 #if 
defined
(
__SDCC_VERSION_MAJOR
)

409 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__SDCC_VERSION_MAJOR
)

	)

410 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__SDCC_VERSION_MINOR
)

	)

411 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SDCC_VERSION_PATCH
)

	)

414 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
SDCC
/100)

	)

415 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
SDCC
/10 % 10)

	)

416 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
SDCC
 % 10)

	)

423 #elif 
defined
(
__hpux
) || defined(
__hpua
)

424 #define 
	#COMPILER_ID
 "HP"

	)

427 #define 
	#COMPILER_ID
 ""

	)

434 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

435 #ifdef 
SIMULATE_ID


436 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

439 #ifdef 
__QNXNTO__


440 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

443 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

444 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

447 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

448 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

451 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

452 #define 
	#PLATFORM_ID
 "Linux"

	)

454 #elif 
defined
(
__MSYS__
)

455 #define 
	#PLATFORM_ID
 "MSYS"

	)

457 #elif 
defined
(
__CYGWIN__
)

458 #define 
	#PLATFORM_ID
 "Cygwin"

	)

460 #elif 
defined
(
__MINGW32__
)

461 #define 
	#PLATFORM_ID
 "MinGW"

	)

463 #elif 
defined
(
__APPLE__
)

464 #define 
	#PLATFORM_ID
 "Darwin"

	)

466 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

467 #define 
	#PLATFORM_ID
 "Windows"

	)

469 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

470 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

472 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

473 #define 
	#PLATFORM_ID
 "NetBSD"

	)

475 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

476 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

478 #elif 
defined
(
__sun
) || defined(
sun
)

479 #define 
	#PLATFORM_ID
 "SunOS"

	)

481 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

482 #define 
	#PLATFORM_ID
 "AIX"

	)

484 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

485 #define 
	#PLATFORM_ID
 "HP-UX"

	)

487 #elif 
defined
(
__HAIKU__
)

488 #define 
	#PLATFORM_ID
 "Haiku"

	)

490 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

491 #define 
	#PLATFORM_ID
 "BeOS"

	)

493 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

494 #define 
	#PLATFORM_ID
 "QNX"

	)

496 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

497 #define 
	#PLATFORM_ID
 "Tru64"

	)

499 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

500 #define 
	#PLATFORM_ID
 "RISCos"

	)

502 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

503 #define 
	#PLATFORM_ID
 "SINIX"

	)

505 #elif 
defined
(
__UNIX_SV__
)

506 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

508 #elif 
defined
(
__bsdos__
)

509 #define 
	#PLATFORM_ID
 "BSDOS"

	)

511 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

512 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

514 #elif 
defined
(
__osf
) || defined(
__osf__
)

515 #define 
	#PLATFORM_ID
 "OSF1"

	)

517 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

518 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

520 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

521 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

523 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

524 #define 
	#PLATFORM_ID
 "Xenix"

	)

526 #elif 
defined
(
__WATCOMC__
)

527 #if 
defined
(
__LINUX__
)

528 #define 
	#PLATFORM_ID
 "Linux"

	)

530 #elif 
defined
(
__DOS__
)

531 #define 
	#PLATFORM_ID
 "DOS"

	)

533 #elif 
defined
(
__OS2__
)

534 #define 
	#PLATFORM_ID
 "OS2"

	)

536 #elif 
defined
(
__WINDOWS__
)

537 #define 
	#PLATFORM_ID
 "Windows3x"

	)

539 #elif 
defined
(
__VXWORKS__
)

540 #define 
	#PLATFORM_ID
 "VxWorks"

	)

543 #define 
	#PLATFORM_ID


	)

546 #elif 
defined
(
__INTEGRITY
)

547 #if 
defined
(
INT_178B
)

548 #define 
	#PLATFORM_ID
 "Integrity178"

	)

551 #define 
	#PLATFORM_ID
 "Integrity"

	)

554 #elif 
defined
(
_ADI_COMPILER
)

555 #define 
	#PLATFORM_ID
 "ADSP"

	)

558 #define 
	#PLATFORM_ID


	)

567 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

568 #if 
defined
(
_M_IA64
)

569 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

571 #elif 
defined
(
_M_ARM64EC
)

572 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

574 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

575 #define 
	#ARCHITECTURE_ID
 "x64"

	)

577 #elif 
defined
(
_M_IX86
)

578 #define 
	#ARCHITECTURE_ID
 "X86"

	)

580 #elif 
defined
(
_M_ARM64
)

581 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

583 #elif 
defined
(
_M_ARM
)

584 #if 
_M_ARM
 == 4

585 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

586 #elif 
_M_ARM
 == 5

587 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

589 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

592 #elif 
defined
(
_M_MIPS
)

593 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

595 #elif 
defined
(
_M_SH
)

596 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

599 #define 
	#ARCHITECTURE_ID
 ""

	)

602 #elif 
defined
(
__WATCOMC__
)

603 #if 
defined
(
_M_I86
)

604 #define 
	#ARCHITECTURE_ID
 "I86"

	)

606 #elif 
defined
(
_M_IX86
)

607 #define 
	#ARCHITECTURE_ID
 "X86"

	)

610 #define 
	#ARCHITECTURE_ID
 ""

	)

613 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

614 #if 
defined
(
__ICCARM__
)

615 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

617 #elif 
defined
(
__ICCRX__
)

618 #define 
	#ARCHITECTURE_ID
 "RX"

	)

620 #elif 
defined
(
__ICCRH850__
)

621 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

623 #elif 
defined
(
__ICCRL78__
)

624 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

626 #elif 
defined
(
__ICCRISCV__
)

627 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

629 #elif 
defined
(
__ICCAVR__
)

630 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

632 #elif 
defined
(
__ICC430__
)

633 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

635 #elif 
defined
(
__ICCV850__
)

636 #define 
	#ARCHITECTURE_ID
 "V850"

	)

638 #elif 
defined
(
__ICC8051__
)

639 #define 
	#ARCHITECTURE_ID
 "8051"

	)

641 #elif 
defined
(
__ICCSTM8__
)

642 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

645 #define 
	#ARCHITECTURE_ID
 ""

	)

648 #elif 
defined
(
__ghs__
)

649 #if 
defined
(
__PPC64__
)

650 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

652 #elif 
defined
(
__ppc__
)

653 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

655 #elif 
defined
(
__ARM__
)

656 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

658 #elif 
defined
(
__x86_64__
)

659 #define 
	#ARCHITECTURE_ID
 "x64"

	)

661 #elif 
defined
(
__i386__
)

662 #define 
	#ARCHITECTURE_ID
 "X86"

	)

665 #define 
	#ARCHITECTURE_ID
 ""

	)

668 #elif 
defined
(
__TI_COMPILER_VERSION__
)

669 #if 
defined
(
__TI_ARM__
)

670 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

672 #elif 
defined
(
__MSP430__
)

673 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

675 #elif 
defined
(
__TMS320C28XX__
)

676 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

678 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

679 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

682 #define 
	#ARCHITECTURE_ID
 ""

	)

685 #elif 
defined
(
__ADSPSHARC__
)

686 #define 
	#ARCHITECTURE_ID
 "SHARC"

	)

688 #elif 
defined
(
__ADSPBLACKFIN__
)

689 #define 
	#ARCHITECTURE_ID
 "Blackfin"

	)

691 #elif 
defined
(
__TASKING__
)

693 #if 
defined
(
__CTC__
) || defined(
__CPTC__
)

694 #define 
	#ARCHITECTURE_ID
 "TriCore"

	)

696 #elif 
defined
(
__CMCS__
)

697 #define 
	#ARCHITECTURE_ID
 "MCS"

	)

699 #elif 
defined
(
__CARM__
)

700 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

702 #elif 
defined
(
__CARC__
)

703 #define 
	#ARCHITECTURE_ID
 "ARC"

	)

705 #elif 
defined
(
__C51__
)

706 #define 
	#ARCHITECTURE_ID
 "8051"

	)

708 #elif 
defined
(
__CPCP__
)

709 #define 
	#ARCHITECTURE_ID
 "PCP"

	)

712 #define 
	#ARCHITECTURE_ID
 ""

	)

716 #define 
	#ARCHITECTURE_ID


	)

720 #define 
	#DEC
(
n
) \

721 ('0' + (((
n
) / 10000000)%10)), \

722 ('0' + (((
n
) / 1000000)%10)), \

723 ('0' + (((
n
) / 100000)%10)), \

724 ('0' + (((
n
) / 10000)%10)), \

725 ('0' + (((
n
) / 1000)%10)), \

726 ('0' + (((
n
) / 100)%10)), \

727 ('0' + (((
n
) / 10)%10)), \

728 ('0' + ((
n
) % 10))

	)

731 #define 
	#HEX
(
n
) \

732 ('0' + ((
n
)>>28 & 0xF)), \

733 ('0' + ((
n
)>>24 & 0xF)), \

734 ('0' + ((
n
)>>20 & 0xF)), \

735 ('0' + ((
n
)>>16 & 0xF)), \

736 ('0' + ((
n
)>>12 & 0xF)), \

737 ('0' + ((
n
)>>8 & 0xF)), \

738 ('0' + ((
n
)>>4 & 0xF)), \

739 ('0' + ((
n
) & 0xF))

	)

742 #ifdef 
COMPILER_VERSION


743 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

746 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

747 char const 
	ginfo_version
[] = {

750 
COMPILER_VERSION_MAJOR
,

751 #ifdef 
COMPILER_VERSION_MINOR


752 '.', 
COMPILER_VERSION_MINOR
,

753 #ifdef 
COMPILER_VERSION_PATCH


754 '.', 
COMPILER_VERSION_PATCH
,

755 #ifdef 
COMPILER_VERSION_TWEAK


756 '.', 
COMPILER_VERSION_TWEAK
,

764 #ifdef 
COMPILER_VERSION_INTERNAL


765 char const 
	ginfo_version_internal
[] = {

769 
COMPILER_VERSION_INTERNAL
,']','\0'};

770 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

771 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

775 #ifdef 
SIMULATE_VERSION_MAJOR


776 char const 
	ginfo_simulate_version
[] = {

779 
SIMULATE_VERSION_MAJOR
,

780 #ifdef 
SIMULATE_VERSION_MINOR


781 '.', 
SIMULATE_VERSION_MINOR
,

782 #ifdef 
SIMULATE_VERSION_PATCH


783 '.', 
SIMULATE_VERSION_PATCH
,

784 #ifdef 
SIMULATE_VERSION_TWEAK


785 '.', 
SIMULATE_VERSION_TWEAK
,

796 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

797 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

801 #if !
defined
(
__STDC__
) && !defined(
__clang__
)

802 #if 
defined
(
_MSC_VER
) || defined(
__ibmxl__
) || defined(
__IBMC__
)

803 #define 
	#C_VERSION
 "90"

	)

805 #define 
	#C_VERSION


	)

807 #elif 
__STDC_VERSION__
 > 201710L

808 #define 
	#C_VERSION
 "23"

	)

809 #elif 
__STDC_VERSION__
 >= 201710L

810 #define 
	#C_VERSION
 "17"

	)

811 #elif 
__STDC_VERSION__
 >= 201000L

812 #define 
	#C_VERSION
 "11"

	)

813 #elif 
__STDC_VERSION__
 >= 199901L

814 #define 
	#C_VERSION
 "99"

	)

816 #define 
	#C_VERSION
 "90"

	)

818 const char* 
	ginfo_language_standard_default
 =

819 "INFO" ":" "standard_default[" 
C_VERSION
 "]";

821 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

822 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || defined(
__xlC__
) || \

823 
defined
(
__TI_COMPILER_VERSION__
)) && \

824 !
defined
(
__STRICT_ANSI__
)

833 #ifdef 
ID_VOID_MAIN


834 void 
	$main
() {
	}
}

836 #if 
defined
(
__CLASSIC_C__
)

837 int 
	$main
(
argc
, 
argv
) int argc; char *argv[];

839 int 
	$main
(int 
argc
, char* 
argv
[])

842 int 
require
 = 0;

843 
require
 += 
info_compiler
[
argc
];

844 
require
 += 
info_platform
[
argc
];

845 
require
 += 
info_arch
[
argc
];

846 #ifdef 
COMPILER_VERSION_MAJOR


847 
require
 += 
info_version
[
argc
];

849 #ifdef 
COMPILER_VERSION_INTERNAL


850 
require
 += 
info_version_internal
[
argc
];

852 #ifdef 
SIMULATE_ID


853 
require
 += 
info_simulate
[
argc
];

855 #ifdef 
SIMULATE_VERSION_MAJOR


856 
require
 += 
info_simulate_version
[
argc
];

858 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

859 
require
 += 
info_cray
[
argc
];

861 
require
 += 
info_language_standard_default
[
argc
];

862 
require
 += 
info_language_extensions_default
[
argc
];

863 (void)
argv
;

864 return 
require
;

865 
	}
}

	@CMakeFiles/3.27.1/CompilerIdCXX/CMakeCXXCompilerId.cpp

4 #ifndef 
__cplusplus


8 #if !
defined
(
__has_include
)

11 #define 
	#__has_include
(
x
) 0

	)

18 #if 
defined
(
__COMO__
)

19 #define 
	#COMPILER_ID
 "Comeau"

	)

21 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__COMO_VERSION__
 / 100)

	)

22 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__COMO_VERSION__
 % 100)

	)

24 #elif 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_CC
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_CC
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

160 #elif 
defined
(
__HP_aCC
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_aCC
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_aCC
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_aCC
 % 100)

	)

167 #elif 
defined
(
__DECCXX
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECCXX_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECCXX_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECCXX_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMCPP__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

181 #elif 
defined
(
__open_xl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "IBMClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__open_xl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__open_xl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__open_xl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__open_xl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

190 #define 
	#COMPILER_ID
 "XLClang"

	)

191 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

192 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

193 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

194 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

197 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ >= 800

198 #define 
	#COMPILER_ID
 "XL"

	)

200 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

201 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

202 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

204 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ < 800

205 #define 
	#COMPILER_ID
 "VisualAge"

	)

207 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

208 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

209 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

211 #elif 
defined
(
__NVCOMPILER
)

212 #define 
	#COMPILER_ID
 "NVHPC"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

215 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

219 #elif 
defined
(
__PGI
)

220 #define 
	#COMPILER_ID
 "PGI"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

223 #if 
defined
(
__PGIC_PATCHLEVEL__
)

224 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

227 #elif 
defined
(
_CRAYC
)

228 #define 
	#COMPILER_ID
 "Cray"

	)

229 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

230 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

232 #elif 
defined
(
__TI_COMPILER_VERSION__
)

233 #define 
	#COMPILER_ID
 "TI"

	)

235 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

236 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

237 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

239 #elif 
defined
(
__CLANG_FUJITSU
)

240 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

241 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

242 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

243 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

244 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

247 #elif 
defined
(
__FUJITSU
)

248 #define 
	#COMPILER_ID
 "Fujitsu"

	)

249 #if 
defined
(
__FCC_version__
)

250 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

251 #elif 
defined
(
__FCC_major__
)

252 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

253 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

254 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

256 #if 
defined
(
__fcc_version
)

257 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

258 #elif 
defined
(
__FCC_VERSION
)

259 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

263 #elif 
defined
(
__ghs__
)

264 #define 
	#COMPILER_ID
 "GHS"

	)

266 #ifdef 
__GHS_VERSION_NUMBER


267 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

268 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

269 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

272 #elif 
defined
(
__TASKING__
)

273 #define 
	#COMPILER_ID
 "Tasking"

	)

274 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSION__
/1000)

	)

275 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSION__
 % 100)

	)

276 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__VERSION__
)

	)

278 #elif 
defined
(
__SCO_VERSION__
)

279 #define 
	#COMPILER_ID
 "SCO"

	)

281 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

282 #define 
	#COMPILER_ID
 "ARMCC"

	)

283 #if 
__ARMCC_VERSION
 >= 1000000

285 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

286 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

287 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

290 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

291 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

292 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

296 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

297 #define 
	#COMPILER_ID
 "AppleClang"

	)

298 #if 
defined
(
_MSC_VER
)

299 #define 
	#SIMULATE_ID
 "MSVC"

	)

301 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

302 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

303 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

304 #if 
defined
(
_MSC_VER
)

306 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

307 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

309 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

311 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

312 #define 
	#COMPILER_ID
 "ARMClang"

	)

313 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

314 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

315 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
/100 % 100)

	)

316 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

318 #elif 
defined
(
__clang__
)

319 #define 
	#COMPILER_ID
 "Clang"

	)

320 #if 
defined
(
_MSC_VER
)

321 #define 
	#SIMULATE_ID
 "MSVC"

	)

323 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

324 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

325 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

326 #if 
defined
(
_MSC_VER
)

328 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

329 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

332 #elif 
defined
(
__LCC__
) && (defined(
__GNUC__
) || defined(
__GNUG__
) || defined(
__MCST__
))

333 #define 
	#COMPILER_ID
 "LCC"

	)

334 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__LCC__
 / 100)

	)

335 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__LCC__
 % 100)

	)

336 #if 
defined
(
__LCC_MINOR__
)

337 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__LCC_MINOR__
)

	)

339 #if 
defined
(
__GNUC__
) && defined(
__GNUC_MINOR__
)

340 #define 
	#SIMULATE_ID
 "GNU"

	)

341 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

342 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

343 #if 
defined
(
__GNUC_PATCHLEVEL__
)

344 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

348 #elif 
defined
(
__GNUC__
) || defined(
__GNUG__
)

349 #define 
	#COMPILER_ID
 "GNU"

	)

350 #if 
defined
(
__GNUC__
)

351 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

353 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

355 #if 
defined
(
__GNUC_MINOR__
)

356 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

358 #if 
defined
(
__GNUC_PATCHLEVEL__
)

359 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

362 #elif 
defined
(
_MSC_VER
)

363 #define 
	#COMPILER_ID
 "MSVC"

	)

365 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

366 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

367 #if 
defined
(
_MSC_FULL_VER
)

368 #if 
_MSC_VER
 >= 1400

370 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

373 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

376 #if 
defined
(
_MSC_BUILD
)

377 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

380 #elif 
defined
(
_ADI_COMPILER
)

381 #define 
	#COMPILER_ID
 "ADSP"

	)

382 #if 
defined
(
__VERSIONNUM__
)

384 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSIONNUM__
 >> 24 & 0xFF)

	)

385 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSIONNUM__
 >> 16 & 0xFF)

	)

386 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__VERSIONNUM__
 >> 8 & 0xFF)

	)

387 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__VERSIONNUM__
 & 0xFF)

	)

390 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

391 #define 
	#COMPILER_ID
 "IAR"

	)

392 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

393 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

394 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

395 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

396 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

397 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

398 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

399 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

400 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

401 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

408 #elif 
defined
(
__hpux
) || defined(
__hpua
)

409 #define 
	#COMPILER_ID
 "HP"

	)

412 #define 
	#COMPILER_ID
 ""

	)

419 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

420 #ifdef 
SIMULATE_ID


421 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

424 #ifdef 
__QNXNTO__


425 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

428 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

429 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

432 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

433 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

436 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

437 #define 
	#PLATFORM_ID
 "Linux"

	)

439 #elif 
defined
(
__MSYS__
)

440 #define 
	#PLATFORM_ID
 "MSYS"

	)

442 #elif 
defined
(
__CYGWIN__
)

443 #define 
	#PLATFORM_ID
 "Cygwin"

	)

445 #elif 
defined
(
__MINGW32__
)

446 #define 
	#PLATFORM_ID
 "MinGW"

	)

448 #elif 
defined
(
__APPLE__
)

449 #define 
	#PLATFORM_ID
 "Darwin"

	)

451 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

452 #define 
	#PLATFORM_ID
 "Windows"

	)

454 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

455 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

457 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

458 #define 
	#PLATFORM_ID
 "NetBSD"

	)

460 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

461 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

463 #elif 
defined
(
__sun
) || defined(
sun
)

464 #define 
	#PLATFORM_ID
 "SunOS"

	)

466 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

467 #define 
	#PLATFORM_ID
 "AIX"

	)

469 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

470 #define 
	#PLATFORM_ID
 "HP-UX"

	)

472 #elif 
defined
(
__HAIKU__
)

473 #define 
	#PLATFORM_ID
 "Haiku"

	)

475 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

476 #define 
	#PLATFORM_ID
 "BeOS"

	)

478 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

479 #define 
	#PLATFORM_ID
 "QNX"

	)

481 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

482 #define 
	#PLATFORM_ID
 "Tru64"

	)

484 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

485 #define 
	#PLATFORM_ID
 "RISCos"

	)

487 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

488 #define 
	#PLATFORM_ID
 "SINIX"

	)

490 #elif 
defined
(
__UNIX_SV__
)

491 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

493 #elif 
defined
(
__bsdos__
)

494 #define 
	#PLATFORM_ID
 "BSDOS"

	)

496 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

497 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

499 #elif 
defined
(
__osf
) || defined(
__osf__
)

500 #define 
	#PLATFORM_ID
 "OSF1"

	)

502 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

503 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

505 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

506 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

508 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

509 #define 
	#PLATFORM_ID
 "Xenix"

	)

511 #elif 
defined
(
__WATCOMC__
)

512 #if 
defined
(
__LINUX__
)

513 #define 
	#PLATFORM_ID
 "Linux"

	)

515 #elif 
defined
(
__DOS__
)

516 #define 
	#PLATFORM_ID
 "DOS"

	)

518 #elif 
defined
(
__OS2__
)

519 #define 
	#PLATFORM_ID
 "OS2"

	)

521 #elif 
defined
(
__WINDOWS__
)

522 #define 
	#PLATFORM_ID
 "Windows3x"

	)

524 #elif 
defined
(
__VXWORKS__
)

525 #define 
	#PLATFORM_ID
 "VxWorks"

	)

528 #define 
	#PLATFORM_ID


	)

531 #elif 
defined
(
__INTEGRITY
)

532 #if 
defined
(
INT_178B
)

533 #define 
	#PLATFORM_ID
 "Integrity178"

	)

536 #define 
	#PLATFORM_ID
 "Integrity"

	)

539 #elif 
defined
(
_ADI_COMPILER
)

540 #define 
	#PLATFORM_ID
 "ADSP"

	)

543 #define 
	#PLATFORM_ID


	)

552 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

553 #if 
defined
(
_M_IA64
)

554 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

556 #elif 
defined
(
_M_ARM64EC
)

557 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

559 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

560 #define 
	#ARCHITECTURE_ID
 "x64"

	)

562 #elif 
defined
(
_M_IX86
)

563 #define 
	#ARCHITECTURE_ID
 "X86"

	)

565 #elif 
defined
(
_M_ARM64
)

566 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

568 #elif 
defined
(
_M_ARM
)

569 #if 
_M_ARM
 == 4

570 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

571 #elif 
_M_ARM
 == 5

572 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

574 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

577 #elif 
defined
(
_M_MIPS
)

578 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

580 #elif 
defined
(
_M_SH
)

581 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

584 #define 
	#ARCHITECTURE_ID
 ""

	)

587 #elif 
defined
(
__WATCOMC__
)

588 #if 
defined
(
_M_I86
)

589 #define 
	#ARCHITECTURE_ID
 "I86"

	)

591 #elif 
defined
(
_M_IX86
)

592 #define 
	#ARCHITECTURE_ID
 "X86"

	)

595 #define 
	#ARCHITECTURE_ID
 ""

	)

598 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

599 #if 
defined
(
__ICCARM__
)

600 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

602 #elif 
defined
(
__ICCRX__
)

603 #define 
	#ARCHITECTURE_ID
 "RX"

	)

605 #elif 
defined
(
__ICCRH850__
)

606 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

608 #elif 
defined
(
__ICCRL78__
)

609 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

611 #elif 
defined
(
__ICCRISCV__
)

612 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

614 #elif 
defined
(
__ICCAVR__
)

615 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

617 #elif 
defined
(
__ICC430__
)

618 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

620 #elif 
defined
(
__ICCV850__
)

621 #define 
	#ARCHITECTURE_ID
 "V850"

	)

623 #elif 
defined
(
__ICC8051__
)

624 #define 
	#ARCHITECTURE_ID
 "8051"

	)

626 #elif 
defined
(
__ICCSTM8__
)

627 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

630 #define 
	#ARCHITECTURE_ID
 ""

	)

633 #elif 
defined
(
__ghs__
)

634 #if 
defined
(
__PPC64__
)

635 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

637 #elif 
defined
(
__ppc__
)

638 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

640 #elif 
defined
(
__ARM__
)

641 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

643 #elif 
defined
(
__x86_64__
)

644 #define 
	#ARCHITECTURE_ID
 "x64"

	)

646 #elif 
defined
(
__i386__
)

647 #define 
	#ARCHITECTURE_ID
 "X86"

	)

650 #define 
	#ARCHITECTURE_ID
 ""

	)

653 #elif 
defined
(
__TI_COMPILER_VERSION__
)

654 #if 
defined
(
__TI_ARM__
)

655 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

657 #elif 
defined
(
__MSP430__
)

658 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

660 #elif 
defined
(
__TMS320C28XX__
)

661 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

663 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

664 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

667 #define 
	#ARCHITECTURE_ID
 ""

	)

670 #elif 
defined
(
__ADSPSHARC__
)

671 #define 
	#ARCHITECTURE_ID
 "SHARC"

	)

673 #elif 
defined
(
__ADSPBLACKFIN__
)

674 #define 
	#ARCHITECTURE_ID
 "Blackfin"

	)

676 #elif 
defined
(
__TASKING__
)

678 #if 
defined
(
__CTC__
) || defined(
__CPTC__
)

679 #define 
	#ARCHITECTURE_ID
 "TriCore"

	)

681 #elif 
defined
(
__CMCS__
)

682 #define 
	#ARCHITECTURE_ID
 "MCS"

	)

684 #elif 
defined
(
__CARM__
)

685 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

687 #elif 
defined
(
__CARC__
)

688 #define 
	#ARCHITECTURE_ID
 "ARC"

	)

690 #elif 
defined
(
__C51__
)

691 #define 
	#ARCHITECTURE_ID
 "8051"

	)

693 #elif 
defined
(
__CPCP__
)

694 #define 
	#ARCHITECTURE_ID
 "PCP"

	)

697 #define 
	#ARCHITECTURE_ID
 ""

	)

701 #define 
	#ARCHITECTURE_ID


	)

705 #define 
	#DEC
(
n
) \

706 ('0' + (((
n
) / 10000000)%10)), \

707 ('0' + (((
n
) / 1000000)%10)), \

708 ('0' + (((
n
) / 100000)%10)), \

709 ('0' + (((
n
) / 10000)%10)), \

710 ('0' + (((
n
) / 1000)%10)), \

711 ('0' + (((
n
) / 100)%10)), \

712 ('0' + (((
n
) / 10)%10)), \

713 ('0' + ((
n
) % 10))

	)

716 #define 
	#HEX
(
n
) \

717 ('0' + ((
n
)>>28 & 0xF)), \

718 ('0' + ((
n
)>>24 & 0xF)), \

719 ('0' + ((
n
)>>20 & 0xF)), \

720 ('0' + ((
n
)>>16 & 0xF)), \

721 ('0' + ((
n
)>>12 & 0xF)), \

722 ('0' + ((
n
)>>8 & 0xF)), \

723 ('0' + ((
n
)>>4 & 0xF)), \

724 ('0' + ((
n
) & 0xF))

	)

727 #ifdef 
COMPILER_VERSION


728 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

731 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

732 char const 
	ginfo_version
[] = {

735 
COMPILER_VERSION_MAJOR
,

736 #ifdef 
COMPILER_VERSION_MINOR


737 '.', 
COMPILER_VERSION_MINOR
,

738 #ifdef 
COMPILER_VERSION_PATCH


739 '.', 
COMPILER_VERSION_PATCH
,

740 #ifdef 
COMPILER_VERSION_TWEAK


741 '.', 
COMPILER_VERSION_TWEAK
,

749 #ifdef 
COMPILER_VERSION_INTERNAL


750 char const 
	ginfo_version_internal
[] = {

754 
COMPILER_VERSION_INTERNAL
,']','\0'};

755 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

756 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

760 #ifdef 
SIMULATE_VERSION_MAJOR


761 char const 
	ginfo_simulate_version
[] = {

764 
SIMULATE_VERSION_MAJOR
,

765 #ifdef 
SIMULATE_VERSION_MINOR


766 '.', 
SIMULATE_VERSION_MINOR
,

767 #ifdef 
SIMULATE_VERSION_PATCH


768 '.', 
SIMULATE_VERSION_PATCH
,

769 #ifdef 
SIMULATE_VERSION_TWEAK


770 '.', 
SIMULATE_VERSION_TWEAK
,

781 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

782 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

786 #if 
defined
(
__INTEL_COMPILER
) && defined(
_MSVC_LANG
) && _MSVC_LANG < 201403L

787 #if 
defined
(
__INTEL_CXX11_MODE__
)

788 #if 
defined
(
__cpp_aggregate_nsdmi
)

789 #define 
	#CXX_STD
 201402L

	)

791 #define 
	#CXX_STD
 201103L

	)

794 #define 
	#CXX_STD
 199711L

	)

796 #elif 
defined
(
_MSC_VER
) && defined(
_MSVC_LANG
)

797 #define 
	#CXX_STD
 
_MSVC_LANG


	)

799 #define 
	#CXX_STD
 
__cplusplus


	)

802 const char* 
	ginfo_language_standard_default
 = "INFO" ":" "standard_default["

803 #if 
CXX_STD
 > 202002L

805 #elif 
CXX_STD
 > 201703L

807 #elif 
CXX_STD
 >= 201703L

809 #elif 
CXX_STD
 >= 201402L

811 #elif 
CXX_STD
 >= 201103L

818 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

819 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || defined(
__xlC__
) || \

820 
defined
(
__TI_COMPILER_VERSION__
)) && \

821 !
defined
(
__STRICT_ANSI__
)

830 int 
	$main
(int 
argc
, char* 
argv
[])

832 int 
require
 = 0;

833 
require
 += 
info_compiler
[
argc
];

834 
require
 += 
info_platform
[
argc
];

835 
require
 += 
info_arch
[
argc
];

836 #ifdef 
COMPILER_VERSION_MAJOR


837 
require
 += 
info_version
[
argc
];

839 #ifdef 
COMPILER_VERSION_INTERNAL


840 
require
 += 
info_version_internal
[
argc
];

842 #ifdef 
SIMULATE_ID


843 
require
 += 
info_simulate
[
argc
];

845 #ifdef 
SIMULATE_VERSION_MAJOR


846 
require
 += 
info_simulate_version
[
argc
];

848 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

849 
require
 += 
info_cray
[
argc
];

851 
require
 += 
info_language_standard_default
[
argc
];

852 
require
 += 
info_language_extensions_default
[
argc
];

853 (void)
argv
;

854 return 
require
;

855 
	}
}

	@build/CMakeFiles/3.27.1/CompilerIdC/CMakeCCompilerId.c

1 #ifdef 
__cplusplus


5 #if 
defined
(
__18CXX
)

6 #define 
	#ID_VOID_MAIN


	)

8 #if 
defined
(
__CLASSIC_C__
)

10 #define const

	)

11 #define volatile

	)

14 #if !
defined
(
__has_include
)

17 #define 
	#__has_include
(
x
) 0

	)

24 #if 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_C
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_C
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

160 #elif 
defined
(
__HP_cc
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_cc
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_cc
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_cc
 % 100)

	)

167 #elif 
defined
(
__DECC
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECC_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECC_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECC_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMC__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

181 #elif 
defined
(
__open_xl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "IBMClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__open_xl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__open_xl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__open_xl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__open_xl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

190 #define 
	#COMPILER_ID
 "XLClang"

	)

191 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

192 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

193 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

194 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

197 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ >= 800

198 #define 
	#COMPILER_ID
 "XL"

	)

200 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

201 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

202 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

204 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ < 800

205 #define 
	#COMPILER_ID
 "VisualAge"

	)

207 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

208 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

209 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

211 #elif 
defined
(
__NVCOMPILER
)

212 #define 
	#COMPILER_ID
 "NVHPC"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

215 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

219 #elif 
defined
(
__PGI
)

220 #define 
	#COMPILER_ID
 "PGI"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

223 #if 
defined
(
__PGIC_PATCHLEVEL__
)

224 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

227 #elif 
defined
(
_CRAYC
)

228 #define 
	#COMPILER_ID
 "Cray"

	)

229 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

230 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

232 #elif 
defined
(
__TI_COMPILER_VERSION__
)

233 #define 
	#COMPILER_ID
 "TI"

	)

235 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

236 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

237 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

239 #elif 
defined
(
__CLANG_FUJITSU
)

240 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

241 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

242 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

243 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

244 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

247 #elif 
defined
(
__FUJITSU
)

248 #define 
	#COMPILER_ID
 "Fujitsu"

	)

249 #if 
defined
(
__FCC_version__
)

250 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

251 #elif 
defined
(
__FCC_major__
)

252 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

253 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

254 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

256 #if 
defined
(
__fcc_version
)

257 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

258 #elif 
defined
(
__FCC_VERSION
)

259 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

263 #elif 
defined
(
__ghs__
)

264 #define 
	#COMPILER_ID
 "GHS"

	)

266 #ifdef 
__GHS_VERSION_NUMBER


267 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

268 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

269 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

272 #elif 
defined
(
__TASKING__
)

273 #define 
	#COMPILER_ID
 "Tasking"

	)

274 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSION__
/1000)

	)

275 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSION__
 % 100)

	)

276 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__VERSION__
)

	)

278 #elif 
defined
(
__TINYC__
)

279 #define 
	#COMPILER_ID
 "TinyCC"

	)

281 #elif 
defined
(
__BCC__
)

282 #define 
	#COMPILER_ID
 "Bruce"

	)

284 #elif 
defined
(
__SCO_VERSION__
)

285 #define 
	#COMPILER_ID
 "SCO"

	)

287 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

288 #define 
	#COMPILER_ID
 "ARMCC"

	)

289 #if 
__ARMCC_VERSION
 >= 1000000

291 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

292 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

293 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

296 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

297 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

298 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

302 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

303 #define 
	#COMPILER_ID
 "AppleClang"

	)

304 #if 
defined
(
_MSC_VER
)

305 #define 
	#SIMULATE_ID
 "MSVC"

	)

307 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

308 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

309 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

310 #if 
defined
(
_MSC_VER
)

312 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

313 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

315 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

317 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

318 #define 
	#COMPILER_ID
 "ARMClang"

	)

319 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

320 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

321 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
/100 % 100)

	)

322 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

324 #elif 
defined
(
__clang__
)

325 #define 
	#COMPILER_ID
 "Clang"

	)

326 #if 
defined
(
_MSC_VER
)

327 #define 
	#SIMULATE_ID
 "MSVC"

	)

329 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

330 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

331 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

332 #if 
defined
(
_MSC_VER
)

334 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

335 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

338 #elif 
defined
(
__LCC__
) && (defined(
__GNUC__
) || defined(
__GNUG__
) || defined(
__MCST__
))

339 #define 
	#COMPILER_ID
 "LCC"

	)

340 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__LCC__
 / 100)

	)

341 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__LCC__
 % 100)

	)

342 #if 
defined
(
__LCC_MINOR__
)

343 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__LCC_MINOR__
)

	)

345 #if 
defined
(
__GNUC__
) && defined(
__GNUC_MINOR__
)

346 #define 
	#SIMULATE_ID
 "GNU"

	)

347 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

348 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

349 #if 
defined
(
__GNUC_PATCHLEVEL__
)

350 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

354 #elif 
defined
(
__GNUC__
)

355 #define 
	#COMPILER_ID
 "GNU"

	)

356 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

357 #if 
defined
(
__GNUC_MINOR__
)

358 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

360 #if 
defined
(
__GNUC_PATCHLEVEL__
)

361 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

364 #elif 
defined
(
_MSC_VER
)

365 #define 
	#COMPILER_ID
 "MSVC"

	)

367 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

368 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

369 #if 
defined
(
_MSC_FULL_VER
)

370 #if 
_MSC_VER
 >= 1400

372 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

375 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

378 #if 
defined
(
_MSC_BUILD
)

379 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

382 #elif 
defined
(
_ADI_COMPILER
)

383 #define 
	#COMPILER_ID
 "ADSP"

	)

384 #if 
defined
(
__VERSIONNUM__
)

386 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSIONNUM__
 >> 24 & 0xFF)

	)

387 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSIONNUM__
 >> 16 & 0xFF)

	)

388 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__VERSIONNUM__
 >> 8 & 0xFF)

	)

389 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__VERSIONNUM__
 & 0xFF)

	)

392 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

393 #define 
	#COMPILER_ID
 "IAR"

	)

394 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

395 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

396 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

397 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

398 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

399 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

400 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

401 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

402 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

403 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

406 #elif 
defined
(
__SDCC_VERSION_MAJOR
) || defined(
SDCC
)

407 #define 
	#COMPILER_ID
 "SDCC"

	)

408 #if 
defined
(
__SDCC_VERSION_MAJOR
)

409 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__SDCC_VERSION_MAJOR
)

	)

410 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__SDCC_VERSION_MINOR
)

	)

411 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SDCC_VERSION_PATCH
)

	)

414 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
SDCC
/100)

	)

415 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
SDCC
/10 % 10)

	)

416 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
SDCC
 % 10)

	)

423 #elif 
defined
(
__hpux
) || defined(
__hpua
)

424 #define 
	#COMPILER_ID
 "HP"

	)

427 #define 
	#COMPILER_ID
 ""

	)

434 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

435 #ifdef 
SIMULATE_ID


436 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

439 #ifdef 
__QNXNTO__


440 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

443 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

444 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

447 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

448 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

451 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

452 #define 
	#PLATFORM_ID
 "Linux"

	)

454 #elif 
defined
(
__MSYS__
)

455 #define 
	#PLATFORM_ID
 "MSYS"

	)

457 #elif 
defined
(
__CYGWIN__
)

458 #define 
	#PLATFORM_ID
 "Cygwin"

	)

460 #elif 
defined
(
__MINGW32__
)

461 #define 
	#PLATFORM_ID
 "MinGW"

	)

463 #elif 
defined
(
__APPLE__
)

464 #define 
	#PLATFORM_ID
 "Darwin"

	)

466 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

467 #define 
	#PLATFORM_ID
 "Windows"

	)

469 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

470 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

472 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

473 #define 
	#PLATFORM_ID
 "NetBSD"

	)

475 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

476 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

478 #elif 
defined
(
__sun
) || defined(
sun
)

479 #define 
	#PLATFORM_ID
 "SunOS"

	)

481 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

482 #define 
	#PLATFORM_ID
 "AIX"

	)

484 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

485 #define 
	#PLATFORM_ID
 "HP-UX"

	)

487 #elif 
defined
(
__HAIKU__
)

488 #define 
	#PLATFORM_ID
 "Haiku"

	)

490 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

491 #define 
	#PLATFORM_ID
 "BeOS"

	)

493 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

494 #define 
	#PLATFORM_ID
 "QNX"

	)

496 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

497 #define 
	#PLATFORM_ID
 "Tru64"

	)

499 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

500 #define 
	#PLATFORM_ID
 "RISCos"

	)

502 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

503 #define 
	#PLATFORM_ID
 "SINIX"

	)

505 #elif 
defined
(
__UNIX_SV__
)

506 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

508 #elif 
defined
(
__bsdos__
)

509 #define 
	#PLATFORM_ID
 "BSDOS"

	)

511 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

512 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

514 #elif 
defined
(
__osf
) || defined(
__osf__
)

515 #define 
	#PLATFORM_ID
 "OSF1"

	)

517 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

518 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

520 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

521 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

523 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

524 #define 
	#PLATFORM_ID
 "Xenix"

	)

526 #elif 
defined
(
__WATCOMC__
)

527 #if 
defined
(
__LINUX__
)

528 #define 
	#PLATFORM_ID
 "Linux"

	)

530 #elif 
defined
(
__DOS__
)

531 #define 
	#PLATFORM_ID
 "DOS"

	)

533 #elif 
defined
(
__OS2__
)

534 #define 
	#PLATFORM_ID
 "OS2"

	)

536 #elif 
defined
(
__WINDOWS__
)

537 #define 
	#PLATFORM_ID
 "Windows3x"

	)

539 #elif 
defined
(
__VXWORKS__
)

540 #define 
	#PLATFORM_ID
 "VxWorks"

	)

543 #define 
	#PLATFORM_ID


	)

546 #elif 
defined
(
__INTEGRITY
)

547 #if 
defined
(
INT_178B
)

548 #define 
	#PLATFORM_ID
 "Integrity178"

	)

551 #define 
	#PLATFORM_ID
 "Integrity"

	)

554 #elif 
defined
(
_ADI_COMPILER
)

555 #define 
	#PLATFORM_ID
 "ADSP"

	)

558 #define 
	#PLATFORM_ID


	)

567 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

568 #if 
defined
(
_M_IA64
)

569 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

571 #elif 
defined
(
_M_ARM64EC
)

572 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

574 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

575 #define 
	#ARCHITECTURE_ID
 "x64"

	)

577 #elif 
defined
(
_M_IX86
)

578 #define 
	#ARCHITECTURE_ID
 "X86"

	)

580 #elif 
defined
(
_M_ARM64
)

581 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

583 #elif 
defined
(
_M_ARM
)

584 #if 
_M_ARM
 == 4

585 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

586 #elif 
_M_ARM
 == 5

587 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

589 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

592 #elif 
defined
(
_M_MIPS
)

593 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

595 #elif 
defined
(
_M_SH
)

596 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

599 #define 
	#ARCHITECTURE_ID
 ""

	)

602 #elif 
defined
(
__WATCOMC__
)

603 #if 
defined
(
_M_I86
)

604 #define 
	#ARCHITECTURE_ID
 "I86"

	)

606 #elif 
defined
(
_M_IX86
)

607 #define 
	#ARCHITECTURE_ID
 "X86"

	)

610 #define 
	#ARCHITECTURE_ID
 ""

	)

613 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

614 #if 
defined
(
__ICCARM__
)

615 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

617 #elif 
defined
(
__ICCRX__
)

618 #define 
	#ARCHITECTURE_ID
 "RX"

	)

620 #elif 
defined
(
__ICCRH850__
)

621 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

623 #elif 
defined
(
__ICCRL78__
)

624 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

626 #elif 
defined
(
__ICCRISCV__
)

627 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

629 #elif 
defined
(
__ICCAVR__
)

630 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

632 #elif 
defined
(
__ICC430__
)

633 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

635 #elif 
defined
(
__ICCV850__
)

636 #define 
	#ARCHITECTURE_ID
 "V850"

	)

638 #elif 
defined
(
__ICC8051__
)

639 #define 
	#ARCHITECTURE_ID
 "8051"

	)

641 #elif 
defined
(
__ICCSTM8__
)

642 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

645 #define 
	#ARCHITECTURE_ID
 ""

	)

648 #elif 
defined
(
__ghs__
)

649 #if 
defined
(
__PPC64__
)

650 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

652 #elif 
defined
(
__ppc__
)

653 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

655 #elif 
defined
(
__ARM__
)

656 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

658 #elif 
defined
(
__x86_64__
)

659 #define 
	#ARCHITECTURE_ID
 "x64"

	)

661 #elif 
defined
(
__i386__
)

662 #define 
	#ARCHITECTURE_ID
 "X86"

	)

665 #define 
	#ARCHITECTURE_ID
 ""

	)

668 #elif 
defined
(
__TI_COMPILER_VERSION__
)

669 #if 
defined
(
__TI_ARM__
)

670 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

672 #elif 
defined
(
__MSP430__
)

673 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

675 #elif 
defined
(
__TMS320C28XX__
)

676 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

678 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

679 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

682 #define 
	#ARCHITECTURE_ID
 ""

	)

685 #elif 
defined
(
__ADSPSHARC__
)

686 #define 
	#ARCHITECTURE_ID
 "SHARC"

	)

688 #elif 
defined
(
__ADSPBLACKFIN__
)

689 #define 
	#ARCHITECTURE_ID
 "Blackfin"

	)

691 #elif 
defined
(
__TASKING__
)

693 #if 
defined
(
__CTC__
) || defined(
__CPTC__
)

694 #define 
	#ARCHITECTURE_ID
 "TriCore"

	)

696 #elif 
defined
(
__CMCS__
)

697 #define 
	#ARCHITECTURE_ID
 "MCS"

	)

699 #elif 
defined
(
__CARM__
)

700 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

702 #elif 
defined
(
__CARC__
)

703 #define 
	#ARCHITECTURE_ID
 "ARC"

	)

705 #elif 
defined
(
__C51__
)

706 #define 
	#ARCHITECTURE_ID
 "8051"

	)

708 #elif 
defined
(
__CPCP__
)

709 #define 
	#ARCHITECTURE_ID
 "PCP"

	)

712 #define 
	#ARCHITECTURE_ID
 ""

	)

716 #define 
	#ARCHITECTURE_ID


	)

720 #define 
	#DEC
(
n
) \

721 ('0' + (((
n
) / 10000000)%10)), \

722 ('0' + (((
n
) / 1000000)%10)), \

723 ('0' + (((
n
) / 100000)%10)), \

724 ('0' + (((
n
) / 10000)%10)), \

725 ('0' + (((
n
) / 1000)%10)), \

726 ('0' + (((
n
) / 100)%10)), \

727 ('0' + (((
n
) / 10)%10)), \

728 ('0' + ((
n
) % 10))

	)

731 #define 
	#HEX
(
n
) \

732 ('0' + ((
n
)>>28 & 0xF)), \

733 ('0' + ((
n
)>>24 & 0xF)), \

734 ('0' + ((
n
)>>20 & 0xF)), \

735 ('0' + ((
n
)>>16 & 0xF)), \

736 ('0' + ((
n
)>>12 & 0xF)), \

737 ('0' + ((
n
)>>8 & 0xF)), \

738 ('0' + ((
n
)>>4 & 0xF)), \

739 ('0' + ((
n
) & 0xF))

	)

742 #ifdef 
COMPILER_VERSION


743 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

746 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

747 char const 
	ginfo_version
[] = {

750 
COMPILER_VERSION_MAJOR
,

751 #ifdef 
COMPILER_VERSION_MINOR


752 '.', 
COMPILER_VERSION_MINOR
,

753 #ifdef 
COMPILER_VERSION_PATCH


754 '.', 
COMPILER_VERSION_PATCH
,

755 #ifdef 
COMPILER_VERSION_TWEAK


756 '.', 
COMPILER_VERSION_TWEAK
,

764 #ifdef 
COMPILER_VERSION_INTERNAL


765 char const 
	ginfo_version_internal
[] = {

769 
COMPILER_VERSION_INTERNAL
,']','\0'};

770 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

771 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

775 #ifdef 
SIMULATE_VERSION_MAJOR


776 char const 
	ginfo_simulate_version
[] = {

779 
SIMULATE_VERSION_MAJOR
,

780 #ifdef 
SIMULATE_VERSION_MINOR


781 '.', 
SIMULATE_VERSION_MINOR
,

782 #ifdef 
SIMULATE_VERSION_PATCH


783 '.', 
SIMULATE_VERSION_PATCH
,

784 #ifdef 
SIMULATE_VERSION_TWEAK


785 '.', 
SIMULATE_VERSION_TWEAK
,

796 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

797 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

801 #if !
defined
(
__STDC__
) && !defined(
__clang__
)

802 #if 
defined
(
_MSC_VER
) || defined(
__ibmxl__
) || defined(
__IBMC__
)

803 #define 
	#C_VERSION
 "90"

	)

805 #define 
	#C_VERSION


	)

807 #elif 
__STDC_VERSION__
 > 201710L

808 #define 
	#C_VERSION
 "23"

	)

809 #elif 
__STDC_VERSION__
 >= 201710L

810 #define 
	#C_VERSION
 "17"

	)

811 #elif 
__STDC_VERSION__
 >= 201000L

812 #define 
	#C_VERSION
 "11"

	)

813 #elif 
__STDC_VERSION__
 >= 199901L

814 #define 
	#C_VERSION
 "99"

	)

816 #define 
	#C_VERSION
 "90"

	)

818 const char* 
	ginfo_language_standard_default
 =

819 "INFO" ":" "standard_default[" 
C_VERSION
 "]";

821 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

822 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || defined(
__xlC__
) || \

823 
defined
(
__TI_COMPILER_VERSION__
)) && \

824 !
defined
(
__STRICT_ANSI__
)

833 #ifdef 
ID_VOID_MAIN


834 void 
	$main
() {
	}
}

836 #if 
defined
(
__CLASSIC_C__
)

837 int 
	$main
(
argc
, 
argv
) int argc; char *argv[];

839 int 
	$main
(int 
argc
, char* 
argv
[])

842 int 
require
 = 0;

843 
require
 += 
info_compiler
[
argc
];

844 
require
 += 
info_platform
[
argc
];

845 
require
 += 
info_arch
[
argc
];

846 #ifdef 
COMPILER_VERSION_MAJOR


847 
require
 += 
info_version
[
argc
];

849 #ifdef 
COMPILER_VERSION_INTERNAL


850 
require
 += 
info_version_internal
[
argc
];

852 #ifdef 
SIMULATE_ID


853 
require
 += 
info_simulate
[
argc
];

855 #ifdef 
SIMULATE_VERSION_MAJOR


856 
require
 += 
info_simulate_version
[
argc
];

858 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

859 
require
 += 
info_cray
[
argc
];

861 
require
 += 
info_language_standard_default
[
argc
];

862 
require
 += 
info_language_extensions_default
[
argc
];

863 (void)
argv
;

864 return 
require
;

865 
	}
}

	@build/CMakeFiles/3.27.1/CompilerIdCXX/CMakeCXXCompilerId.cpp

4 #ifndef 
__cplusplus


8 #if !
defined
(
__has_include
)

11 #define 
	#__has_include
(
x
) 0

	)

18 #if 
defined
(
__COMO__
)

19 #define 
	#COMPILER_ID
 "Comeau"

	)

21 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__COMO_VERSION__
 / 100)

	)

22 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__COMO_VERSION__
 % 100)

	)

24 #elif 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_CC
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_CC
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

160 #elif 
defined
(
__HP_aCC
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_aCC
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_aCC
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_aCC
 % 100)

	)

167 #elif 
defined
(
__DECCXX
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECCXX_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECCXX_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECCXX_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMCPP__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

181 #elif 
defined
(
__open_xl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "IBMClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__open_xl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__open_xl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__open_xl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__open_xl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

190 #define 
	#COMPILER_ID
 "XLClang"

	)

191 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

192 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

193 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

194 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

197 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ >= 800

198 #define 
	#COMPILER_ID
 "XL"

	)

200 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

201 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

202 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

204 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ < 800

205 #define 
	#COMPILER_ID
 "VisualAge"

	)

207 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

208 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

209 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

211 #elif 
defined
(
__NVCOMPILER
)

212 #define 
	#COMPILER_ID
 "NVHPC"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

215 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

219 #elif 
defined
(
__PGI
)

220 #define 
	#COMPILER_ID
 "PGI"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

223 #if 
defined
(
__PGIC_PATCHLEVEL__
)

224 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

227 #elif 
defined
(
_CRAYC
)

228 #define 
	#COMPILER_ID
 "Cray"

	)

229 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

230 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

232 #elif 
defined
(
__TI_COMPILER_VERSION__
)

233 #define 
	#COMPILER_ID
 "TI"

	)

235 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

236 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

237 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

239 #elif 
defined
(
__CLANG_FUJITSU
)

240 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

241 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

242 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

243 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

244 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

247 #elif 
defined
(
__FUJITSU
)

248 #define 
	#COMPILER_ID
 "Fujitsu"

	)

249 #if 
defined
(
__FCC_version__
)

250 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

251 #elif 
defined
(
__FCC_major__
)

252 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

253 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

254 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

256 #if 
defined
(
__fcc_version
)

257 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

258 #elif 
defined
(
__FCC_VERSION
)

259 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

263 #elif 
defined
(
__ghs__
)

264 #define 
	#COMPILER_ID
 "GHS"

	)

266 #ifdef 
__GHS_VERSION_NUMBER


267 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

268 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

269 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

272 #elif 
defined
(
__TASKING__
)

273 #define 
	#COMPILER_ID
 "Tasking"

	)

274 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSION__
/1000)

	)

275 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSION__
 % 100)

	)

276 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__VERSION__
)

	)

278 #elif 
defined
(
__SCO_VERSION__
)

279 #define 
	#COMPILER_ID
 "SCO"

	)

281 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

282 #define 
	#COMPILER_ID
 "ARMCC"

	)

283 #if 
__ARMCC_VERSION
 >= 1000000

285 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

286 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

287 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

290 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

291 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

292 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

296 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

297 #define 
	#COMPILER_ID
 "AppleClang"

	)

298 #if 
defined
(
_MSC_VER
)

299 #define 
	#SIMULATE_ID
 "MSVC"

	)

301 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

302 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

303 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

304 #if 
defined
(
_MSC_VER
)

306 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

307 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

309 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

311 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

312 #define 
	#COMPILER_ID
 "ARMClang"

	)

313 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

314 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

315 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
/100 % 100)

	)

316 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

318 #elif 
defined
(
__clang__
)

319 #define 
	#COMPILER_ID
 "Clang"

	)

320 #if 
defined
(
_MSC_VER
)

321 #define 
	#SIMULATE_ID
 "MSVC"

	)

323 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

324 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

325 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

326 #if 
defined
(
_MSC_VER
)

328 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

329 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

332 #elif 
defined
(
__LCC__
) && (defined(
__GNUC__
) || defined(
__GNUG__
) || defined(
__MCST__
))

333 #define 
	#COMPILER_ID
 "LCC"

	)

334 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__LCC__
 / 100)

	)

335 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__LCC__
 % 100)

	)

336 #if 
defined
(
__LCC_MINOR__
)

337 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__LCC_MINOR__
)

	)

339 #if 
defined
(
__GNUC__
) && defined(
__GNUC_MINOR__
)

340 #define 
	#SIMULATE_ID
 "GNU"

	)

341 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

342 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

343 #if 
defined
(
__GNUC_PATCHLEVEL__
)

344 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

348 #elif 
defined
(
__GNUC__
) || defined(
__GNUG__
)

349 #define 
	#COMPILER_ID
 "GNU"

	)

350 #if 
defined
(
__GNUC__
)

351 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

353 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

355 #if 
defined
(
__GNUC_MINOR__
)

356 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

358 #if 
defined
(
__GNUC_PATCHLEVEL__
)

359 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

362 #elif 
defined
(
_MSC_VER
)

363 #define 
	#COMPILER_ID
 "MSVC"

	)

365 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

366 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

367 #if 
defined
(
_MSC_FULL_VER
)

368 #if 
_MSC_VER
 >= 1400

370 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

373 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

376 #if 
defined
(
_MSC_BUILD
)

377 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

380 #elif 
defined
(
_ADI_COMPILER
)

381 #define 
	#COMPILER_ID
 "ADSP"

	)

382 #if 
defined
(
__VERSIONNUM__
)

384 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__VERSIONNUM__
 >> 24 & 0xFF)

	)

385 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__VERSIONNUM__
 >> 16 & 0xFF)

	)

386 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__VERSIONNUM__
 >> 8 & 0xFF)

	)

387 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__VERSIONNUM__
 & 0xFF)

	)

390 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

391 #define 
	#COMPILER_ID
 "IAR"

	)

392 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

393 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

394 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

395 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

396 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

397 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

398 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

399 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

400 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

401 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

408 #elif 
defined
(
__hpux
) || defined(
__hpua
)

409 #define 
	#COMPILER_ID
 "HP"

	)

412 #define 
	#COMPILER_ID
 ""

	)

419 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

420 #ifdef 
SIMULATE_ID


421 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

424 #ifdef 
__QNXNTO__


425 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

428 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

429 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

432 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

433 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

436 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

437 #define 
	#PLATFORM_ID
 "Linux"

	)

439 #elif 
defined
(
__MSYS__
)

440 #define 
	#PLATFORM_ID
 "MSYS"

	)

442 #elif 
defined
(
__CYGWIN__
)

443 #define 
	#PLATFORM_ID
 "Cygwin"

	)

445 #elif 
defined
(
__MINGW32__
)

446 #define 
	#PLATFORM_ID
 "MinGW"

	)

448 #elif 
defined
(
__APPLE__
)

449 #define 
	#PLATFORM_ID
 "Darwin"

	)

451 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

452 #define 
	#PLATFORM_ID
 "Windows"

	)

454 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

455 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

457 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

458 #define 
	#PLATFORM_ID
 "NetBSD"

	)

460 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

461 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

463 #elif 
defined
(
__sun
) || defined(
sun
)

464 #define 
	#PLATFORM_ID
 "SunOS"

	)

466 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

467 #define 
	#PLATFORM_ID
 "AIX"

	)

469 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

470 #define 
	#PLATFORM_ID
 "HP-UX"

	)

472 #elif 
defined
(
__HAIKU__
)

473 #define 
	#PLATFORM_ID
 "Haiku"

	)

475 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

476 #define 
	#PLATFORM_ID
 "BeOS"

	)

478 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

479 #define 
	#PLATFORM_ID
 "QNX"

	)

481 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

482 #define 
	#PLATFORM_ID
 "Tru64"

	)

484 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

485 #define 
	#PLATFORM_ID
 "RISCos"

	)

487 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

488 #define 
	#PLATFORM_ID
 "SINIX"

	)

490 #elif 
defined
(
__UNIX_SV__
)

491 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

493 #elif 
defined
(
__bsdos__
)

494 #define 
	#PLATFORM_ID
 "BSDOS"

	)

496 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

497 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

499 #elif 
defined
(
__osf
) || defined(
__osf__
)

500 #define 
	#PLATFORM_ID
 "OSF1"

	)

502 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

503 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

505 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

506 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

508 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

509 #define 
	#PLATFORM_ID
 "Xenix"

	)

511 #elif 
defined
(
__WATCOMC__
)

512 #if 
defined
(
__LINUX__
)

513 #define 
	#PLATFORM_ID
 "Linux"

	)

515 #elif 
defined
(
__DOS__
)

516 #define 
	#PLATFORM_ID
 "DOS"

	)

518 #elif 
defined
(
__OS2__
)

519 #define 
	#PLATFORM_ID
 "OS2"

	)

521 #elif 
defined
(
__WINDOWS__
)

522 #define 
	#PLATFORM_ID
 "Windows3x"

	)

524 #elif 
defined
(
__VXWORKS__
)

525 #define 
	#PLATFORM_ID
 "VxWorks"

	)

528 #define 
	#PLATFORM_ID


	)

531 #elif 
defined
(
__INTEGRITY
)

532 #if 
defined
(
INT_178B
)

533 #define 
	#PLATFORM_ID
 "Integrity178"

	)

536 #define 
	#PLATFORM_ID
 "Integrity"

	)

539 #elif 
defined
(
_ADI_COMPILER
)

540 #define 
	#PLATFORM_ID
 "ADSP"

	)

543 #define 
	#PLATFORM_ID


	)

552 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

553 #if 
defined
(
_M_IA64
)

554 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

556 #elif 
defined
(
_M_ARM64EC
)

557 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

559 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

560 #define 
	#ARCHITECTURE_ID
 "x64"

	)

562 #elif 
defined
(
_M_IX86
)

563 #define 
	#ARCHITECTURE_ID
 "X86"

	)

565 #elif 
defined
(
_M_ARM64
)

566 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

568 #elif 
defined
(
_M_ARM
)

569 #if 
_M_ARM
 == 4

570 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

571 #elif 
_M_ARM
 == 5

572 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

574 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

577 #elif 
defined
(
_M_MIPS
)

578 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

580 #elif 
defined
(
_M_SH
)

581 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

584 #define 
	#ARCHITECTURE_ID
 ""

	)

587 #elif 
defined
(
__WATCOMC__
)

588 #if 
defined
(
_M_I86
)

589 #define 
	#ARCHITECTURE_ID
 "I86"

	)

591 #elif 
defined
(
_M_IX86
)

592 #define 
	#ARCHITECTURE_ID
 "X86"

	)

595 #define 
	#ARCHITECTURE_ID
 ""

	)

598 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

599 #if 
defined
(
__ICCARM__
)

600 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

602 #elif 
defined
(
__ICCRX__
)

603 #define 
	#ARCHITECTURE_ID
 "RX"

	)

605 #elif 
defined
(
__ICCRH850__
)

606 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

608 #elif 
defined
(
__ICCRL78__
)

609 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

611 #elif 
defined
(
__ICCRISCV__
)

612 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

614 #elif 
defined
(
__ICCAVR__
)

615 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

617 #elif 
defined
(
__ICC430__
)

618 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

620 #elif 
defined
(
__ICCV850__
)

621 #define 
	#ARCHITECTURE_ID
 "V850"

	)

623 #elif 
defined
(
__ICC8051__
)

624 #define 
	#ARCHITECTURE_ID
 "8051"

	)

626 #elif 
defined
(
__ICCSTM8__
)

627 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

630 #define 
	#ARCHITECTURE_ID
 ""

	)

633 #elif 
defined
(
__ghs__
)

634 #if 
defined
(
__PPC64__
)

635 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

637 #elif 
defined
(
__ppc__
)

638 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

640 #elif 
defined
(
__ARM__
)

641 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

643 #elif 
defined
(
__x86_64__
)

644 #define 
	#ARCHITECTURE_ID
 "x64"

	)

646 #elif 
defined
(
__i386__
)

647 #define 
	#ARCHITECTURE_ID
 "X86"

	)

650 #define 
	#ARCHITECTURE_ID
 ""

	)

653 #elif 
defined
(
__TI_COMPILER_VERSION__
)

654 #if 
defined
(
__TI_ARM__
)

655 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

657 #elif 
defined
(
__MSP430__
)

658 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

660 #elif 
defined
(
__TMS320C28XX__
)

661 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

663 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

664 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

667 #define 
	#ARCHITECTURE_ID
 ""

	)

670 #elif 
defined
(
__ADSPSHARC__
)

671 #define 
	#ARCHITECTURE_ID
 "SHARC"

	)

673 #elif 
defined
(
__ADSPBLACKFIN__
)

674 #define 
	#ARCHITECTURE_ID
 "Blackfin"

	)

676 #elif 
defined
(
__TASKING__
)

678 #if 
defined
(
__CTC__
) || defined(
__CPTC__
)

679 #define 
	#ARCHITECTURE_ID
 "TriCore"

	)

681 #elif 
defined
(
__CMCS__
)

682 #define 
	#ARCHITECTURE_ID
 "MCS"

	)

684 #elif 
defined
(
__CARM__
)

685 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

687 #elif 
defined
(
__CARC__
)

688 #define 
	#ARCHITECTURE_ID
 "ARC"

	)

690 #elif 
defined
(
__C51__
)

691 #define 
	#ARCHITECTURE_ID
 "8051"

	)

693 #elif 
defined
(
__CPCP__
)

694 #define 
	#ARCHITECTURE_ID
 "PCP"

	)

697 #define 
	#ARCHITECTURE_ID
 ""

	)

701 #define 
	#ARCHITECTURE_ID


	)

705 #define 
	#DEC
(
n
) \

706 ('0' + (((
n
) / 10000000)%10)), \

707 ('0' + (((
n
) / 1000000)%10)), \

708 ('0' + (((
n
) / 100000)%10)), \

709 ('0' + (((
n
) / 10000)%10)), \

710 ('0' + (((
n
) / 1000)%10)), \

711 ('0' + (((
n
) / 100)%10)), \

712 ('0' + (((
n
) / 10)%10)), \

713 ('0' + ((
n
) % 10))

	)

716 #define 
	#HEX
(
n
) \

717 ('0' + ((
n
)>>28 & 0xF)), \

718 ('0' + ((
n
)>>24 & 0xF)), \

719 ('0' + ((
n
)>>20 & 0xF)), \

720 ('0' + ((
n
)>>16 & 0xF)), \

721 ('0' + ((
n
)>>12 & 0xF)), \

722 ('0' + ((
n
)>>8 & 0xF)), \

723 ('0' + ((
n
)>>4 & 0xF)), \

724 ('0' + ((
n
) & 0xF))

	)

727 #ifdef 
COMPILER_VERSION


728 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

731 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

732 char const 
	ginfo_version
[] = {

735 
COMPILER_VERSION_MAJOR
,

736 #ifdef 
COMPILER_VERSION_MINOR


737 '.', 
COMPILER_VERSION_MINOR
,

738 #ifdef 
COMPILER_VERSION_PATCH


739 '.', 
COMPILER_VERSION_PATCH
,

740 #ifdef 
COMPILER_VERSION_TWEAK


741 '.', 
COMPILER_VERSION_TWEAK
,

749 #ifdef 
COMPILER_VERSION_INTERNAL


750 char const 
	ginfo_version_internal
[] = {

754 
COMPILER_VERSION_INTERNAL
,']','\0'};

755 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

756 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

760 #ifdef 
SIMULATE_VERSION_MAJOR


761 char const 
	ginfo_simulate_version
[] = {

764 
SIMULATE_VERSION_MAJOR
,

765 #ifdef 
SIMULATE_VERSION_MINOR


766 '.', 
SIMULATE_VERSION_MINOR
,

767 #ifdef 
SIMULATE_VERSION_PATCH


768 '.', 
SIMULATE_VERSION_PATCH
,

769 #ifdef 
SIMULATE_VERSION_TWEAK


770 '.', 
SIMULATE_VERSION_TWEAK
,

781 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

782 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

786 #if 
defined
(
__INTEL_COMPILER
) && defined(
_MSVC_LANG
) && _MSVC_LANG < 201403L

787 #if 
defined
(
__INTEL_CXX11_MODE__
)

788 #if 
defined
(
__cpp_aggregate_nsdmi
)

789 #define 
	#CXX_STD
 201402L

	)

791 #define 
	#CXX_STD
 201103L

	)

794 #define 
	#CXX_STD
 199711L

	)

796 #elif 
defined
(
_MSC_VER
) && defined(
_MSVC_LANG
)

797 #define 
	#CXX_STD
 
_MSVC_LANG


	)

799 #define 
	#CXX_STD
 
__cplusplus


	)

802 const char* 
	ginfo_language_standard_default
 = "INFO" ":" "standard_default["

803 #if 
CXX_STD
 > 202002L

805 #elif 
CXX_STD
 > 201703L

807 #elif 
CXX_STD
 >= 201703L

809 #elif 
CXX_STD
 >= 201402L

811 #elif 
CXX_STD
 >= 201103L

818 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

819 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || defined(
__xlC__
) || \

820 
defined
(
__TI_COMPILER_VERSION__
)) && \

821 !
defined
(
__STRICT_ANSI__
)

830 int 
	$main
(int 
argc
, char* 
argv
[])

832 int 
require
 = 0;

833 
require
 += 
info_compiler
[
argc
];

834 
require
 += 
info_platform
[
argc
];

835 
require
 += 
info_arch
[
argc
];

836 #ifdef 
COMPILER_VERSION_MAJOR


837 
require
 += 
info_version
[
argc
];

839 #ifdef 
COMPILER_VERSION_INTERNAL


840 
require
 += 
info_version_internal
[
argc
];

842 #ifdef 
SIMULATE_ID


843 
require
 += 
info_simulate
[
argc
];

845 #ifdef 
SIMULATE_VERSION_MAJOR


846 
require
 += 
info_simulate_version
[
argc
];

848 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

849 
require
 += 
info_cray
[
argc
];

851 
require
 += 
info_language_standard_default
[
argc
];

852 
require
 += 
info_language_extensions_default
[
argc
];

853 (void)
argv
;

854 return 
require
;

855 
	}
}

	@main.cpp

1 #include 
	~<iostream
>

2 #include 
	~<memory
>

3 #include 
	~<opencv2/core/mat.hpp
>

4 #include 
	~<opencv2/highgui.hpp
>

5 #include 
	~<vector
>

6 #include 
	~<opencv2/opencv.hpp
>

7 #include 
	~"opencv2/ximgproc.hpp
"

12 enum 
	eBallType
 { 
	mRED
 = 0, 
	mPURPLE
 = 1, 
	mBLUE
 = 2 };

15 
	gcv
::
Scalar
 
lower_purple
 = 
cv
::Scalar(181, 132, 0);

16 
	gcv
::
Scalar
 
upper_purple
 = 
cv
::Scalar(202, 255, 255);

17 
	gcv
::
Scalar
 
lower_red
 = 
cv
::Scalar(117, 143, 0);

18 
	gcv
::
Scalar
 
upper_red
 = 
cv
::Scalar(133, 255, 255);

19 
	gcv
::
Scalar
 
lower_blue
 = 
cv
::Scalar(0, 159, 0);

20 
	gcv
::
Scalar
 
upper_blue
 = 
cv
::Scalar(16, 255, 255);

23 class 
	cFindBallServer


25 
	mpublic
:

26 
std
::
shared_ptr
<
cv
::
VideoCapture
> 
cap
;

28 
	$FindBallServer
():
	`lutEqual
(256), 
	`lutZero
(256, 0), 
	`lutRaisen
(256), 
	`lutSRaisen
(256, 256, 
CV_8UC3
), 
	`flag
(0),
	$count
(0)

30 
std
::
cout
 << "FindBallServer created" << std::
endl
;

31 
cap
 = 
std
::
make_shared
<
cv
::
VideoCapture
>();

32 
ball_result
 = 
cv
::
	`Vec3d
(0, 0, 0);

33 
ball_last_result
 = 
cv
::
	`Vec3d
(0, 0, 0);

36 
cv
::
Vec3d
 
	$find_ball
(int 
type
)

40 
cv
::
Ptr
<cv::
ximgproc
::
EdgeDrawing
> 
ed
 = cv::ximgproc::
	`createEdgeDrawing
();

41 
std
::
shared_ptr
<
cv
::
ximgproc
::
EdgeDrawing
::
Params
> 
EDParams
 = std::
make_shared
<cv::ximgproc::EdgeDrawing::Params>();

42 
	`init
(
ed
, 
EDParams
);

44 
cv
::
Mat
 
color_image
 = 
	`usbcamera_getImage
();

45 if (
color_image
.
	`empty
()) {

46 
std
::
cerr
 << "Failed to capture frame." << std::
endl
;

47 return 
cv
::
	`Vec3d
(0, 0, 0);

49 
cv
::
Mat
 
color_image_copy
 = 
color_image
.
	`clone
();

50 
cv
::
Mat
 
hsv
;

51 
cv
::
Mat
 
blendSRaisen
;

52 
cv
::
Mat
 
mask
;

53 
cv
::
Mat
 
img
;

54 
cv
::
Mat
 
gray
;

55 
cv
::
Mat
 
thre
;

56 
cv
::
Mat
 
edge_image
;

57 
std
::
vector
<std::vector<
cv
::
Point
>> 
contours
;

59 
cv
::
	`cvtColor
(
color_image
, 
hsv
, cv::
COLOR_BGR2HSV
);

60 
cv
::
	`LUT
(
hsv
, 
lutRaisen
 ,
blendSRaisen
);

61 
cv
::
	`inRange
(
blendSRaisen
, 
this
->
lower
[
type
], this->
upper
[type], 
mask
);

62 
cv
::
	`bitwise_and
(
color_image
, color_image, 
img
, 
mask
);

63 
cv
::
	`medianBlur
(
img
, img, 7);

64 
cv
::
	`cvtColor
(
img
, 
gray
, cv::
COLOR_BGR2GRAY
);

65 
cv
::
	`threshold
(
gray
, 
thre
, 0, 255, cv::
THRESH_BINARY
);

66 
cv
::
	`morphologyEx
(
thre
, thre, cv::
MORPH_CLOSE
, cv::
	`getStructuringElement
(cv::
MORPH_RECT
, cv::
	`Size
(5, 5)), cv::
	`Point
(-1, -1), 2);

68 
cv
::
	`findContours
(
thre
, 
contours
, cv::
RETR_EXTERNAL
, cv::
CHAIN_APPROX_SIMPLE
);

69 for (auto 
contour
 : 
contours
) {

70 
cv
::
	`fillPoly
(
thre
, 
contour
, cv::
	`Scalar
(255, 255, 255));

74 
std
::
vector
<
cv
::
Vec6d
> 
ellipses
;

75 
std
::
vector
<
cv
::
Vec3d
> 
filter_ellipses
;

76 
ed
->
	`detectEdges
(
thre
);

78 
ed
->
	`detectEllipses
(
ellipses
);

79 
ed
->
	`getEdgeImage
(
edge_image
);

99 
cv
::
	`imshow
("color_image", 
color_image_copy
);

100 
cv
::
	`imshow
("hsv", 
hsv
);

101 
cv
::
	`imshow
("mask", 
mask
);

102 
cv
::
	`imshow
("color", 
blendSRaisen
);

103 
cv
::
	`imshow
("thre", 
thre
);

104 
cv
::
	`imshow
("edge", 
edge_image
);

105 
cv
::
	`imshow
("blendSRaisen", 
blendSRaisen
);

108 for (
size_t
 
i
=0; i<
ellipses
.
	`size
(); i++)

110 
cv
::
Point
 
	`center
((int)
ellipses
[
i
][0], (int)ellipses[i][1]);

111 
cv
::
Size
 
	`axes
((int)
ellipses
[
i
][2] + (int)ellipses[i][3], (int)ellipses[i][2] + (int)ellipses[i][4]);

114 
filter_ellipses
.
	`push_back
(
cv
::
	`Vec3d
(
center
.
x
, center.
y
, 
axes
.
width
/2.0 + axes.
height
/2.0));

117 
std
::
	`sort
(
filter_ellipses
.
	`begin
(), filter_ellipses.
	`end
(),

118 [](const 
cv
::
Vec3d
& 
a
, const cv::Vec3d& 
b
) {

119 return 
a
[0] > 
b
[0];

122 if (
ellipses
.
	`size
() > 0)

124 
cv
::
Mat
 
circle_region
;

125 
cv
::
Vec3d
 
max_ellipse
 = 
filter_ellipses
[0];

126 
cv
::
Mat
 
mask_
 = cv::Mat::
	`zeros
(
thre
.
	`size
(), 
CV_8UC1
);

127 
cv
::
	`circle
(
mask_
, cv::
	`Point
(int(
max_ellipse
[0]), int(max_ellipse[1])), int(max_ellipse[2]), cv::
	`Scalar
(255), -1);

128 
cv
::
	`bitwise_and
(
thre
, 
mask_
, 
circle_region
);

129 float 
white_pixels
 = 
cv
::
	`countNonZero
(
circle_region
);

130 float 
total_pixels
 = 
cv
::
	`countNonZero
(
mask_
);

131 if (
white_pixels
 / 
total_pixels
 > 0.6)

133 
this
->
ball_result
 = 
max_ellipse
;

136 
filter_ellipses
.
	`erase
(filter_ellipses.
	`begin
() + 0);

137 if(
filter_ellipses
.
	`size
()> 0)

139 
this
->
ball_result
 = 
filter_ellipses
[0];

143 if( 
filter_ellipses
.
	`size
() == 0 && 
ball_result
[0] > 161 && ball_result[0] < 468 && ball_result[1] > 333 )

145 
flag
 = 1;

148 
this
->
ball_result
 = 
filter_ellipses
[0];

151 }else if (
ellipses
.
	`size
() == 0 && 
flag
 == 0)

153 
std
::
vector
<
cv
::
Vec3d
> 
filter_ellipses_
 ;

154 
std
::
vector
<std::vector<
cv
::
Point
>> 
contours_
;

155 
cv
::
	`findContours
(
thre
, 
contours_
, cv::
RETR_TREE
, cv::
CHAIN_APPROX_SIMPLE
);

156 for (auto 
contour
 : 
contours_
) {

157 if(
contour
.
	`size
() > 50 && 
cv
::
	`contourArea
(contour) >100)

159 
cv
::
Point2f
 
center_
;

160 float 
radius_
;

161 
cv
::
	`minEnclosingCircle
(
contour
, 
center_
, 
radius_
);

162 
filter_ellipses_
.
	`push_back
(
cv
::
	`Vec3d
(
center_
.
x
, center_.
y
, 
radius_
));

166 
std
::
	`sort
(
filter_ellipses_
.
	`begin
(), filter_ellipses_.
	`end
(),

167 [](const 
cv
::
Vec3d
& 
a
, const cv::Vec3d& 
b
) {

168 return 
a
[0] > 
b
[0];

170 if(
filter_ellipses_
.
	`size
() > 0)

172 
this
->
ball_result
 = 
filter_ellipses_
[0];

176 if (
ball_result
 == 
ball_last_result
 && ball_result != 
cv
::
	`Vec3d
(0, 0, 0) && ball_result[0] > 161 && ball_result[0] < 468 && ball_result[1] > 333)

178 
count
 +=1;

180 if (
count
 > 100)

182 
flag
 = 0;

183 
count
 = 0;

185 
ball_last_result
 = 
ball_result
;

189 
cv
::
	`circle
( 
color_image_copy
, cv::
	`Point
(
ball_result
[0], ball_result[1]), ball_result[2], cv::
	`Scalar
(0, 255, 0), 2);

190 return 
ball_result
;

191 
	}
}

193 
bool
 
	$usbcamera_init
()

195 
this
->
cap
->
	`open
(0);

196 if (!
cap
->
	`isOpened
()) {

197 
std
::
cerr
 << "Failed to open camera." << std::
endl
;

198 return 
false
;

200 return 
true
;

201 
	}
}

203 
	gcv
::
Mat
 
	$usbcamera_getImage
()

205 
cv
::
Mat
 
frame
;

206 
this
->
cap
->
	`read
(
frame
);

208 if (
frame
.
	`empty
()) {

209 
std
::
cerr
 << "Failed to capture frame." << std::
endl
;

211 return 
frame
;

212 
	}
}

214 void 
init
( 
cv
::
Ptr
<cv::
ximgproc
::
EdgeDrawing
> &
ed
,

215 
std
::
shared_ptr
<
cv
::
ximgproc
::
EdgeDrawing
::
Params
> &
EDParams
)

217 
EDParams
->
MinPathLength
 = 60;

218 
	gEDParams
->
	gMinLineLength
 = 20;

219 
	gEDParams
->
	gPFmode
 = 
false
;

220 
	gEDParams
->
	gNFAValidation
 = 
true
;

221 
	ged
->
setParams
(*
EDParams
);

224 void 
	$lut_init
()

227 for (int 
i
 = 0; i < 256; ++i) {

228 
lutEqual
[
i
] = 
static_cast
<
uint8_t
>(i);

232 for (int 
i
 = 0; i < 256; ++i) {

233 
lutRaisen
[
i
] = 
static_cast
<
uint8_t
>(102 + 0.6 * i);

236 for (int 
i
 = 0; i < 256; ++i) {

237 for (int 
j
 = 0; j < 256; ++j) {

238 
lutSRaisen
.
at
<
cv
::
Vec3b
>(
i
, 
j
) = cv::
	`Vec3b
(
lutEqual
[i], 
lutRaisen
[j], lutEqual[i]);

241 
	}
}

243 void 
	$put_text
(
cv
::
Mat
 
frame
 ,int &
frame_number
)

245 
cv
::
	`putText
(
frame
, "Frames per second: " + 
std
::
	`to_string
(
frame_number
), cv::
	`Point
(10, 30), cv::
FONT_HERSHEY_SIMPLEX
, 1, cv::
	`Scalar
(0, 255, 0), 2);

246 
	}
}

247 #ifdef 
ENABLE_THRESHOLD


248 
	gstd
::
vector
<
cv
::
Scalar
> 
lower
 = {
lower_red
, 
lower_purple
, 
lower_blue
};

249 
	gstd
::
vector
<
cv
::
Scalar
> 
upper
 = {
upper_red
, 
upper_purple
, 
upper_blue
};

252 
	gprivate
:

256 #ifndef 
ENABLE_THRESHOLD


257 
std
::
vector
<
cv
::
Scalar
> 
lower
 = {
lower_red
, 
lower_purple
, 
lower_blue
};

258 
	gstd
::
vector
<
cv
::
Scalar
> 
upper
 = {
upper_red
, 
upper_purple
, 
upper_blue
};

261 
	gstd
::
vector
<
uint8_t
> 
lutEqual
;

262 
	gstd
::
vector
<
uint8_t
> 
lutZero
;

263 
	gstd
::
vector
<
uint8_t
> 
lutRaisen
;

264 
	gcv
::
Mat
 
lutSRaisen
;

266 
	gcv
::
Vec3d
 
ball_result
;

267 
	gcv
::
Vec3d
 
ball_last_result
;

268 int 
	gflag
;

269 int 
	gcount
;

271 int 
	gframe_number
;

276 #ifdef 
ENABLE_THRESHOLD


278 void 
	$onTrackbar
(int, void*) {

280 
	}
}

283 int 
	$main
()

287 double 
start_time
 = (double)
cv
::
	`getTickCount
() / cv::
	`getTickFrequency
();

289 int 
frame_number
 = -1;

290 int 
frame_number_record
 = -1;

291 int 
frames_per_second
 = 0;

292 double 
elapsed_seconds
 = 0.0;

294 #ifdef 
ENABLE_THRESHOLD


296 int 
lowH
 = 184, 
lowS
 = 118, 
lowV
 = 150;

297 int 
highH
 = 194, 
highS
 = 218, 
highV
 = 255;

298 
cv
::
	`namedWindow
("Threshold Adjustments", cv::
WINDOW_NORMAL
);

300 
cv
::
	`createTrackbar
("Low H", "Threshold Adjustments", &
lowH
, 255, 
onTrackbar
);

301 
cv
::
	`createTrackbar
("High H", "Threshold Adjustments", &
highH
, 255, 
onTrackbar
);

302 
cv
::
	`createTrackbar
("Low S", "Threshold Adjustments", &
lowS
, 255, 
onTrackbar
);

303 
cv
::
	`createTrackbar
("High S", "Threshold Adjustments", &
highS
, 255, 
onTrackbar
);

304 
cv
::
	`createTrackbar
("Low V", "Threshold Adjustments", &
lowV
, 255, 
onTrackbar
);

305 
cv
::
	`createTrackbar
("High V", "Threshold Adjustments", &
highV
, 255, 
onTrackbar
);

308 
cv
::
	`namedWindow
("color_image", cv::
WINDOW_AUTOSIZE
);

309 
cv
::
	`namedWindow
("color", cv::
WINDOW_AUTOSIZE
);

310 
cv
::
	`namedWindow
("hsv", cv::
WINDOW_AUTOSIZE
);

311 
cv
::
	`namedWindow
("blendSRaisen", cv::
WINDOW_AUTOSIZE
);

312 
cv
::
	`namedWindow
("thre", cv::
WINDOW_AUTOSIZE
);

313 
cv
::
	`namedWindow
("edge", cv::
WINDOW_AUTOSIZE
);

314 
cv
::
	`namedWindow
("mask",cv::
WINDOW_AUTOSIZE
);

316 
std
::
cout
 << "Hello, OpenCV!" << std::
endl
;

317 
std
::
shared_ptr
<
FindBallServer
> 
instance
 = std::
make_shared
<FindBallServer>();

318 
std
::
cout
 << 
instance
->
	`usbcamera_init
() << std::
endl
;

319 for(int 
i
 = 0; i < 20; i++)

320 
instance
->
	`usbcamera_getImage
();

321 
instance
->
	`lut_init
();

322 
cv
::
Vec3d
 
ref_
 = 
instance
->
	`find_ball
(1);

327 
cv
::
Vec2f
 
last_measurement
;

328 
cv
::
Vec2f
 
current_measurement
 ;

329 
cv
::
Vec4f
 
last_prediction
 ;

330 
cv
::
Vec4f
 
current_prediction
 ;

332 
std
::
shared_ptr
<
cv
::
KalmanFilter
> 
Kalman
 = std::
make_shared
<cv::KalmanFilter>(4, 2);

333 
Kalman
->
measurementMatrix
 = (
cv
::
Mat_
<float>(2, 4) << 1, 0, 0, 0, 0, 1, 0, 0);

334 
Kalman
->
transitionMatrix
 = (
cv
::
Mat_
<float>(4, 4) << 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1);

335 
Kalman
->
processNoiseCov
 = (
cv
::
Mat_
<float>(4, 4) << 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

336 while (
true
) {

339 
frame_number
 = frame_number + 1;

341 #ifdef 
ENABLE_THRESHOLD


342 
cv
::
Mat
 
	`thresholdImage
(100, 600, 
CV_8UC3
, cv::
	`Scalar
(0, 0, 0));

344 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(0, 0, 100, 100), cv::
	`Scalar
(
lowH
, 
lowS
, 
lowV
), -1);

345 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(100, 0, 100, 100), cv::
	`Scalar
(
highH
, 
highS
, 
highV
), -1);

346 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(200, 0, 100, 100), cv::
	`Scalar
(
lowH
, 255, 255), -1);

347 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(300, 0, 100, 100), cv::
	`Scalar
(
highH
, 255, 255), -1);

348 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(400, 0, 100, 100), cv::
	`Scalar
(255, 
lowS
, 255), -1);

349 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(500, 0, 100, 100), cv::
	`Scalar
(255, 
highS
, 255), -1);

350 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(600, 0, 100, 100), cv::
	`Scalar
(255, 255, 
lowV
), -1);

351 
cv
::
	`rectangle
(
thresholdImage
, cv::
	`Rect
(700, 0, 100, 100), cv::
	`Scalar
(255, 255, 
highV
), -1);

353 
instance
->
lower
[1] = 
cv
::
	`Scalar
(
lowH
, 
lowS
, 
lowV
);

354 
instance
->
upper
[1] = 
cv
::
	`Scalar
(
highH
, 
highS
, 
highV
);

356 
cv
::
	`imshow
("Threshold Adjustments", 
thresholdImage
);

360 auto 
ref
 = 
instance
->
	`find_ball
(1);

361 
last_prediction
 = 
current_prediction
;

362 
last_measurement
 = 
current_measurement
;

363 if (
ref
 == 
cv
::
	`Vec3d
(0, 0, 0))

364 
current_measurement
 = 
last_measurement
;

366 
current_measurement
 = 
cv
::
	`Vec2f
(
ref
[0], ref[1]);

367 
Kalman
->
	`correct
(
cv
::
	`Mat
(
current_measurement
));

368 
current_prediction
 = 
Kalman
->
	`predict
();

369 
std
::
cout
 << "current_prediction: " << 
current_prediction
 << std::
endl
;

371 auto 
key
 = 
cv
::
	`waitKey
(1);

372 if(
key
 == 27)

376 double 
current_time
 = (double)
cv
::
	`getTickCount
() / cv::
	`getTickFrequency
();

377 
elapsed_seconds
 = (
current_time
 - 
start_time
);

379 if (
elapsed_seconds
 >= 1.0)

381 
std
::
cout
 << "Frames per second: " << 
frame_number
 - 
frame_number_record
 << std::
endl
;

384 
start_time
 = 
current_time
;

385 
frame_number_record
 = 
frame_number
;

388 
instance
->
cap
->
	`release
();

389 
cv
::
	`destroyAllWindows
();

391 
	}
}

	@test.cpp

1 #include 
	~<iostream
>

2 #include 
	~<memory
>

3 #include 
	~<opencv2/opencv.hpp
>

4 #include 
	~<opencv2/videoio.hpp
>

7 int 
	$main
 ()

10 auto 
cap
 = 
std
::
make_shared
<
cv
::
VideoCapture
>();

11 
cap
->
	`open
(0);

14 if (!
cap
->
	`isOpened
()) {

15 
std
::
cerr
 << "ERROR: 摄像头无法打开" << std::
endl
;

19 
cv
::
	`namedWindow
("摄像头", cv::
WINDOW_AUTOSIZE
);

21 
cv
::
Mat
 
frame
;

22 while (
true
) {

23 
cap
->
	`read
(
frame
);

24 if (
frame
.
	`empty
()) {

25 
std
::
cerr
 << "ERROR: 捕获到空帧" << std::
endl
;

29 
cv
::
	`imshow
("摄像头", 
frame
);

31 if (
cv
::
	`waitKey
(1) == 'q') {

36 
cv
::
	`destroyWindow
("摄像头");

38 
	}
}

	@ximgproc/include/opencv2/ximgproc.hpp

37 #ifndef 
__OPENCV_XIMGPROC_HPP__


38 #define 
	#__OPENCV_XIMGPROC_HPP__


	)

40 #include 
	~"ximgproc/edge_filter.hpp
"

41 #include 
	~"ximgproc/disparity_filter.hpp
"

42 #include 
	~"ximgproc/sparse_match_interpolator.hpp
"

43 #include 
	~"ximgproc/structured_edge_detection.hpp
"

44 #include 
	~"ximgproc/edgeboxes.hpp
"

45 #include 
	~"ximgproc/edge_drawing.hpp
"

46 #include 
	~"ximgproc/scansegment.hpp
"

47 #include 
	~"ximgproc/seeds.hpp
"

48 #include 
	~"ximgproc/segmentation.hpp
"

49 #include 
	~"ximgproc/fast_hough_transform.hpp
"

50 #include 
	~"ximgproc/estimated_covariance.hpp
"

51 #include 
	~"ximgproc/weighted_median_filter.hpp
"

52 #include 
	~"ximgproc/slic.hpp
"

53 #include 
	~"ximgproc/lsc.hpp
"

54 #include 
	~"ximgproc/paillou_filter.hpp
"

55 #include 
	~"ximgproc/fast_line_detector.hpp
"

56 #include 
	~"ximgproc/deriche_filter.hpp
"

57 #include 
	~"ximgproc/peilin.hpp
"

58 #include 
	~"ximgproc/fourier_descriptors.hpp
"

59 #include 
	~"ximgproc/ridgefilter.hpp
"

60 #include 
	~"ximgproc/brightedges.hpp
"

61 #include 
	~"ximgproc/run_length_morphology.hpp
"

62 #include 
	~"ximgproc/edgepreserving_filter.hpp
"

63 #include 
	~"ximgproc/color_match.hpp
"

64 #include 
	~"ximgproc/radon_transform.hpp
"

65 #include 
	~"ximgproc/find_ellipses.hpp
"

122 
namespace
 
	gcv


124 
namespace
 
	gximgproc


127 enum 
	eThinningTypes
{

128 
	gTHINNING_ZHANGSUEN
 = 0,

129 
	gTHINNING_GUOHALL
 = 1

135 enum 
	eLocalBinarizationMethods
{

136 
	gBINARIZATION_NIBLACK
 = 0,

137 
	gBINARIZATION_SAUVOLA
 = 1,

138 
	gBINARIZATION_WOLF
 = 2,

139 
	gBINARIZATION_NICK
 = 3

177 
CV_EXPORTS_W
 void 
niBlackThreshold
( 
InputArray
 
_src
, 
OutputArray
 
_dst
,

178 double 
maxValue
, int 
type
,

179 int 
blockSize
, double 
k
, int 
binarizationMethod
 = 
BINARIZATION_NIBLACK
,

180 double 
r
 = 128 );

190 
CV_EXPORTS_W
 void 
thinning
( 
InputArray
 
src
, 
OutputArray
 
dst
, int 
thinningType
 = 
THINNING_ZHANGSUEN
);

212 
CV_EXPORTS_W
 void 
anisotropicDiffusion
(
InputArray
 
src
, 
OutputArray
 
dst
, float 
alpha
, float 
K
, int 
niters
 );

	@ximgproc/include/opencv2/ximgproc/brightedges.hpp

44 #include 
	~"opencv2/core.hpp
"

45 
namespace
 
	gcv


47 
namespace
 
	gximgproc
 {

48 
CV_EXPORTS_W
 void 
BrightEdges
(
Mat
 &
_original
, Mat &
_edgeview
, int 
contrast
 = 1, int 
shortrange
 = 3, int 
longrange
 = 9);

	@ximgproc/include/opencv2/ximgproc/color_match.hpp

5 #ifndef 
__OPENCV_COLOR_MATCH_HPP__


6 #define 
	#__OPENCV_COLOR_MATCH_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 {

11 
namespace
 
	gximgproc
 {

22 
CV_EXPORTS_W
 void 
createQuaternionImage
(
InputArray
 
img
, 
OutputArray
 
qimg
);

30 
CV_EXPORTS_W
 void 
qconj
(
InputArray
 
qimg
, 
OutputArray
 
qcimg
);

37 
CV_EXPORTS_W
 void 
qunitary
(
InputArray
 
qimg
, 
OutputArray
 
qnimg
);

45 
CV_EXPORTS_W
 void 
qmultiply
(
InputArray
 
src1
, InputArray 
src2
, 
OutputArray
 
dst
);

54 
CV_EXPORTS_W
 void 
qdft
(
InputArray
 
img
, 
OutputArray
 
qimg
, int 
flags
, 
bool
 
sideLeft
);

62 
CV_EXPORTS_W
 void 
colorMatchTemplate
(
InputArray
 
img
, InputArray 
templ
, 
OutputArray
 
result
);

	@ximgproc/include/opencv2/ximgproc/deriche_filter.hpp

37 #ifndef 
__OPENCV_DERICHEFILTER_HPP__


38 #define 
	#__OPENCV_DERICHEFILTER_HPP__


	)

39 #ifdef 
__cplusplus


41 #include 
	~<opencv2/core.hpp
>

43 
namespace
 
	gcv
 {

44 
namespace
 
	gximgproc
 {

60 
CV_EXPORTS_W
 void 
GradientDericheY
(
InputArray
 
op
, 
OutputArray
 
dst
, double 
alpha
,double 
omega
);

72 
CV_EXPORTS_W
 void 
GradientDericheX
(
InputArray
 
op
, 
OutputArray
 
dst
, double 
alpha
,double 
omega
);

	@ximgproc/include/opencv2/ximgproc/disparity_filter.hpp

37 #ifndef 
__OPENCV_DISPARITYFILTER_HPP__


38 #define 
	#__OPENCV_DISPARITYFILTER_HPP__


	)

39 #ifdef 
__cplusplus


41 #include 
	~<opencv2/core.hpp
>

42 #include 
	~<opencv2/calib3d.hpp
>

44 
namespace
 
	gcv
 {

45 
namespace
 
	gximgproc
 {

52 class 
	cCV_EXPORTS_W
 
	gDisparityFilter
 : 
public
 
Algorithm


54 
public
:

75 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
disparity_map_left
, InputArray 
left_view
, 
OutputArray
 
filtered_disparity_map
, InputArray 
disparity_map_right
 = 
Mat
(), 
Rect
 
ROI
 = Rect(), InputArray 
right_view
 = Mat()) = 0;

82 class 
	cCV_EXPORTS_W
 
	gDisparityWLSFilter
 : 
public
 
DisparityFilter


84 
public
:

90 
CV_WRAP
 
virtual
 double 
getLambda
() = 0;

92 
CV_WRAP
 
virtual
 void 
setLambda
(double 
_lambda
) = 0;

97 
CV_WRAP
 
virtual
 double 
getSigmaColor
() = 0;

99 
CV_WRAP
 
virtual
 void 
setSigmaColor
(double 
_sigma_color
) = 0;

106 
CV_WRAP
 
virtual
 int 
getLRCthresh
() = 0;

108 
CV_WRAP
 
virtual
 void 
setLRCthresh
(int 
_LRC_thresh
) = 0;

112 
CV_WRAP
 
virtual
 int 
getDepthDiscontinuityRadius
() = 0;

114 
CV_WRAP
 
virtual
 void 
setDepthDiscontinuityRadius
(int 
_disc_radius
) = 0;

119 
CV_WRAP
 
virtual
 
Mat
 
getConfidenceMap
() = 0;

122 
CV_WRAP
 
virtual
 
Rect
 
getROI
() = 0;

130 
CV_EXPORTS_W


131 
	gPtr
<
	gDisparityWLSFilter
> 
createDisparityWLSFilter
(
Ptr
<
StereoMatcher
> 
matcher_left
);

138 
CV_EXPORTS_W


139 
	gPtr
<
	gStereoMatcher
> 
createRightMatcher
(
Ptr
<
StereoMatcher
> 
matcher_left
);

148 
CV_EXPORTS_W


149 
	gPtr
<
	gDisparityWLSFilter
> 
createDisparityWLSFilterGeneric
(
bool
 
use_confidence
);

163 
CV_EXPORTS_W


164 int 
readGT
(
String
 
src_path
,
OutputArray
 
dst
);

176 
CV_EXPORTS_W


177 double 
computeMSE
(
InputArray
 
GT
, InputArray 
src
, 
Rect
 
ROI
);

192 
CV_EXPORTS_W


193 double 
computeBadPixelPercent
(
InputArray
 
GT
, InputArray 
src
, 
Rect
 
ROI
, int 
thresh
=24 );

203 
CV_EXPORTS_W


204 void 
getDisparityVis
(
InputArray
 
src
,
OutputArray
 
dst
,double 
scale
=1.0);

	@ximgproc/include/opencv2/ximgproc/edge_drawing.hpp

5 #ifndef 
__OPENCV_EDGE_DRAWING_HPP__


6 #define 
	#__OPENCV_EDGE_DRAWING_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv


12 
namespace
 
	gximgproc


21 class 
	cCV_EXPORTS_W
 
	gEdgeDrawing
 : 
public
 
Algorithm


23 
public
:

25 enum 
	eGradientOperator


27 
PREWITT
 = 0,

28 
	gSOBEL
 = 1,

29 
	gSCHARR
 = 2,

30 
	gLSD
 = 3

33 struct 
CV_EXPORTS_W_SIMPLE
 
	gParams


35 
CV_WRAP
 
Params
();

37 
CV_PROP_RW
 
bool
 
	gPFmode
;

42 
CV_PROP_RW
 int 
	gEdgeDetectionOperator
;

44 
CV_PROP_RW
 int 
	gGradientThresholdValue
;

46 
CV_PROP_RW
 int 
	gAnchorThresholdValue
;

48 
CV_PROP_RW
 int 
	gScanInterval
;

54 
CV_PROP_RW
 int 
	gMinPathLength
;

56 
CV_PROP_RW
 float 
	gSigma
;

57 
CV_PROP_RW
 
bool
 
	gSumFlag
;

59 
CV_PROP_RW
 
bool
 
	gNFAValidation
;

61 
CV_PROP_RW
 int 
	gMinLineLength
;

63 
CV_PROP_RW
 double 
	gMaxDistanceBetweenTwoLines
;

65 
CV_PROP_RW
 double 
	gLineFitErrorThreshold
;

67 
CV_PROP_RW
 double 
	gMaxErrorThreshold
;

69 void 
read
(const 
FileNode
& 
fn
);

70 void 
write
(
FileStorage
& 
fs
) const;

77 
CV_WRAP
 
virtual
 void 
detectEdges
(
InputArray
 
src
) = 0;

83 
CV_WRAP
 
virtual
 void 
getEdgeImage
(
OutputArray
 
dst
) = 0;

89 
CV_WRAP
 
virtual
 void 
getGradientImage
(
OutputArray
 
dst
) = 0;

93 
CV_WRAP
 
virtual
 
	gstd
::
vector
<
std
::vector<
Point
> > 
getSegments
() = 0;

97 
CV_WRAP
 
virtual
 
	gstd
::
vector
<int> 
getSegmentIndicesOfLines
() const = 0;

104 
CV_WRAP
 
virtual
 void 
detectLines
(
OutputArray
 
lines
) = 0;

111 
CV_WRAP
 
virtual
 void 
detectEllipses
(
OutputArray
 
ellipses
) = 0;

113 
CV_WRAP
 
Params
 
	gparams
;

120 
CV_WRAP
 void 
setParams
(const 
EdgeDrawing
::
Params
& 
parameters
);

121 
	gvirtual
 ~
EdgeDrawing
() { }

126 
CV_EXPORTS_W
 
	gPtr
<
	gEdgeDrawing
> 
createEdgeDrawing
();

	@ximgproc/include/opencv2/ximgproc/edge_filter.hpp

37 #ifndef 
__OPENCV_EDGEFILTER_HPP__


38 #define 
	#__OPENCV_EDGEFILTER_HPP__


	)

39 #ifdef 
__cplusplus


41 #include 
	~<opencv2/core.hpp
>

43 
namespace
 
	gcv


45 
namespace
 
	gximgproc


51 enum 
	eEdgeAwareFiltersList


53 
	gDTF_NC
,

54 
	gDTF_IC
,

55 
	gDTF_RF
,

57 
	gGUIDED_FILTER
,

58 
	gAM_FILTER


66 class 
	cCV_EXPORTS_W
 
	gDTFilter
 : 
public
 
Algorithm


68 
public
:

79 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
dDepth
 = -1) = 0;

101 
CV_EXPORTS_W


102 
	gPtr
<
	gDTFilter
> 
createDTFilter
(
InputArray
 
guide
, double 
sigmaSpatial
, double 
sigmaColor
, int 
mode
 = 
DTF_NC
, int 
numIters
 = 3);

120 
CV_EXPORTS_W


121 void 
dtFilter
(
InputArray
 
guide
, InputArray 
src
, 
OutputArray
 
dst
, double 
sigmaSpatial
, double 
sigmaColor
, int 
mode
 = 
DTF_NC
, int 
numIters
 = 3);

130 class 
	cCV_EXPORTS_W
 
	gGuidedFilter
 : 
public
 
Algorithm


132 
public
:

143 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
dDepth
 = -1) = 0;

158 
CV_EXPORTS_W
 
	gPtr
<
	gGuidedFilter
> 
createGuidedFilter
(
InputArray
 
guide
, int 
radius
, double 
eps
);

180 
CV_EXPORTS_W
 void 
guidedFilter
(
InputArray
 
guide
, InputArray 
src
, 
OutputArray
 
dst
, int 
radius
, double 
eps
, int 
dDepth
 = -1);

203 class 
	cCV_EXPORTS_W
 
	gAdaptiveManifoldFilter
 : 
public
 
Algorithm


205 
public
:

214 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
src
, 
OutputArray
 
dst
, InputArray 
joint
 = 
noArray
()) = 0;

216 
CV_WRAP
 
virtual
 void 
collectGarbage
() = 0;

218 
CV_WRAP
 static 
	gPtr
<
	gAdaptiveManifoldFilter
> 
create
();

221 
virtual
 double 
getSigmaS
() const = 0;

223 
virtual
 void 
setSigmaS
(double 
val
) = 0;

225 
virtual
 double 
getSigmaR
() const = 0;

227 
virtual
 void 
setSigmaR
(double 
val
) = 0;

229 
virtual
 int 
getTreeHeight
() const = 0;

231 
virtual
 void 
setTreeHeight
(int 
val
) = 0;

233 
virtual
 int 
getPCAIterations
() const = 0;

235 
virtual
 void 
setPCAIterations
(int 
val
) = 0;

237 
virtual
 
bool
 
getAdjustOutliers
() const = 0;

239 
virtual
 void 
setAdjustOutliers
(
bool
 
val
) = 0;

241 
virtual
 
bool
 
getUseRNG
() const = 0;

243 
virtual
 void 
setUseRNG
(
bool
 
val
) = 0;

262 
CV_EXPORTS_W
 
	gPtr
<
	gAdaptiveManifoldFilter
> 
createAMFilter
(double 
sigma_s
, double 
sigma_r
, 
bool
 
adjust_outliers
 = 
false
);

284 
CV_EXPORTS_W
 void 
amFilter
(
InputArray
 
joint
, InputArray 
src
, 
OutputArray
 
dst
, double 
sigma_s
, double 
sigma_r
, 
bool
 
adjust_outliers
 = 
false
);

316 
CV_EXPORTS_W


317 void 
jointBilateralFilter
(
InputArray
 
joint
, InputArray 
src
, 
OutputArray
 
dst
, int 
d
, double 
sigmaColor
, double 
sigmaSpace
, int 
borderType
 = 
BORDER_DEFAULT
);

338 
CV_EXPORTS_W


339 void 
bilateralTextureFilter
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
fr
 = 3, int 
numIter
 = 1, double 
sigmaAlpha
 = -1., double 
sigmaAvg
 = -1.);

372 
CV_EXPORTS_W


373 void 
rollingGuidanceFilter
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
d
 = -1, double 
sigmaColor
 = 25, double 
sigmaSpace
 = 3, int 
numOfIter
 = 4, int 
borderType
 = 
BORDER_DEFAULT
);

382 class 
	cCV_EXPORTS_W
 
	gFastBilateralSolverFilter
 : 
public
 
Algorithm


384 
public
:

395 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
src
, InputArray 
confidence
, 
OutputArray
 
dst
) = 0;

417 
CV_EXPORTS_W
 
	gPtr
<
	gFastBilateralSolverFilter
> 
createFastBilateralSolverFilter
(
InputArray
 
guide
, double 
sigma_spatial
, double 
sigma_luma
, double 
sigma_chroma
, double 
lambda
 = 128.0, int 
num_iter
 = 25, double 
max_tol
 = 1e-5);

448 
CV_EXPORTS_W
 void 
fastBilateralSolverFilter
(
InputArray
 
guide
, InputArray 
src
, InputArray 
confidence
, 
OutputArray
 
dst
, double 
sigma_spatial
 = 8, double 
sigma_luma
 = 8, double 
sigma_chroma
 = 8, double 
lambda
 = 128.0, int 
num_iter
 = 25, double 
max_tol
 = 1e-5);

457 class 
	cCV_EXPORTS_W
 
	gFastGlobalSmootherFilter
 : 
public
 
Algorithm


459 
public
:

466 
CV_WRAP
 
virtual
 void 
filter
(
InputArray
 
src
, 
OutputArray
 
dst
) = 0;

489 
CV_EXPORTS_W
 
	gPtr
<
	gFastGlobalSmootherFilter
> 
createFastGlobalSmootherFilter
(
InputArray
 
guide
, double 
lambda
, double 
sigma_color
, double 
lambda_attenuation
=0.25, int 
num_iter
=3);

509 
CV_EXPORTS_W
 void 
fastGlobalSmootherFilter
(
InputArray
 
guide
, InputArray 
src
, 
OutputArray
 
dst
, double 
lambda
, double 
sigma_color
, double 
lambda_attenuation
=0.25, int 
num_iter
=3);

523 
CV_EXPORTS_W
 void 
l0Smooth
(
InputArray
 
src
, 
OutputArray
 
dst
, double 
lambda
 = 0.02, double 
kappa
 = 2.0);

	@ximgproc/include/opencv2/ximgproc/edgeboxes.hpp

43 #ifndef 
__OPENCV_EDGEBOXES_HPP__


44 #define 
	#__OPENCV_EDGEBOXES_HPP__


	)

46 #include 
	~<opencv2/core.hpp
>

48 
namespace
 
	gcv


50 
namespace
 
	gximgproc


59 int 
	gx
, 
	gy
, 
	gw
, 
	gh
;

60 float 
	gscore
;

61 } 
	tBox
;

63 typedef 
	gstd
::
	tvector
<
	tBox
> 
	tBoxes
;

67 class 
	cCV_EXPORTS_W
 
	gEdgeBoxes
 : 
public
 
Algorithm


70 
public
:

79 
CV_WRAP
 
virtual
 void 
getBoundingBoxes
(
InputArray
 
edge_map
, InputArray 
orientation_map
, 
CV_OUT
 
std
::
vector
<
Rect
> &
boxes
, 
OutputArray
 
scores
 = 
noArray
()) = 0;

83 
CV_WRAP
 
virtual
 float 
getAlpha
() const = 0;

86 
CV_WRAP
 
virtual
 void 
setAlpha
(float 
value
) = 0;

90 
CV_WRAP
 
virtual
 float 
getBeta
() const = 0;

93 
CV_WRAP
 
virtual
 void 
setBeta
(float 
value
) = 0;

97 
CV_WRAP
 
virtual
 float 
getEta
() const = 0;

100 
CV_WRAP
 
virtual
 void 
setEta
(float 
value
) = 0;

104 
CV_WRAP
 
virtual
 float 
getMinScore
() const = 0;

107 
CV_WRAP
 
virtual
 void 
setMinScore
(float 
value
) = 0;

111 
CV_WRAP
 
virtual
 int 
getMaxBoxes
() const = 0;

114 
CV_WRAP
 
virtual
 void 
setMaxBoxes
(int 
value
) = 0;

118 
CV_WRAP
 
virtual
 float 
getEdgeMinMag
() const = 0;

121 
CV_WRAP
 
virtual
 void 
setEdgeMinMag
(float 
value
) = 0;

125 
CV_WRAP
 
virtual
 float 
getEdgeMergeThr
() const = 0;

128 
CV_WRAP
 
virtual
 void 
setEdgeMergeThr
(float 
value
) = 0;

132 
CV_WRAP
 
virtual
 float 
getClusterMinMag
() const = 0;

135 
CV_WRAP
 
virtual
 void 
setClusterMinMag
(float 
value
) = 0;

139 
CV_WRAP
 
virtual
 float 
getMaxAspectRatio
() const = 0;

142 
CV_WRAP
 
virtual
 void 
setMaxAspectRatio
(float 
value
) = 0;

146 
CV_WRAP
 
virtual
 float 
getMinBoxArea
() const = 0;

149 
CV_WRAP
 
virtual
 void 
setMinBoxArea
(float 
value
) = 0;

153 
CV_WRAP
 
virtual
 float 
getGamma
() const = 0;

156 
CV_WRAP
 
virtual
 void 
setGamma
(float 
value
) = 0;

160 
CV_WRAP
 
virtual
 float 
getKappa
() const = 0;

163 
CV_WRAP
 
virtual
 void 
setKappa
(float 
value
) = 0;

182 
CV_EXPORTS_W
 
	gPtr
<
	gEdgeBoxes
>

183 
createEdgeBoxes
(float 
alpha
=0.65f,

184 float 
beta
=0.75f,

185 float 
eta
=1,

186 float 
minScore
=0.01f,

187 int 
maxBoxes
=10000,

188 float 
edgeMinMag
=0.1f,

189 float 
edgeMergeThr
=0.5f,

190 float 
clusterMinMag
=0.5f,

191 float 
maxAspectRatio
=3,

192 float 
minBoxArea
=1000,

193 float 
gamma
=2,

194 float 
kappa
=1.5f);

	@ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp

5 #ifndef 
__OPENCV_EDGEPRESERVINGFILTER_HPP__


6 #define 
	#__OPENCV_EDGEPRESERVINGFILTER_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

27 
CV_EXPORTS_W
 void 
edgePreservingFilter
( 
InputArray
 
src
, 
OutputArray
 
dst
, int 
d
, double 
threshold
 );

	@ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp

51 #ifndef 
__OPENCV_ESTIMATECOVARIANCE_HPP__


52 #define 
	#__OPENCV_ESTIMATECOVARIANCE_HPP__


	)

53 #ifdef 
__cplusplus


55 #include 
	~<opencv2/core.hpp
>

57 
namespace
 
	gcv


59 
namespace
 
	gximgproc


77 
CV_EXPORTS_W
 void 
covarianceEstimation
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
windowRows
, int 
windowCols
);

	@ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp

44 #ifndef 
__OPENCV_FAST_HOUGH_TRANSFORM_HPP__


45 #define 
	#__OPENCV_FAST_HOUGH_TRANSFORM_HPP__


	)

46 #ifdef 
__cplusplus


48 #include 
	~"opencv2/core.hpp
"

51 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

64 enum 
	eAngleRangeOption


66 
	gARO_0_45
 = 0,

67 
	gARO_45_90
 = 1,

68 
	gARO_90_135
 = 2,

69 
	gARO_315_0
 = 3,

70 
	gARO_315_45
 = 4,

71 
	gARO_45_135
 = 5,

72 
	gARO_315_135
 = 6,

73 
	gARO_CTR_HOR
 = 7,

75 
	gARO_CTR_VER
 = 8

88 enum 
	eHoughOp


90 
	gFHT_MIN
 = 0,

92 
	gFHT_MAX
 = 1,

94 
	gFHT_ADD
 = 2,

96 
	gFHT_AVE
 = 3

105 enum 
	eHoughDeskewOption


107 
	gHDO_RAW
 = 0,

108 
	gHDO_DESKEW
 = 1

117 
	gRO_STRICT
 = 0x00,

118 
	gRO_IGNORE_BORDERS
 = 0x01,

119 } 
	tRulesOption
;

133 
CV_EXPORTS_W
 void 
FastHoughTransform
( 
InputArray
 
src
,

134 
OutputArray
 
dst
,

135 int 
dstMatDepth
,

136 int 
angleRange
 = 
ARO_315_135
,

137 int 
op
 = 
FHT_ADD
,

138 int 
makeSkew
 = 
HDO_DESKEW
 );

155 
CV_EXPORTS_W
 
Vec4i
 
HoughPoint2Line
(const 
Point
 &
houghPoint
,

156 
InputArray
 
srcImgInfo
,

157 int 
angleRange
 = 
ARO_315_135
,

158 int 
makeSkew
 = 
HDO_DESKEW
,

159 int 
rules
 = 
RO_IGNORE_BORDERS
 );

	@ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp

5 #ifndef 
__OPENCV_FAST_LINE_DETECTOR_HPP__


6 #define 
	#__OPENCV_FAST_LINE_DETECTOR_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv


12 
namespace
 
	gximgproc


24 class 
	cCV_EXPORTS_W
 
	gFastLineDetector
 : 
public
 
Algorithm


26 
public
:

44 
CV_WRAP
 
virtual
 void 
detect
(
InputArray
 
image
, 
OutputArray
 
lines
) = 0;

54 
CV_WRAP
 
virtual
 void 
drawSegments
(
InputOutputArray
 
image
, 
InputArray
 
lines
,

55 
bool
 
draw_arrow
 = 
false
, 
Scalar
 
linecolor
 = Scalar(0, 0, 255), int 
linethickness
 = 1) = 0;

57 
	gvirtual
 ~
FastLineDetector
() { }

71 
CV_EXPORTS_W
 
	gPtr
<
	gFastLineDetector
> 
createFastLineDetector
(

72 int 
length_threshold
 = 10, float 
distance_threshold
 = 1.414213562f,

73 double 
canny_th1
 = 50.0, double 
canny_th2
 = 50.0, int 
canny_aperture_size
 = 3,

74 
bool
 
do_merge
 = 
false
);

	@ximgproc/include/opencv2/ximgproc/find_ellipses.hpp

5 #ifndef 
__OPENCV_FIND_ELLIPSES_HPP__


6 #define 
	#__OPENCV_FIND_ELLIPSES_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 {

11 
namespace
 
	gximgproc
 {

30 
CV_EXPORTS_W
 void 
findEllipses
(

31 
InputArray
 
image
, 
OutputArray
 
ellipses
,

32 float 
scoreThreshold
 = 0.7f, float 
reliabilityThreshold
 = 0.5f,

33 float 
centerDistanceThreshold
 = 0.05f

	@ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp

5 #ifndef 
__OPENCV_FOURIERDESCRIPTORS_HPP__


6 #define 
	#__OPENCV_FOURIERDESCRIPTORS_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 {

11 
namespace
 
	gximgproc
 {

20 class 
	cCV_EXPORTS_W
 
	gContourFitting
 : 
public
 
Algorithm


22 int 
ctrSize
;

23 int 
	gfdSize
;

24 
	gstd
::
vector
<
std
::
complex
<double> > 
b
;

25 
	gstd
::
vector
<
std
::
complex
<double> > 
a
;

26 
	gstd
::
vector
<double> 
frequence
;

27 
	gstd
::
vector
<double> 
rho
, 
	gpsi
;

28 void 
frequencyInit
();

29 void 
fAlpha
(double 
x
, double &
fn
, double &
df
);

30 double 
distance
(
std
::
complex
<double> 
r
, double 
alpha
);

31 double 
newtonRaphson
(double 
x1
, double 
x2
);

32 
	gpublic
:

38 
ContourFitting
(int 
ctr
=1024,int 
fd
=16):
ctrSize
(ctr),
fdSize
(fd){};

47 void 
estimateTransformation
(
InputArray
 
src
, InputArray 
dst
, 
OutputArray
 
alphaPhiST
, double *
dist
 = 0, 
bool
 
fdContour
 = 
false
);

56 
CV_WRAP
 void 
estimateTransformation
(
InputArray
 
src
, InputArray 
dst
, 
OutputArray
 
alphaPhiST
, 
CV_OUT
 double &
dist
 , 
bool
 
fdContour
 = 
false
);

61 
CV_WRAP
 void 
setCtrSize
(int 
n
);

66 
CV_WRAP
 void 
setFDSize
(int 
n
);

70 
CV_WRAP
 int 
getCtrSize
() { return 
	gctrSize
; };

74 
CV_WRAP
 int 
getFDSize
() { return 
	gfdSize
; };

87 
CV_EXPORTS_W
 void 
fourierDescriptor
(
InputArray
 
src
, 
OutputArray
 
dst
, int 
nbElt
=-1,int 
nbFD
=-1);

97 
CV_EXPORTS_W
 void 
transformFD
(
InputArray
 
src
, InputArray 
t
,
OutputArray
 
dst
, 
bool
 
fdContour
=
true
);

106 
CV_EXPORTS_W
 void 
contourSampling
(
InputArray
 
src
, 
OutputArray
 
out
, int 
nbElt
);

114 
CV_EXPORTS_W
 
	gPtr
<
	gContourFitting
> 
createContourFitting
(int 
ctr
 = 1024, int 
fd
 = 16);

	@ximgproc/include/opencv2/ximgproc/lsc.hpp

46 #ifndef 
__OPENCV_LSC_HPP__


47 #define 
	#__OPENCV_LSC_HPP__


	)

48 #ifdef 
__cplusplus


50 #include 
	~<opencv2/core.hpp
>

52 
namespace
 
	gcv


54 
namespace
 
	gximgproc


71 class 
	cCV_EXPORTS_W
 
	gSuperpixelLSC
 : 
public
 
Algorithm


73 
public
:

78 
CV_WRAP
 
virtual
 int 
getNumberOfSuperpixels
() const = 0;

94 
CV_WRAP
 
virtual
 void 
iterate
( int 
num_iterations
 = 10 ) = 0;

106 
CV_WRAP
 
virtual
 void 
getLabels
( 
OutputArray
 
labels_out
 ) const = 0;

118 
CV_WRAP
 
virtual
 void 
getLabelContourMask
( 
OutputArray
 
image
, 
bool
 
thick_line
 = 
true
 ) const = 0;

129 
CV_WRAP
 
virtual
 void 
enforceLabelConnectivity
( int 
min_element_size
 = 25 ) = 0;

150 
CV_EXPORTS_W
 
	gPtr
<
	gSuperpixelLSC
> 
createSuperpixelLSC
( 
InputArray
 
image
, int 
region_size
 = 10, float 
ratio
 = 0.075f );

	@ximgproc/include/opencv2/ximgproc/paillou_filter.hpp

37 #ifndef 
__OPENCV_PAILLOUFILTER_HPP__


38 #define 
	#__OPENCV_PAILLOUFILTER_HPP__


	)

39 #ifdef 
__cplusplus


41 #include 
	~<opencv2/core.hpp
>

43 
namespace
 
	gcv
 {

44 
namespace
 
	gximgproc
 {

61 
CV_EXPORTS
 void 
GradientPaillouY
(
InputArray
 
op
, 
OutputArray
 
_dst
, double 
alpha
, double 
omega
);

62 
CV_EXPORTS
 void 
GradientPaillouX
(
InputArray
 
op
, 
OutputArray
 
_dst
, double 
alpha
, double 
omega
);

	@ximgproc/include/opencv2/ximgproc/peilin.hpp

5 #ifndef 
__OPENCV_PEILIN_HPP__


6 #define 
	#__OPENCV_PEILIN_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

26 
CV_EXPORTS
 
Matx23d
 
PeiLinNormalization
 ( 
InputArray
 
I
 );

28 
CV_EXPORTS_W
 void 
PeiLinNormalization
 ( 
InputArray
 
I
, 
OutputArray
 
T
 );

	@ximgproc/include/opencv2/ximgproc/radon_transform.hpp

5 #ifndef 
__OPENCV_RADON_TRANSFORM_HPP__


6 #define 
	#__OPENCV_RADON_TRANSFORM_HPP__


	)

8 #include 
	~"opencv2/core.hpp
"

9 #include 
	~"opencv2/imgproc.hpp
"

11 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

31 
CV_EXPORTS_W
 void 
RadonTransform
(
InputArray
 
src
,

32 
OutputArray
 
dst
,

33 double 
theta
 = 1,

34 double 
start_angle
 = 0,

35 double 
end_angle
 = 180,

36 
bool
 
crop
 = 
false
,

37 
bool
 
norm
 = 
false
);

	@ximgproc/include/opencv2/ximgproc/ridgefilter.hpp

11 #ifndef 
__OPENCV_XIMGPROC_RIDGEFILTER_HPP__


12 #define 
	#__OPENCV_XIMGPROC_RIDGEFILTER_HPP__


	)

14 #include 
	~<opencv2/core.hpp
>

16 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

27 class 
	cCV_EXPORTS_W
 
	gRidgeDetectionFilter
 : 
public
 
Algorithm


29 
public
:

42 
CV_WRAP
 static 
Ptr
<
RidgeDetectionFilter
> 
create
(int 
ddepth
 = 
CV_32FC1
, int 
dx
=1, int 
dy
=1, int 
ksize
 = 3, int 
out_dtype
=
CV_8UC1
, double 
scale
 = 1, double 
delta
 = 0, int 
borderType
 = 
BORDER_DEFAULT
);

48 
CV_WRAP
 
virtual
 void 
getRidgeFilteredImage
(
InputArray
 
_img
, 
OutputArray
 
out
) = 0;

	@ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp

5 #ifndef 
__OPENCV_RUN_LENGTH_MORPHOLOGY_HPP__


6 #define 
	#__OPENCV_RUN_LENGTH_MORPHOLOGY_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 
namespace
 
	gcv
 {

11 
namespace
 
	gximgproc
 {

12 
namespace
 
	grl
 {

28 
CV_EXPORTS
 void 
threshold
(
InputArray
 
src
, 
OutputArray
 
rlDest
, double 
thresh
, int 
type
);

42 
CV_EXPORTS
 void 
dilate
(
InputArray
 
rlSrc
, 
OutputArray
 
rlDest
, InputArray 
rlKernel
, 
Point
 
anchor
 = Point(0, 0));

57 
CV_EXPORTS
 void 
erode
(
InputArray
 
rlSrc
, 
OutputArray
 
rlDest
, InputArray 
rlKernel
,

58 
bool
 
bBoundaryOn
 = 
true
, 
Point
 
anchor
 = Point(0, 0));

68 
CV_EXPORTS
 
	gcv
::
Mat
 
getStructuringElement
(int 
shape
, 
Size
 
ksize
);

79 
CV_EXPORTS
 void 
paint
(
InputOutputArray
 
image
, 
InputArray
 
rlSrc
, const 
cv
::
Scalar
& 
value
);

87 
CV_EXPORTS
 
bool
 
isRLMorphologyPossible
(
InputArray
 
rlStructuringElement
);

97 
CV_EXPORTS
 void 
createRLEImage
(const 
std
::
vector
<
cv
::
Point3i
>& 
runs
, 
OutputArray
 
res
, 
Size
 
size
 = Size(0, 0));

113 
CV_EXPORTS
 void 
morphologyEx
(
InputArray
 
rlSrc
, 
OutputArray
 
rlDest
, int 
op
, InputArray 
rlKernel
,

114 
bool
 
bBoundaryOnForErosion
 = 
true
, 
Point
 
anchor
 = Point(0,0));

	@ximgproc/include/opencv2/ximgproc/scansegment.hpp

7 #ifndef 
__OPENCV_XIMGPROC_SCANSEGMENT_HPP__


8 #define 
	#__OPENCV_XIMGPROC_SCANSEGMENT_HPP__


	)

10 #include 
	~<opencv2/core.hpp
>

12 
namespace
 
	gcv
 { namespace 
	gximgproc
 {

23 class 
	cCV_EXPORTS_W
 
	gScanSegment
 : 
public
 
Algorithm


25 
public
:

26 
virtual
 ~
ScanSegment
();

32 
CV_WRAP
 
virtual
 int 
getNumberOfSuperpixels
() = 0;

43 
CV_WRAP
 
virtual
 void 
iterate
(
InputArray
 
img
) = 0;

52 
CV_WRAP
 
virtual
 void 
getLabels
(
OutputArray
 
labels_out
) = 0;

61 
CV_WRAP
 
virtual
 void 
getLabelContourMask
(
OutputArray
 
image
, 
bool
 
thick_line
 = 
false
) = 0;

80 
CV_EXPORTS_W
 
	gcv
::
Ptr
<
ScanSegment
> 
createScanSegment
(int 
image_width
, int 
image_height
, int 
num_superpixels
, int 
slices
 = 8, 
bool
 
merge_small
 = 
true
);

	@ximgproc/include/opencv2/ximgproc/seeds.hpp

42 #ifndef 
__OPENCV_SEEDS_HPP__


43 #define 
	#__OPENCV_SEEDS_HPP__


	)

44 #ifdef 
__cplusplus


46 #include 
	~<opencv2/core.hpp
>

48 
namespace
 
	gcv


50 
namespace
 
	gximgproc


66 class 
	cCV_EXPORTS_W
 
	gSuperpixelSEEDS
 : 
public
 
Algorithm


68 
public
:

75 
CV_WRAP
 
virtual
 int 
getNumberOfSuperpixels
() = 0;

99 
CV_WRAP
 
virtual
 void 
iterate
(
InputArray
 
img
, int 
num_iterations
=4) = 0;

111 
CV_WRAP
 
virtual
 void 
getLabels
(
OutputArray
 
labels_out
) = 0;

139 
CV_WRAP
 
virtual
 void 
getLabelContourMask
(
OutputArray
 
image
, 
bool
 
thick_line
 = 
false
) = 0;

141 
	gvirtual
 ~
SuperpixelSEEDS
() {}

173 
CV_EXPORTS_W
 
	gPtr
<
	gSuperpixelSEEDS
> 
createSuperpixelSEEDS
(

174 int 
image_width
, int 
image_height
, int 
image_channels
,

175 int 
num_superpixels
, int 
num_levels
, int 
prior
 = 2,

176 int 
histogram_bins
=5, 
bool
 
double_step
 = 
false
);

	@ximgproc/include/opencv2/ximgproc/segmentation.hpp

32 #ifndef 
__OPENCV_XIMGPROC_SEGMENTATION_HPP__


33 #define 
	#__OPENCV_XIMGPROC_SEGMENTATION_HPP__


	)

35 #include 
	~<opencv2/core.hpp
>

37 
namespace
 
	gcv
 {

38 
namespace
 
	gximgproc
 {

39 
namespace
 
	gsegmentation
 {

46 class 
	cCV_EXPORTS_W
 
	gGraphSegmentation
 : 
public
 
Algorithm
 {

47 
public
:

52 
CV_WRAP
 
virtual
 void 
processImage
(
InputArray
 
src
, 
OutputArray
 
dst
) = 0;

54 
CV_WRAP
 
virtual
 void 
setSigma
(double 
sigma
) = 0;

55 
CV_WRAP
 
virtual
 double 
getSigma
() = 0;

57 
CV_WRAP
 
virtual
 void 
setK
(float 
k
) = 0;

58 
CV_WRAP
 
virtual
 float 
getK
() = 0;

60 
CV_WRAP
 
virtual
 void 
setMinSize
(int 
min_size
) = 0;

61 
CV_WRAP
 
virtual
 int 
getMinSize
() = 0;

69 
CV_EXPORTS_W
 
	gPtr
<
	gGraphSegmentation
> 
createGraphSegmentation
(double 
sigma
=0.5, float 
k
=300, int 
min_size
=100);

74 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategy
 : 
public
 
Algorithm
 {

75 
public
:

82 
CV_WRAP
 
virtual
 void 
setImage
(
InputArray
 
img
, InputArray 
regions
, InputArray 
sizes
, int 
image_id
 = -1) = 0;

88 
CV_WRAP
 
virtual
 float 
get
(int 
r1
, int 
r2
) = 0;

94 
CV_WRAP
 
virtual
 void 
merge
(int 
r1
, int 
r2
) = 0;

100 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategyColor
 : 
public
 
SelectiveSearchSegmentationStrategy
 {

104 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyColor
> 
createSelectiveSearchSegmentationStrategyColor
();

109 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategySize
 : 
public
 
SelectiveSearchSegmentationStrategy
 {

113 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategySize
> 
createSelectiveSearchSegmentationStrategySize
();

118 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategyTexture
 : 
public
 
SelectiveSearchSegmentationStrategy
 {

122 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyTexture
> 
createSelectiveSearchSegmentationStrategyTexture
();

127 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategyFill
 : 
public
 
SelectiveSearchSegmentationStrategy
 {

131 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyFill
> 
createSelectiveSearchSegmentationStrategyFill
();

135 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentationStrategyMultiple
 : 
public
 
SelectiveSearchSegmentationStrategy
 {

136 
public
:

142 
CV_WRAP
 
virtual
 void 
addStrategy
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
g
, float 
weight
) = 0;

145 
CV_WRAP
 
virtual
 void 
clearStrategies
() = 0;

149 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyMultiple
> 
createSelectiveSearchSegmentationStrategyMultiple
();

154 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyMultiple
> 
createSelectiveSearchSegmentationStrategyMultiple
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
s1
);

160 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyMultiple
> 
createSelectiveSearchSegmentationStrategyMultiple
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
s1
, Ptr<SelectiveSearchSegmentationStrategy> 
s2
);

168 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyMultiple
> 
createSelectiveSearchSegmentationStrategyMultiple
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
s1
, Ptr<SelectiveSearchSegmentationStrategy> 
s2
, Ptr<SelectiveSearchSegmentationStrategy> 
s3
);

176 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentationStrategyMultiple
> 
createSelectiveSearchSegmentationStrategyMultiple
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
s1
, Ptr<SelectiveSearchSegmentationStrategy> 
s2
, Ptr<SelectiveSearchSegmentationStrategy> 
s3
, Ptr<SelectiveSearchSegmentationStrategy> 
s4
);

181 class 
	cCV_EXPORTS_W
 
	gSelectiveSearchSegmentation
 : 
public
 
Algorithm
 {

182 
public
:

187 
CV_WRAP
 
virtual
 void 
setBaseImage
(
InputArray
 
img
) = 0;

193 
CV_WRAP
 
virtual
 void 
switchToSingleStrategy
(int 
k
 = 200, float 
sigma
 = 0.8f) = 0;

200 
CV_WRAP
 
virtual
 void 
switchToSelectiveSearchFast
(int 
base_k
 = 150, int 
inc_k
 = 150, float 
sigma
 = 0.8f) = 0;

207 
CV_WRAP
 
virtual
 void 
switchToSelectiveSearchQuality
(int 
base_k
 = 150, int 
inc_k
 = 150, float 
sigma
 = 0.8f) = 0;

212 
CV_WRAP
 
virtual
 void 
addImage
(
InputArray
 
img
) = 0;

216 
CV_WRAP
 
virtual
 void 
clearImages
() = 0;

221 
CV_WRAP
 
virtual
 void 
addGraphSegmentation
(
Ptr
<
GraphSegmentation
> 
g
) = 0;

225 
CV_WRAP
 
virtual
 void 
clearGraphSegmentations
() = 0;

230 
CV_WRAP
 
virtual
 void 
addStrategy
(
Ptr
<
SelectiveSearchSegmentationStrategy
> 
s
) = 0;

234 
CV_WRAP
 
virtual
 void 
clearStrategies
() = 0;

239 
CV_WRAP
 
virtual
 void 
process
(
CV_OUT
 
std
::
vector
<
Rect
>& 
rects
) = 0;

244 
CV_EXPORTS_W
 
	gPtr
<
	gSelectiveSearchSegmentation
> 
createSelectiveSearchSegmentation
();

	@ximgproc/include/opencv2/ximgproc/slic.hpp

50 #ifndef 
__OPENCV_SLIC_HPP__


51 #define 
	#__OPENCV_SLIC_HPP__


	)

52 #ifdef 
__cplusplus


54 #include 
	~<opencv2/core.hpp
>

56 
namespace
 
	gcv


58 
namespace
 
	gximgproc


64 enum 
	eSLICType
 { 
	gSLIC
 = 100, 
	gSLICO
 = 101, 
	gMSLIC
 = 102 };

78 class 
	cCV_EXPORTS_W
 
	gSuperpixelSLIC
 : 
public
 
Algorithm


80 
public
:

85 
CV_WRAP
 
virtual
 int 
getNumberOfSuperpixels
() const = 0;

101 
CV_WRAP
 
virtual
 void 
iterate
( int 
num_iterations
 = 10 ) = 0;

113 
CV_WRAP
 
virtual
 void 
getLabels
( 
OutputArray
 
labels_out
 ) const = 0;

125 
CV_WRAP
 
virtual
 void 
getLabelContourMask
( 
OutputArray
 
image
, 
bool
 
thick_line
 = 
true
 ) const = 0;

136 
CV_WRAP
 
virtual
 void 
enforceLabelConnectivity
( int 
min_element_size
 = 25 ) = 0;

160 
CV_EXPORTS_W
 
	gPtr
<
	gSuperpixelSLIC
> 
createSuperpixelSLIC
( 
InputArray
 
image
, int 
algorithm
 = 
SLICO
,

161 int 
region_size
 = 10, float 
ruler
 = 10.0f );

	@ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp

37 #ifndef 
__OPENCV_SPARSEMATCHINTERPOLATOR_HPP__


38 #define 
	#__OPENCV_SPARSEMATCHINTERPOLATOR_HPP__


	)

39 #ifdef 
__cplusplus


41 #include 
	~<opencv2/core.hpp
>

43 
namespace
 
	gcv
 {

44 
namespace
 
	gximgproc
 {

52 class 
	cCV_EXPORTS_W
 
	gSparseMatchInterpolator
 : 
public
 
Algorithm


54 
public
:

69 
CV_WRAP
 
virtual
 void 
interpolate
(
InputArray
 
from_image
, InputArray 
from_points
,

70 
InputArray
 
to_image
 , InputArray 
to_points
,

71 
OutputArray
 
dense_flow
) = 0;

77 class 
	cCV_EXPORTS_W
 
	gEdgeAwareInterpolator
 : 
public
 
SparseMatchInterpolator


79 
public
:

88 
CV_WRAP
 
virtual
 void 
setCostMap
(const 
Mat
 & 
_costMap
) = 0;

96 
CV_WRAP
 
virtual
 void 
setK
(int 
_k
) = 0;

98 
CV_WRAP
 
virtual
 int 
getK
() = 0;

104 
CV_WRAP
 
virtual
 void 
setSigma
(float 
_sigma
) = 0;

106 
CV_WRAP
 
virtual
 float 
getSigma
() = 0;

111 
CV_WRAP
 
virtual
 void 
setLambda
(float 
_lambda
) = 0;

113 
CV_WRAP
 
virtual
 float 
getLambda
() = 0;

118 
CV_WRAP
 
virtual
 void 
setUsePostProcessing
(
bool
 
_use_post_proc
) = 0;

120 
CV_WRAP
 
virtual
 
bool
 
getUsePostProcessing
() = 0;

124 
CV_WRAP
 
virtual
 void 
setFGSLambda
(float 
_lambda
) = 0;

126 
CV_WRAP
 
virtual
 float 
getFGSLambda
() = 0;

129 
CV_WRAP
 
virtual
 void 
setFGSSigma
(float 
_sigma
) = 0;

131 
CV_WRAP
 
virtual
 float 
getFGSSigma
() = 0;

137 
CV_EXPORTS_W


138 
	gPtr
<
	gEdgeAwareInterpolator
> 
createEdgeAwareInterpolator
();

146 class 
	cCV_EXPORTS_W
 
	gRICInterpolator
 : 
public
 
SparseMatchInterpolator


148 
public
:

153 
CV_WRAP
 
virtual
 void 
setK
(int 
k
 = 32) = 0;

157 
CV_WRAP
 
virtual
 int 
getK
() const = 0;

166 
CV_WRAP
 
virtual
 void 
setCostMap
(const 
Mat
 & 
costMap
) = 0;

170 
CV_WRAP
 
virtual
 void 
setSuperpixelSize
(int 
spSize
 = 15) = 0;

174 
CV_WRAP
 
virtual
 int 
getSuperpixelSize
() const = 0;

178 
CV_WRAP
 
virtual
 void 
setSuperpixelNNCnt
(int 
spNN
 = 150) = 0;

182 
CV_WRAP
 
virtual
 int 
getSuperpixelNNCnt
() const = 0;

186 
CV_WRAP
 
virtual
 void 
setSuperpixelRuler
(float 
ruler
 = 15.f) = 0;

190 
CV_WRAP
 
virtual
 float 
getSuperpixelRuler
() const = 0;

197 
CV_WRAP
 
virtual
 void 
setSuperpixelMode
(int 
mode
 = 100) = 0;

201 
CV_WRAP
 
virtual
 int 
getSuperpixelMode
() const = 0;

204 
CV_WRAP
 
virtual
 void 
setAlpha
(float 
alpha
 = 0.7f) = 0;

208 
CV_WRAP
 
virtual
 float 
getAlpha
() const = 0;

211 
CV_WRAP
 
virtual
 void 
setModelIter
(int 
modelIter
 = 4) = 0;

215 
CV_WRAP
 
virtual
 int 
getModelIter
() const = 0;

218 
CV_WRAP
 
virtual
 void 
setRefineModels
(
bool
 
refineModles
 = 
true
) = 0;

222 
CV_WRAP
 
virtual
 
bool
 
getRefineModels
() const = 0;

226 
CV_WRAP
 
virtual
 void 
setMaxFlow
(float 
maxFlow
 = 250.f) = 0;

230 
CV_WRAP
 
virtual
 float 
getMaxFlow
() const = 0;

233 
CV_WRAP
 
virtual
 void 
setUseVariationalRefinement
(
bool
 
use_variational_refinement
 = 
false
) = 0;

237 
CV_WRAP
 
virtual
 
bool
 
getUseVariationalRefinement
() const = 0;

240 
CV_WRAP
 
virtual
 void 
setUseGlobalSmootherFilter
(
bool
 
use_FGS
 = 
true
) = 0;

244 
CV_WRAP
 
virtual
 
bool
 
getUseGlobalSmootherFilter
() const = 0;

247 
CV_WRAP
 
virtual
 void 
setFGSLambda
(float 
lambda
 = 500.f) = 0;

251 
CV_WRAP
 
virtual
 float 
getFGSLambda
() const = 0;

254 
CV_WRAP
 
virtual
 void 
setFGSSigma
(float 
sigma
 = 1.5f) = 0;

258 
CV_WRAP
 
virtual
 float 
getFGSSigma
() const = 0;

264 
CV_EXPORTS_W


265 
	gPtr
<
	gRICInterpolator
> 
createRICInterpolator
();

	@ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp

43 #ifndef 
__OPENCV_STRUCTURED_EDGE_DETECTION_HPP__


44 #define 
	#__OPENCV_STRUCTURED_EDGE_DETECTION_HPP__


	)

45 #ifdef 
__cplusplus


52 #include 
	~<opencv2/core.hpp
>

54 
namespace
 
	gcv


56 
namespace
 
	gximgproc


65 class 
	cCV_EXPORTS_W
 
	gRFFeatureGetter
 : 
public
 
Algorithm


67 
public
:

83 
CV_WRAP
 
virtual
 void 
getFeatures
(const 
Mat
 &
src
, Mat &
features
,

84 const int 
gnrmRad
,

85 const int 
gsmthRad
,

86 const int 
shrink
,

87 const int 
outNum
,

88 const int 
gradNum
) const = 0;

91 
CV_EXPORTS_W
 
	gPtr
<
	gRFFeatureGetter
> 
createRFFeatureGetter
();

97 class 
	cCV_EXPORTS_W
 
	gStructuredEdgeDetection
 : 
public
 
Algorithm


99 
public
:

109 
CV_WRAP
 
virtual
 void 
detectEdges
(
cv
::
InputArray
 
src
, cv::
OutputArray
 
dst
) const = 0;

116 
CV_WRAP
 
virtual
 void 
computeOrientation
(
cv
::
InputArray
 
src
, cv::
OutputArray
 
dst
) const = 0;

129 
CV_WRAP
 
virtual
 void 
edgesNms
(
cv
::
InputArray
 
edge_image
, cv::InputArray 
orientation_image
, cv::
OutputArray
 
dst
, int 
r
 = 2, int 
s
 = 0, float 
m
 = 1, 
bool
 
isParallel
 = 
true
) const = 0;

140 
CV_EXPORTS_W
 
	gPtr
<
	gStructuredEdgeDetection
> 
createStructuredEdgeDetection
(const 
String
 &
model
,

141 
Ptr
<const 
RFFeatureGetter
> 
howToGetFeatures
 = Ptr<RFFeatureGetter>());

	@ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp

43 #ifndef 
__OPENCV_WEIGHTED_MEDIAN_FILTER_HPP__


44 #define 
	#__OPENCV_WEIGHTED_MEDIAN_FILTER_HPP__


	)

45 #ifdef 
__cplusplus


53 #include 
	~<opencv2/core.hpp
>

54 #include 
	~<string
>

56 
namespace
 
	gcv


58 
namespace
 
	gximgproc


64 enum 
	eWMFWeightType


66 
	gWMF_EXP
 = 1 ,

67 
	gWMF_IV1
 = 1 << 1,

68 
	gWMF_IV2
 = 1 << 2,

69 
	gWMF_COS
 = 1 << 3,

70 
	gWMF_JAC
 = 1 << 4,

71 
	gWMF_OFF
 = 1 << 5

90 
CV_EXPORTS_W
 void 
weightedMedianFilter
(
InputArray
 
joint
, InputArray 
src
, 
OutputArray
 
dst
,

91 int 
r
, double 
sigma
 = 25.5, int 
weightType
 = 
WMF_EXP
, 
InputArray
 
mask
 = 
noArray
());

	@ximgproc/src/edge_drawing.cpp

5 #include 
	~"precomp.hpp
"

6 #include 
	~"edge_drawing_common.hpp
"

7 #include 
	~<cstddef
>

9 
using
 
namespace
 
	gstd
;

11 
namespace
 
	gcv


13 
namespace
 
	gximgproc


16 struct 
	gComputeGradientBody
 : 
ParallelLoopBody


18 void 
operator
() (const 
Range
& 
range
) const 
CV_OVERRIDE
;

20 
	gMat_
<
	guchar
> 
	gsrc
;

21 
mutable
 
	gMat_
<
	gushort
> 
	ggradImage
;

22 
mutable
 
	gMat_
<
	guchar
> 
	gdirImage
;

23 int 
	ggradThresh
;

24 int 
	gop
;

25 
bool
 
	gSumFlag
;

26 int* 
	ggrads
;

27 
bool
 
	gPFmode
;

30 void 
	gComputeGradientBody
::
operator
() (const 
Range
& 
range
) const

32 const int 
last_col
 = 
src
.
cols
 - 1;

33 int 
	ggx
 = 0;

34 int 
	ggy
 = 0;

35 int 
	gsum
;

37 for (int 
	gy
 = 
range
.
start
; y < 
	grange
.
	gend
; ++y)

39 const 
uchar
* 
	gsrcPrevRow
 = 
src
[
y
 - 1];

40 const 
uchar
* 
	gsrcCurRow
 = 
src
[
y
];

41 const 
uchar
* 
	gsrcNextRow
 = 
src
[
y
 + 1];

43 
ushort
* 
	ggradRow
 = 
gradImage
[
y
];

44 
uchar
* 
	gdirRow
 = 
dirImage
[
y
];

46 for (int 
	gx
 = 1; x < 
	glast_col
; ++x)

48 int 
	gcom1
 = 
srcNextRow
[
x
 + 1] - 
srcPrevRow
[x - 1];

49 int 
	gcom2
 = 
srcPrevRow
[
x
 + 1] - 
srcNextRow
[x - 1];

51 switch (
	gop
)

53 case 
	gEdgeDrawing
::
PREWITT
:

54 
gx
 = 
abs
(
com1
 + 
com2
 + 
srcCurRow
[
x
 + 1] - srcCurRow[x - 1]);

55 
	ggy
 = 
abs
(
com1
 - 
com2
 + 
srcNextRow
[
x
] - 
srcPrevRow
[x]);

57 case 
	gEdgeDrawing
::
SOBEL
:

58 
gx
 = 
abs
(
com1
 + 
com2
 + 2 * (
srcCurRow
[
x
 + 1] - srcCurRow[x - 1]));

59 
	ggy
 = 
abs
(
com1
 - 
com2
 + 2 * (
srcNextRow
[
x
] - 
srcPrevRow
[x]));

61 case 
	gEdgeDrawing
::
SCHARR
:

62 
gx
 = 
abs
(3 * (
com1
 + 
com2
) + 10 * (
srcCurRow
[
x
 + 1] - srcCurRow[x - 1]));

63 
	ggy
 = 
abs
(3 * (
com1
 - 
com2
) + 10 * (
srcNextRow
[
x
] - 
srcPrevRow
[x]));

65 case 
	gEdgeDrawing
::
LSD
:

67 
com1
 = 
srcNextRow
[
x
 + 1] - 
srcCurRow
[x];

68 
	gcom2
 = 
srcCurRow
[
x
 + 1] - 
srcNextRow
[x];

70 
	ggx
 = 
abs
(
com1
 + 
com2
);

71 
	ggy
 = 
abs
(
com1
 - 
com2
);

75 if (
	gSumFlag
)

76 
	gsum
 = 
gx
 + 
gy
;

78 
	gsum
 = (int)
sqrt
((double)
gx
 * gx + 
gy
 * gy);

80 
	ggradRow
[
x
] = (
ushort
)
sum
;

82 if (
	gPFmode
)

83 
	ggrads
[
sum
]++;

85 if (
	gsum
 >= 
gradThresh
)

87 if (
gx
 >= 
gy
)

88 
dirRow
[
x
] = 
EDGE_VERTICAL
;

90 
	gdirRow
[
x
] = 
EDGE_HORIZONTAL
;

96 class 
	cEdgeDrawingImpl
 : 
public
 
EdgeDrawing


98 
public
:

100 enum 
	eEllipseFittingMethods


102 
BOOKSTEIN
 = 0,

103 
	gFPF
 = 1

106 
EdgeDrawingImpl
();

107 ~
EdgeDrawingImpl
();

108 void 
detectEdges
(
InputArray
 
src
) 
	gCV_OVERRIDE
;

109 void 
getEdgeImage
(
OutputArray
 
dst
) 
	gCV_OVERRIDE
;

110 void 
getGradientImage
(
OutputArray
 
dst
) 
	gCV_OVERRIDE
;

112 
	gvector
<vector<
	gPoint
> > 
getSegments
() 
	gCV_OVERRIDE
;

113 
	gvector
<int> 
getSegmentIndicesOfLines
() const 
	gCV_OVERRIDE
;

114 void 
detectLines
(
OutputArray
 
lines
) 
	gCV_OVERRIDE
;

115 void 
detectEllipses
(
OutputArray
 
ellipses
) 
	gCV_OVERRIDE
;

117 
virtual
 
String
 
getDefaultName
() const 
	gCV_OVERRIDE
;

118 
virtual
 void 
read
(const 
FileNode
& 
fn
) 
	gCV_OVERRIDE
;

119 
virtual
 void 
write
(
FileStorage
& 
fs
) const 
	gCV_OVERRIDE
;

121 
	gprotected
:

122 int 
width
;

123 int 
	gheight
;

124 
uchar
 *
	gsrcImg
;

125 
	gvector
<vector<
	gPoint
> > 
	gsegmentPoints
;

126 
	gvector
<int> 
	gsegmentIndicesOfLines
;

127 
Mat
 
	gsmoothImage
;

128 
uchar
 *
	gedgeImg
;

129 
uchar
 *
	gsmoothImg
;

130 int 
	gsegmentNos
;

131 
Mat
 
	gsrcImage
;

133 double 
	gdivForTestSegment
;

134 double* 
	gdH
;

135 int* 
	ggrads
;

136 int 
	gnp
;

138 
	gprivate
:

139 void 
ComputeGradient
();

140 void 
ComputeAnchorPoints
();

141 void 
JoinAnchorPointsUsingSortedAnchors
();

142 int* 
sortAnchorsByGradValue1
();

144 static int 
LongestChain
(
Chain
 *
chains
, int 
root
);

145 static int 
RetrieveChainNos
(
Chain
 *
chains
, int 
root
, int 
chainNos
[]);

147 int 
	ganchorNos
;

148 
	gvector
<
	gPoint
> 
	ganchorPoints
;

149 
	gvector
<
	gPoint
> 
	gedgePoints
;

151 
Mat
 
	gedgeImage
;

152 
Mat
 
	ggradImage
;

153 
Mat
 
	gdirImage
;

154 
uchar
 *
	gdirImg
;

155 
ushort
 *
	ggradImg
;

157 int 
	gop
;

158 int 
	ggradThresh
;

159 int 
	ganchorThresh
;

161 
	gstd
::
vector
<
EDLineSegment
> 
lines
;

162 int 
	glinesNo
;

163 int 
	gmin_line_len
;

164 double 
	gline_error
;

165 double 
	gmax_distance_between_two_lines
;

166 double 
	gmax_error
;

167 double 
	gprecision
;

168 
NFALUT
* 
	gnfa
;

170 int 
ComputeMinLineLength
();

171 void 
SplitSegment2Lines
(double* 
x
, double* 
y
, int 
noPixels
, int 
segmentNo
);

172 void 
JoinCollinearLines
();

174 void 
ValidateLineSegments
();

175 
bool
 
ValidateLineSegmentRect
(int* 
x
, int* 
y
, 
EDLineSegment
* 
ls
);

176 
bool
 
TryToJoinTwoLineSegments
(
EDLineSegment
* 
ls1
, EDLineSegment* 
ls2
, int 
changeIndex
);

178 static double 
ComputeMinDistance
(double 
x1
, double 
y1
, double 
a
, double 
b
, int 
invert
);

179 static void 
ComputeClosestPoint
(double 
x1
, double 
y1
, double 
a
, double 
b
, int 
invert
, double& 
xOut
, double& 
yOut
);

180 static void 
LineFit
(double* 
x
, double* 
y
, int 
count
, double& 
a
, double& 
b
, int 
invert
);

181 static void 
LineFit
(double* 
x
, double* 
y
, int 
count
, double& 
a
, double& 
b
, double& 
e
, int& 
invert
);

182 static double 
ComputeMinDistanceBetweenTwoLines
(
EDLineSegment
* 
ls1
, EDLineSegment* 
ls2
, int* 
pwhich
);

183 static void 
UpdateLineParameters
(
EDLineSegment
* 
ls
);

184 static void 
EnumerateRectPoints
(double 
sx
, double 
sy
, double 
ex
, double 
ey
, int 
ptsx
[], int 
ptsy
[], int* 
pNoPoints
);

186 void 
TestSegment
(int 
i
, int 
index1
, int 
index2
);

187 void 
ExtractNewSegments
();

188 double 
NFA
(double 
prob
, int 
len
);

190 int 
	gnoEllipses
;

191 int 
	gnoCircles
;

192 
	gstd
::
vector
<
mCircle
> 
Circles
;

193 
	gstd
::
vector
<
mEllipse
> 
Ellipses
;

195 
Circle
* 
	gcircles1
;

196 
Circle
* 
	gcircles2
;

197 
Circle
* 
	gcircles3
;

198 int 
	gnoCircles1
;

199 int 
	gnoCircles2
;

200 int 
	gnoCircles3
;

202 
EDArcs
* 
	gedarcs1
;

203 
EDArcs
* 
	gedarcs2
;

204 
EDArcs
* 
	gedarcs3
;

205 
EDArcs
* 
	gedarcs4
;

207 int* 
	gsegmentStartLines
;

208 
BufferManager
* 
	gbm
;

209 
Info
* 
	ginfo
;

211 void 
GenerateCandidateCircles
();

212 void 
DetectArcs
();

213 void 
ValidateCircles
(
bool
 
validate
);

214 void 
JoinCircles
();

215 void 
JoinArcs1
();

216 void 
JoinArcs2
();

217 void 
JoinArcs3
();

220 static void 
addCircle
(
Circle
* 
circles
, int& 
noCircles
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, double* 
x
, double* 
y
, int 
noPixels
);

221 static void 
addCircle
(
Circle
* 
circles
, int& 
noCircles
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, 
EllipseEquation
* 
pEq
, double 
ellipseFitError
, double* 
x
, double* 
y
, int 
noPixels
);

222 static void 
sortCircles
(
Circle
* 
circles
, int 
noCircles
);

223 static 
bool
 
CircleFit
(double* 
x
, double* 
y
, int 
N
, double* 
pxc
, double* 
pyc
, double* 
pr
, double* 
pe
);

224 static void 
ComputeCirclePoints
(double 
xc
, double 
yc
, double 
r
, double* 
px
, double* 
py
, int* 
noPoints
);

227 static 
bool
 
EllipseFit
(double* 
x
, double* 
y
, int 
noPoints
, 
EllipseEquation
* 
pResult
, int 
mode
 = 
FPF
);

228 static double** 
AllocateMatrix
(int 
noRows
, int 
noColumns
);

229 static void 
A_TperB
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
);

230 static void 
choldc
(double** 
a
, int 
n
, double** 
l
);

231 static int 
inverse
(double** 
TB
, double** 
InvB
, int 
N
);

232 static void 
DeallocateMatrix
(double** 
m
, int 
noRows
);

233 static void 
AperB_T
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
);

234 static void 
AperB
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
);

235 static void 
jacobi
(double** 
a
, int 
n
, double 
d
[], double** 
v
);

236 static void 
ROTATE
(double** 
a
, int 
i
, int 
j
, int 
k
, int 
l
, double 
tau
, double 
s
);

237 static double 
computeEllipsePerimeter
(
EllipseEquation
* 
eq
);

238 static double 
ComputeEllipseError
(
EllipseEquation
* 
eq
, double* 
px
, double* 
py
, int 
noPoints
);

239 static double 
ComputeEllipseCenterAndAxisLengths
(
EllipseEquation
* 
eq
, double* 
pxc
, double* 
pyc
, double* 
pmajorAxisLength
, double* 
pminorAxisLength
);

240 static void 
ComputeEllipsePoints
(double* 
pvec
, double* 
px
, double* 
py
, int 
noPoints
);

243 static void 
joinLastTwoArcs
(
MyArc
* 
arcs
, int& 
noArcs
);

244 static void 
addArc
(
MyArc
* 
arcs
, int& 
noArchs
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
,

245 double 
sTheta
, double 
eTheta
, int 
turn
, int 
segmentNo
,

246 int 
sx
, int 
sy
, int 
ex
, int 
ey
,

247 double* 
x
, double* 
y
, int 
noPixels
, double 
overlapRatio
 = 0.0);

248 static void 
addArc
(
MyArc
* 
arcs
, int& 
noArchs
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
,

249 double 
sTheta
, double 
eTheta
, int 
turn
, int 
segmentNo
,

250 
EllipseEquation
* 
pEq
, double 
ellipseFitError
,

251 int 
sx
, int 
sy
, int 
ex
, int 
ey
,

252 double* 
x
, double* 
y
, int 
noPixels
, double 
overlapRatio
 = 0.0);

254 static void 
ComputeStartAndEndAngles
(double 
xc
, double 
yc
, double 
r
,

255 double* 
x
, double* 
y
, int 
len
,

256 double* 
psTheta
, double* 
peTheta
);

258 static void 
sortArc
(
MyArc
* 
arcs
, int 
noArcs
);

261 
	gPtr
<
	gEdgeDrawing
> 
createEdgeDrawing
()

263 return 
	gmakePtr
<
	gEdgeDrawingImpl
>();

266 
	gEdgeDrawing
::
Params
::Params()

268 
PFmode
 = 
false
;

269 
	gEdgeDetectionOperator
 = 
PREWITT
;

270 
	gGradientThresholdValue
 = 20;

271 
	gAnchorThresholdValue
 = 0;

272 
	gScanInterval
 = 1;

273 
	gMinPathLength
 = 10;

274 
	gSigma
 = 1.0;

275 
	gSumFlag
 = 
true
;

276 
	gNFAValidation
 = 
true
;

277 
	gMinLineLength
 = -1;

278 
	gMaxDistanceBetweenTwoLines
 = 6.0;

279 
	gLineFitErrorThreshold
 = 1.0;

280 
	gMaxErrorThreshold
 = 1.3;

283 void 
	gEdgeDrawing
::
setParams
(const 
EdgeDrawing
::
Params
& 
parameters
)

285 
params
 = 
parameters
;

288 void 
	gEdgeDrawing
::
Params
::
read
(const 
cv
::
FileNode
& 
fn
)

290 
PFmode
 = (int)
fn
["PFmode"] != 0 ? 
true
 : 
false
;

291 
	gEdgeDetectionOperator
 = 
fn
["EdgeDetectionOperator"];

292 
	gGradientThresholdValue
 = 
fn
["GradientThresholdValue"];

293 
	gAnchorThresholdValue
 = 
fn
["AnchorThresholdValue"];

294 
	gScanInterval
 = 
fn
["ScanInterval"];

295 
	gMinPathLength
 = 
fn
["MinPathLength"];

296 
	gSigma
 = 
fn
["Sigma"];

297 
	gSumFlag
 = (int)
fn
["SumFlag"] != 0 ? 
true
 : 
false
;

298 
	gNFAValidation
 = (int)
fn
["NFAValidation"] != 0 ? 
true
 : 
false
;

299 
	gMinLineLength
 = 
fn
["MinLineLength"];

300 
	gMaxDistanceBetweenTwoLines
 = 
fn
["MaxDistanceBetweenTwoLines"];

301 
	gLineFitErrorThreshold
 = 
fn
["LineFitErrorThreshold"];

302 
	gMaxErrorThreshold
 = 
fn
["MaxErrorThreshold"];

305 void 
	gEdgeDrawing
::
Params
::
write
(
cv
::
FileStorage
& 
fs
) const

307 
fs
 << "PFmode" << 
PFmode
;

308 
	gfs
 << "EdgeDetectionOperator" << 
	gEdgeDetectionOperator
;

309 
	gfs
 << "GradientThresholdValue" << 
	gGradientThresholdValue
;

310 
	gfs
 << "AnchorThresholdValue" << 
	gAnchorThresholdValue
;

311 
	gfs
 << "ScanInterval" << 
	gScanInterval
;

312 
	gfs
 << "MinPathLength" << 
	gMinPathLength
;

313 
	gfs
 << "Sigma" << 
	gSigma
;

314 
	gfs
 << "SumFlag" << 
	gSumFlag
;

315 
	gfs
 << "NFAValidation" << 
	gNFAValidation
;

316 
	gfs
 << "MinLineLength" << 
	gMinLineLength
;

317 
	gfs
 << "MaxDistanceBetweenTwoLines" << 
	gMaxDistanceBetweenTwoLines
;

318 
	gfs
 << "LineFitErrorThreshold" << 
	gLineFitErrorThreshold
;

319 
	gfs
 << "MaxErrorThreshold" << 
	gMaxErrorThreshold
;

322 
String
 
	gEdgeDrawingImpl
::
getDefaultName
() const

324 return 
String
("EdgeDrawing");

327 void 
	gEdgeDrawingImpl
::
read
(const 
cv
::
FileNode
& 
fn
)

329 
params
.
read
(
fn
);

332 void 
	gEdgeDrawingImpl
::
write
(
cv
::
FileStorage
& 
fs
) const

334 
writeFormat
(
fs
);

335 
	gparams
.
write
(
fs
);

338 
	gEdgeDrawingImpl
::
EdgeDrawingImpl
()

340 
params
 = 
EdgeDrawing
::
Params
();

341 
	gnfa
 = 
new
 
NFALUT
(1, 1/2, 1, 1);

342 
	gdH
 = 
new
 double[
MAX_GRAD_VALUE
];

343 
	ggrads
 = 
new
 int[
MAX_GRAD_VALUE
];

346 
	gEdgeDrawingImpl
::~
EdgeDrawingImpl
()

348 
delete
 
nfa
;

349 
	gdelete
[] 
	gdH
;

350 
	gdelete
[] 
	ggrads
;

353 void 
	gEdgeDrawingImpl
::
detectEdges
(
InputArray
 
src
)

355 
CV_Assert
(!
src
.
empty
() && src.
type
() == 
CV_8UC1
);

356 
	ggradThresh
 = 
params
.
GradientThresholdValue
;

357 
	ganchorThresh
 = 
params
.
AnchorThresholdValue
;

358 
	gop
 = 
params
.
EdgeDetectionOperator
;

361 if (
	gop
 < 0 || op > 3)

362 
	gop
 = 0;

364 if (
	ggradThresh
 < 1)

365 
	ggradThresh
 = 1;

367 if (
	ganchorThresh
 < 0)

368 
	ganchorThresh
 = 0;

370 
	gsegmentNos
 = 0;

371 
	ganchorNos
 = 0;

372 
	ganchorPoints
.
clear
();

373 
	glines
.
clear
();

374 
	gsegmentPoints
.
clear
();

375 
	gsegmentPoints
.
push_back
(
vector
<
Point
>());

376 
	gsrcImage
 = 
src
.
getMat
();

377 
	gsrcImg
 = 
srcImage
.
data
;

378 
	gheight
 = 
srcImage
.
rows
;

379 
	gwidth
 = 
srcImage
.
cols
;

381 
	gedgeImage
 = 
Mat
(
height
, 
width
, 
CV_8UC1
, 
Scalar
(0));

382 
	ggradImage
 = 
Mat
(
height
, 
width
, 
CV_16UC1
);

383 
	gdirImage
 = 
Mat
(
height
, 
width
, 
CV_8UC1
);

385 if (
	gparams
.
	gSigma
 < 1.0)

386 
	gsmoothImage
 = 
srcImage
;

387 else if (
	gparams
.
	gSigma
 == 1.0)

388 
GaussianBlur
(
srcImage
, 
smoothImage
, 
Size
(5, 5), 
params
.
Sigma
);

390 
GaussianBlur
(
srcImage
, 
smoothImage
, 
Size
(), 
params
.
Sigma
);

393 
	gsmoothImg
 = 
smoothImage
.
data
;

394 
	ggradImg
 = (
ushort
*)
gradImage
.
data
;

395 
	gedgeImg
 = 
edgeImage
.
data
;

396 
	gdirImg
 = 
dirImage
.
data
;

398 if (
	gparams
.
	gPFmode
)

400 
memset
(
dH
, 0, sizeof(double) * 
MAX_GRAD_VALUE
);

401 
memset
(
grads
, 0, sizeof(int) * 
MAX_GRAD_VALUE
);

404 
ComputeGradient
();

405 
ComputeAnchorPoints
();

406 
JoinAnchorPointsUsingSortedAnchors
();

408 if (
	gparams
.
	gPFmode
)

411 int 
	gsize
 = (
width
 - 2) * (
height
 - 2);

413 for (int 
	gi
 = 
MAX_GRAD_VALUE
 - 1; i > 0; i--)

414 
	ggrads
[
i
 - 1] += 
grads
[i];

416 for (int 
	gi
 = 0; i < 
	gMAX_GRAD_VALUE
; i++)

417 
	gdH
[
i
] = (double)
grads
[i] / ((double)
size
);

419 
	gdivForTestSegment
 = 2.25;

420 
memset
(
edgeImg
, 0, 
width
 * 
height
);

421 
	gnp
 = 0;

422 for (int 
	gi
 = 0; i < 
	gsegmentNos
; i++)

424 int 
	glen
 = (int)
segmentPoints
[
i
].
size
();

425 
	gnp
 += (
len
 * (len - 1)) / 2;

429 for (int 
	gi
 = 0; i < 
	gsegmentNos
; i++)

430 
TestSegment
(
i
, 0, (int)
segmentPoints
[i].
size
() - 1);

432 
ExtractNewSegments
();

436 void 
	gEdgeDrawingImpl
::
getEdgeImage
(
OutputArray
 
_dst
)

438 if (!
edgeImage
.
empty
())

439 
edgeImage
.
copyTo
(
_dst
);

442 void 
	gEdgeDrawingImpl
::
getGradientImage
(
OutputArray
 
_dst
)

444 if (!
gradImage
.
empty
())

445 
gradImage
.
copyTo
(
_dst
);

448 
	gstd
::
vector
<
std
::vector<
Point
> > 
EdgeDrawingImpl
::
getSegments
()

450 return 
segmentPoints
;

453 
	gstd
::
vector
<int> 
EdgeDrawingImpl
::
getSegmentIndicesOfLines
() const

455 return 
segmentIndicesOfLines
;

458 void 
	gEdgeDrawingImpl
::
ComputeGradient
()

460 for (int 
j
 = 0; 
	gj
 < 
	gwidth
; j++)

462 
	ggradImg
[
j
] = 
gradImg
[(
height
 - 1) * 
width
 + j] = (
ushort
)
gradThresh
 - 1;

465 for (int 
	gi
 = 1; i < 
	gheight
 - 1; i++)

467 
	ggradImg
[
i
 * 
width
] = 
gradImg
[(i + 1) * width - 1] = (
ushort
)
gradThresh
 - 1;

470 
ComputeGradientBody
 
	gbody
;

471 
	gbody
.
	gsrc
 = 
smoothImage
;

472 
	gbody
.
	ggradImage
 = 
gradImage
;

473 
	gbody
.
	gdirImage
 = 
dirImage
;

474 
	gbody
.
	ggradThresh
 = 
gradThresh
;

475 
	gbody
.
	gSumFlag
 = 
params
.
SumFlag
;

476 
	gbody
.
	gop
 = 
op
;

477 
	gbody
.
	ggrads
 = 
grads
;

478 
	gbody
.
	gPFmode
 = 
params
.
PFmode
;

480 
parallel_for_
(
Range
(1, 
smoothImage
.
rows
 - 1), 
body
);

483 void 
	gEdgeDrawingImpl
::
ComputeAnchorPoints
()

485 for (int 
i
 = 2; 
	gi
 < 
	gheight
 - 2; i++)

487 int 
	gstart
 = 2;

488 int 
	ginc
 = 1;

489 if (
	gi
 % 
	gparams
.
	gScanInterval
 != 0)

491 
start
 = 
params
.
ScanInterval
;

492 
	ginc
 = 
params
.
ScanInterval
;

495 for (int 
	gj
 = 
start
; j < 
	gwidth
 - 2; j += 
inc
)

497 if (
gradImg
[
i
 * 
width
 + 
j
] < 
gradThresh
)

500 if (
	gdirImg
[
i
 * 
width
 + 
j
] == 
EDGE_VERTICAL
)

503 int 
diff1
 = 
gradImg
[
i
 * 
width
 + 
j
] - gradImg[i * width + j - 1];

504 int 
	gdiff2
 = 
gradImg
[
i
 * 
width
 + 
j
] - gradImg[i * width + j + 1];

505 if (
	gdiff1
 >= 
anchorThresh
 && 
diff2
 >= anchorThresh)

507 
edgeImg
[
i
 * 
width
 + 
j
] = 
ANCHOR_PIXEL
;

508 
	ganchorPoints
.
push_back
(
Point
(
j
, 
i
));

514 int 
	gdiff1
 = 
gradImg
[
i
 * 
width
 + 
j
] - gradImg[(i - 1) * width + j];

515 int 
	gdiff2
 = 
gradImg
[
i
 * 
width
 + 
j
] - gradImg[(i + 1) * width + j];

516 if (
	gdiff1
 >= 
anchorThresh
 && 
diff2
 >= anchorThresh)

518 
edgeImg
[
i
 * 
width
 + 
j
] = 
ANCHOR_PIXEL
;

519 
	ganchorPoints
.
push_back
(
Point
(
j
, 
i
));

525 
	ganchorNos
 = (int)
anchorPoints
.
size
();

528 void 
	gEdgeDrawingImpl
::
JoinAnchorPointsUsingSortedAnchors
()

530 int* 
chainNos
 = 
new
 int[(
width
 + 
height
) * 8];

532 
Point
* 
	gpixels
 = 
new
 Point[
width
 * 
height
];

533 
StackNode
* 
	gstack
 = 
new
 StackNode[
width
 * 
height
];

534 
Chain
* 
	gchains
 = 
new
 Chain[
width
 * 
height
];

537 int* 
	gpAnchors
 = 
sortAnchorsByGradValue1
();

541 for (int 
	gk0
 = 
anchorNos
 - 1; k0 >= 0; k0--)

543 int 
	gpixelOffset
 = 
pAnchors
[
k0
];

545 int 
	gi
 = 
pixelOffset
 / 
width
;

546 int 
	gj
 = 
pixelOffset
 % 
width
;

548 if (
	gedgeImg
[
i
 * 
width
 + 
j
] != 
ANCHOR_PIXEL
)

551 
	gchains
[0].
	glen
 = 0;

552 
	gchains
[0].
	gparent
 = -1;

553 
	gchains
[0].
	gdir
 = 0;

554 
	gchains
[0].
	gchildren
[0] = 
chains
[0].
children
[1] = -1;

555 
	gchains
[0].
	gpixels
 = 
NULL
;

557 int 
	gnoChains
 = 1;

558 int 
	glen
 = 0;

559 int 
	gduplicatePixelCount
 = 0;

560 int 
	gtop
 = -1;

562 if (
	gdirImg
[
i
 * 
width
 + 
j
] == 
EDGE_VERTICAL
)

564 
stack
[++
top
].
r
 = 
i
;

565 
	gstack
[
top
].
	gc
 = 
j
;

566 
	gstack
[
top
].
	gdir
 = 
DOWN
;

567 
	gstack
[
top
].
	gparent
 = 0;

569 
	gstack
[++
top
].
	gr
 = 
i
;

570 
	gstack
[
top
].
	gc
 = 
j
;

571 
	gstack
[
top
].
	gdir
 = 
UP
;

572 
	gstack
[
top
].
	gparent
 = 0;

576 
	gstack
[++
top
].
	gr
 = 
i
;

577 
	gstack
[
top
].
	gc
 = 
j
;

578 
	gstack
[
top
].
	gdir
 = 
RIGHT
;

579 
	gstack
[
top
].
	gparent
 = 0;

581 
	gstack
[++
top
].
	gr
 = 
i
;

582 
	gstack
[
top
].
	gc
 = 
j
;

583 
	gstack
[
top
].
	gdir
 = 
LEFT
;

584 
	gstack
[
top
].
	gparent
 = 0;

588 
	gStartOfWhile
:

589 while (
top
 >= 0)

591 int 
r
 = 
stack
[
top
].r;

592 int 
	gc
 = 
stack
[
top
].
c
;

593 int 
	gdir
 = 
stack
[
top
].
dir
;

594 int 
	gparent
 = 
stack
[
top
].
parent
;

595 
	gtop
--;

597 if (
	gedgeImg
[
r
 * 
width
 + 
c
] != 
EDGE_PIXEL
)

598 
duplicatePixelCount
++;

600 
	gchains
[
noChains
].
	gdir
 = 
dir
;

601 
	gchains
[
noChains
].
	gparent
 = 
parent
;

602 
	gchains
[
noChains
].
	gchildren
[0] = 
chains
[noChains].
children
[1] = -1;

604 int 
	gchainLen
 = 0;

606 
	gchains
[
noChains
].
	gpixels
 = &
pixels
[
len
];

608 
	gpixels
[
len
].
	gy
 = 
r
;

609 
	gpixels
[
len
].
	gx
 = 
c
;

610 
	glen
++;

611 
	gchainLen
++;

613 if (
	gdir
 == 
LEFT
)

615 while (
dirImg
[
r
 * 
width
 + 
c
] == 
EDGE_HORIZONTAL
)

617 
edgeImg
[
r
 * 
width
 + 
c
] = 
EDGE_PIXEL
;

626 if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
] == 
ANCHOR_PIXEL
)

627 
edgeImg
[(
r
 - 1) * 
width
 + 
c
] = 0;

628 if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
] == 
ANCHOR_PIXEL
)

629 
edgeImg
[(
r
 + 1) * 
width
 + 
c
] = 0;

632 if (
	gedgeImg
[
r
 * 
width
 + 
c
 - 1] >= 
ANCHOR_PIXEL
)

634 
c
--;

636 else if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
 - 1] >= 
ANCHOR_PIXEL
)

638 
r
--;

639 
	gc
--;

641 else if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
 - 1] >= 
ANCHOR_PIXEL
)

643 
r
++;

644 
	gc
--;

649 int 
	gA
 = 
gradImg
[(
r
 - 1) * 
width
 + 
c
 - 1];

650 int 
	gB
 = 
gradImg
[
r
 * 
width
 + 
c
 - 1];

651 int 
	gC
 = 
gradImg
[(
r
 + 1) * 
width
 + 
c
 - 1];

653 if (
	gA
 > 
	gB
)

655 if (
	gA
 > 
	gC
)

656 
	gr
--;

658 
	gr
++;

660 else if (
	gC
 > 
	gB
)

661 
	gr
++;

662 
	gc
--;

665 if (
	gedgeImg
[
r
 * 
width
 + 
c
] == 
EDGE_PIXEL
 || 
gradImg
[r * width + c] < 
gradThresh
)

667 if (
chainLen
 > 0)

669 
chains
[
noChains
].
len
 = 
chainLen
;

670 
	gchains
[
parent
].
	gchildren
[0] = 
noChains
;

671 
	gnoChains
++;

673 goto 
	gStartOfWhile
;

676 
	gpixels
[
len
].
	gy
 = 
r
;

677 
	gpixels
[
len
].
	gx
 = 
c
;

678 
	glen
++;

679 
	gchainLen
++;

682 
	gstack
[++
top
].
	gr
 = 
r
;

683 
	gstack
[
top
].
	gc
 = 
c
;

684 
	gstack
[
top
].
	gdir
 = 
DOWN
;

685 
	gstack
[
top
].
	gparent
 = 
noChains
;

687 
	gstack
[++
top
].
	gr
 = 
r
;

688 
	gstack
[
top
].
	gc
 = 
c
;

689 
	gstack
[
top
].
	gdir
 = 
UP
;

690 
	gstack
[
top
].
	gparent
 = 
noChains
;

692 
	glen
--;

693 
	gchainLen
--;

695 
	gchains
[
noChains
].
	glen
 = 
chainLen
;

696 
	gchains
[
parent
].
	gchildren
[0] = 
noChains
;

697 
	gnoChains
++;

699 else if (
	gdir
 == 
RIGHT
)

701 while (
dirImg
[
r
 * 
width
 + 
c
] == 
EDGE_HORIZONTAL
)

703 
edgeImg
[
r
 * 
width
 + 
c
] = 
EDGE_PIXEL
;

712 if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
] == 
ANCHOR_PIXEL
)

713 
edgeImg
[(
r
 + 1) * 
width
 + 
c
] = 0;

714 if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
] == 
ANCHOR_PIXEL
)

715 
edgeImg
[(
r
 - 1) * 
width
 + 
c
] = 0;

718 if (
	gedgeImg
[
r
 * 
width
 + 
c
 + 1] >= 
ANCHOR_PIXEL
)

720 
c
++;

722 else if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
 + 1] >= 
ANCHOR_PIXEL
)

724 
r
++;

725 
	gc
++;

727 else if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
 + 1] >= 
ANCHOR_PIXEL
)

729 
r
--;

730 
	gc
++;

735 int 
	gA
 = 
gradImg
[(
r
 - 1) * 
width
 + 
c
 + 1];

736 int 
	gB
 = 
gradImg
[
r
 * 
width
 + 
c
 + 1];

737 int 
	gC
 = 
gradImg
[(
r
 + 1) * 
width
 + 
c
 + 1];

739 if (
	gA
 > 
	gB
)

741 if (
	gA
 > 
	gC
)

742 
	gr
--;

744 
	gr
++;

746 else if (
	gC
 > 
	gB
)

747 
	gr
++;

748 
	gc
++;

751 if (
	gedgeImg
[
r
 * 
width
 + 
c
] == 
EDGE_PIXEL
 || 
gradImg
[r * width + c] < 
gradThresh
)

753 if (
chainLen
 > 0)

755 
chains
[
noChains
].
len
 = 
chainLen
;

756 
	gchains
[
parent
].
	gchildren
[1] = 
noChains
;

757 
	gnoChains
++;

759 goto 
	gStartOfWhile
;

762 
	gpixels
[
len
].
	gy
 = 
r
;

763 
	gpixels
[
len
].
	gx
 = 
c
;

764 
	glen
++;

765 
	gchainLen
++;

768 
	gstack
[++
top
].
	gr
 = 
r
;

769 
	gstack
[
top
].
	gc
 = 
c
;

770 
	gstack
[
top
].
	gdir
 = 
DOWN
;

771 
	gstack
[
top
].
	gparent
 = 
noChains
;

773 
	gstack
[++
top
].
	gr
 = 
r
;

774 
	gstack
[
top
].
	gc
 = 
c
;

775 
	gstack
[
top
].
	gdir
 = 
UP
;

776 
	gstack
[
top
].
	gparent
 = 
noChains
;

778 
	glen
--;

779 
	gchainLen
--;

781 
	gchains
[
noChains
].
	glen
 = 
chainLen
;

782 
	gchains
[
parent
].
	gchildren
[1] = 
noChains
;

783 
	gnoChains
++;

786 else if (
	gdir
 == 
UP
)

788 while (
dirImg
[
r
 * 
width
 + 
c
] == 
EDGE_VERTICAL
)

790 
edgeImg
[
r
 * 
width
 + 
c
] = 
EDGE_PIXEL
;

798 if (
	gedgeImg
[
r
 * 
width
 + 
c
 - 1] == 
ANCHOR_PIXEL
)

799 
edgeImg
[
r
 * 
width
 + 
c
 - 1] = 0;

800 if (
	gedgeImg
[
r
 * 
width
 + 
c
 + 1] == 
ANCHOR_PIXEL
)

801 
edgeImg
[
r
 * 
width
 + 
c
 + 1] = 0;

804 if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
] >= 
ANCHOR_PIXEL
)

806 
r
--;

808 else if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
 - 1] >= 
ANCHOR_PIXEL
)

810 
r
--;

811 
	gc
--;

813 else if (
	gedgeImg
[(
r
 - 1) * 
width
 + 
c
 + 1] >= 
ANCHOR_PIXEL
)

815 
r
--;

816 
	gc
++;

821 int 
	gA
 = 
gradImg
[(
r
 - 1) * 
width
 + 
c
 - 1];

822 int 
	gB
 = 
gradImg
[(
r
 - 1) * 
width
 + 
c
];

823 int 
	gC
 = 
gradImg
[(
r
 - 1) * 
width
 + 
c
 + 1];

825 if (
	gA
 > 
	gB
)

827 if (
	gA
 > 
	gC
)

828 
	gc
--;

830 
	gc
++;

832 else if (
	gC
 > 
	gB
)

833 
	gc
++;

834 
	gr
--;

837 if (
	gedgeImg
[
r
 * 
width
 + 
c
] == 
EDGE_PIXEL
 || 
gradImg
[r * width + c] < 
gradThresh
)

839 if (
chainLen
 > 0)

841 
chains
[
noChains
].
len
 = 
chainLen
;

842 
	gchains
[
parent
].
	gchildren
[0] = 
noChains
;

843 
	gnoChains
++;

845 goto 
	gStartOfWhile
;

848 
	gpixels
[
len
].
	gy
 = 
r
;

849 
	gpixels
[
len
].
	gx
 = 
c
;

851 
	glen
++;

852 
	gchainLen
++;

855 
	gstack
[++
top
].
	gr
 = 
r
;

856 
	gstack
[
top
].
	gc
 = 
c
;

857 
	gstack
[
top
].
	gdir
 = 
RIGHT
;

858 
	gstack
[
top
].
	gparent
 = 
noChains
;

860 
	gstack
[++
top
].
	gr
 = 
r
;

861 
	gstack
[
top
].
	gc
 = 
c
;

862 
	gstack
[
top
].
	gdir
 = 
LEFT
;

863 
	gstack
[
top
].
	gparent
 = 
noChains
;

865 
	glen
--;

866 
	gchainLen
--;

868 
	gchains
[
noChains
].
	glen
 = 
chainLen
;

869 
	gchains
[
parent
].
	gchildren
[0] = 
noChains
;

870 
	gnoChains
++;

874 while (
	gdirImg
[
r
 * 
width
 + 
c
] == 
EDGE_VERTICAL
)

876 
edgeImg
[
r
 * 
width
 + 
c
] = 
EDGE_PIXEL
;

884 if (
	gedgeImg
[
r
 * 
width
 + 
c
 + 1] == 
ANCHOR_PIXEL
)

885 
edgeImg
[
r
 * 
width
 + 
c
 + 1] = 0;

886 if (
	gedgeImg
[
r
 * 
width
 + 
c
 - 1] == 
ANCHOR_PIXEL
)

887 
edgeImg
[
r
 * 
width
 + 
c
 - 1] = 0;

890 if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
] >= 
ANCHOR_PIXEL
)

892 
r
++;

894 else if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
 + 1] >= 
ANCHOR_PIXEL
)

896 
r
++;

897 
	gc
++;

899 else if (
	gedgeImg
[(
r
 + 1) * 
width
 + 
c
 - 1] >= 
ANCHOR_PIXEL
)

901 
r
++;

902 
	gc
--;

907 int 
	gA
 = 
gradImg
[(
r
 + 1) * 
width
 + 
c
 - 1];

908 int 
	gB
 = 
gradImg
[(
r
 + 1) * 
width
 + 
c
];

909 int 
	gC
 = 
gradImg
[(
r
 + 1) * 
width
 + 
c
 + 1];

911 if (
	gA
 > 
	gB
)

913 if (
	gA
 > 
	gC
)

914 
	gc
--;

916 
	gc
++;

918 else if (
	gC
 > 
	gB
)

919 
	gc
++;

920 
	gr
++;

923 if (
	gedgeImg
[
r
 * 
width
 + 
c
] == 
EDGE_PIXEL
 || 
gradImg
[r * width + c] < 
gradThresh
)

925 if (
chainLen
 > 0)

927 
chains
[
noChains
].
len
 = 
chainLen
;

928 
	gchains
[
parent
].
	gchildren
[1] = 
noChains
;

929 
	gnoChains
++;

931 goto 
	gStartOfWhile
;

934 
	gpixels
[
len
].
	gy
 = 
r
;

935 
	gpixels
[
len
].
	gx
 = 
c
;

937 
	glen
++;

938 
	gchainLen
++;

941 
	gstack
[++
top
].
	gr
 = 
r
;

942 
	gstack
[
top
].
	gc
 = 
c
;

943 
	gstack
[
top
].
	gdir
 = 
RIGHT
;

944 
	gstack
[
top
].
	gparent
 = 
noChains
;

946 
	gstack
[++
top
].
	gr
 = 
r
;

947 
	gstack
[
top
].
	gc
 = 
c
;

948 
	gstack
[
top
].
	gdir
 = 
LEFT
;

949 
	gstack
[
top
].
	gparent
 = 
noChains
;

951 
	glen
--;

952 
	gchainLen
--;

954 
	gchains
[
noChains
].
	glen
 = 
chainLen
;

955 
	gchains
[
parent
].
	gchildren
[1] = 
noChains
;

956 
	gnoChains
++;

960 if (
	glen
 - 
	gduplicatePixelCount
 < 
	gparams
.
	gMinPathLength
)

962 for (int 
	gk1
 = 0; k1 < 
	glen
; k1++)

964 
	gedgeImg
[
pixels
[
k1
].
y
 * 
	gwidth
 + 
	gpixels
[k1].
	gx
] = 0;

965 
	gedgeImg
[
pixels
[
k1
].
y
 * 
	gwidth
 + 
	gpixels
[k1].
	gx
] = 0;

970 int 
	gnoSegmentPixels
 = 0;

971 int 
	gtotalLen
 = 
LongestChain
(
chains
, chains[0].
children
[1]);

973 if (
	gtotalLen
 > 0)

976 int 
	gcount
 = 
RetrieveChainNos
(
chains
, chains[0].
children
[1], 
chainNos
);

979 for (int 
	gk2
 = 
count
 - 1; k2 >= 0; k2--)

981 int 
	gchainNo
 = 
chainNos
[
k2
];

985 int 
	gfr
 = 
chains
[
chainNo
].
pixels
[chains[chainNo].
len
 - 1].
y
;

986 int 
	gfc
 = 
chains
[
chainNo
].
pixels
[chains[chainNo].
len
 - 1].
x
;

988 int 
	gindex
 = 
noSegmentPixels
 - 2;

989 while (
	gindex
 >= 0)

991 int 
dr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
index
].
y
);

992 int 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
index
].
x
);

994 if (
	gdr
 <= 1 && 
dc
 <= 1)

997 
segmentPoints
[
segmentNos
].
pop_back
();

998 
	gnoSegmentPixels
--;

999 
	gindex
--;

1005 if (
	gchains
[
chainNo
].
	glen
 > 1 && 
	gnoSegmentPixels
 > 0)

1007 
	gfr
 = 
chains
[
chainNo
].
pixels
[chains[chainNo].
len
 - 2].
y
;

1008 
	gfc
 = 
chains
[
chainNo
].
pixels
[chains[chainNo].
len
 - 2].
x
;

1010 int 
	gdr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
y
);

1011 int 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
x
);

1013 if (
	gdr
 <= 1 && 
dc
 <= 1)

1014 
chains
[
chainNo
].
len
--;

1017 for (int 
	gl
 = 
chains
[
chainNo
].
len
 - 1; l >= 0; l--)

1019 
	gsegmentPoints
[
segmentNos
].
push_back
(
chains
[
chainNo
].
pixels
[
l
]);

1020 
	gnoSegmentPixels
++;

1023 
	gchains
[
chainNo
].
	glen
 = 0;

1027 
	gtotalLen
 = 
LongestChain
(
chains
, chains[0].
children
[0]);

1028 if (
	gtotalLen
 > 1)

1031 int 
	gcount
 = 
RetrieveChainNos
(
chains
, chains[0].
children
[0], 
chainNos
);

1035 int 
	glastChainNo
 = 
chainNos
[0];

1036 
	gchains
[
lastChainNo
].
	gpixels
++;

1037 
	gchains
[
lastChainNo
].
	glen
--;

1039 for (int 
	gk3
 = 0; k3 < 
	gcount
; k3++)

1041 int 
	gchainNo
 = 
chainNos
[
k3
];

1044 int 
	gfr
 = 
chains
[
chainNo
].
pixels
[0].
y
;

1045 int 
	gfc
 = 
chains
[
chainNo
].
pixels
[0].
x
;

1047 int 
	gindex
 = 
noSegmentPixels
 - 2;

1048 while (
	gindex
 >= 0)

1050 int 
dr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
index
].
y
);

1051 int 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
index
].
x
);

1053 if (
	gdr
 <= 1 && 
dc
 <= 1)

1056 
segmentPoints
[
segmentNos
].
pop_back
();

1057 
	gnoSegmentPixels
--;

1058 
	gindex
--;

1064 int 
	gstartIndex
 = 0;

1065 int 
	gchainLen
 = 
chains
[
chainNo
].
len
;

1066 if (
	gchainLen
 > 1 && 
	gnoSegmentPixels
 > 0)

1068 
	gfr
 = 
chains
[
chainNo
].
pixels
[1].
y
;

1069 
	gfc
 = 
chains
[
chainNo
].
pixels
[1].
x
;

1071 int 
	gdr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
y
);

1072 int 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
x
);

1074 if (
	gdr
 <= 1 && 
dc
 <= 1)

1076 
startIndex
 = 1;

1081 for (int 
	gl
 = 
startIndex
; l < 
	gchains
[
chainNo
].
	glen
; l++)

1083 
	gsegmentPoints
[
segmentNos
].
push_back
(
chains
[
chainNo
].
pixels
[
l
]);

1084 
	gnoSegmentPixels
++;

1087 
	gchains
[
chainNo
].
	glen
 = 0;

1092 int 
	gfr
 = 
segmentPoints
[
segmentNos
][1].
y
;

1093 int 
	gfc
 = 
segmentPoints
[
segmentNos
][1].
x
;

1095 int 
	gdr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
y
);

1096 int 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
x
);

1098 if (
	gdr
 <= 1 && 
dc
 <= 1)

1100 
segmentPoints
[
segmentNos
].
erase
(segmentPoints[segmentNos].
begin
());

1101 
	gnoSegmentPixels
--;

1104 
	gsegmentNos
++;

1105 
	gsegmentPoints
.
push_back
(
vector
<
Point
>());

1108 for (int 
	gk4
 = 2; k4 < 
	gnoChains
; k4++)

1110 if (
	gchains
[
k4
].
	glen
 < 2)

1113 
	gtotalLen
 = 
LongestChain
(
chains
, 
k4
);

1115 if (
	gtotalLen
 >= 10)

1118 int 
count
 = 
RetrieveChainNos
(
chains
, 
k4
, 
chainNos
);

1121 
	gnoSegmentPixels
 = 0;

1122 for (int 
	gk5
 = 0; k5 < 
	gcount
; k5++)

1124 int 
	gchainNo
 = 
chainNos
[
k5
];

1127 
	gfr
 = 
chains
[
chainNo
].
pixels
[0].
y
;

1128 
	gfc
 = 
chains
[
chainNo
].
pixels
[0].
x
;

1130 int 
	gindex
 = 
noSegmentPixels
 - 2;

1131 while (
	gindex
 >= 0)

1133 
dr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
index
].
y
);

1134 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
index
].
x
);

1136 if (
	gdr
 <= 1 && 
dc
 <= 1)

1139 
segmentPoints
[
segmentNos
].
pop_back
();

1140 
	gnoSegmentPixels
--;

1141 
	gindex
--;

1147 int 
	gstartIndex
 = 0;

1148 int 
	gchainLen
 = 
chains
[
chainNo
].
len
;

1149 if (
	gchainLen
 > 1 && 
	gnoSegmentPixels
 > 0)

1151 
	gfr
 = 
chains
[
chainNo
].
pixels
[1].
y
;

1152 
	gfc
 = 
chains
[
chainNo
].
pixels
[1].
x
;

1154 
	gdr
 = 
abs
(
fr
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
y
);

1155 
	gdc
 = 
abs
(
fc
 - 
segmentPoints
[
segmentNos
][
noSegmentPixels
 - 1].
x
);

1157 if (
	gdr
 <= 1 && 
dc
 <= 1)

1159 
startIndex
 = 1;

1164 for (int 
	gl
 = 
startIndex
; l < 
	gchains
[
chainNo
].
	glen
; l++)

1166 
	gsegmentPoints
[
segmentNos
].
push_back
(
chains
[
chainNo
].
pixels
[
l
]);

1167 
	gnoSegmentPixels
++;

1170 
	gchains
[
chainNo
].
	glen
 = 0;

1172 
	gsegmentPoints
.
push_back
(
vector
<
Point
>());

1173 
	gsegmentNos
++;

1181 
	gsegmentPoints
.
pop_back
();

1184 
	gdelete
[] 
	gpAnchors
;

1185 
	gdelete
[] 
	gchains
;

1186 
	gdelete
[] 
	gstack
;

1187 
	gdelete
[] 
	gchainNos
;

1188 
	gdelete
[] 
	gpixels
;

1191 int* 
	gEdgeDrawingImpl
::
sortAnchorsByGradValue1
()

1193 int 
SIZE
 = 128 * 256;

1194 int* 
	gC
 = 
new
 int[
SIZE
];

1195 
memset
(
C
, 0, sizeof(int) * 
SIZE
);

1198 for (int 
	gi
 = 1; i < 
	gheight
 - 1; i++)

1200 for (int 
	gj
 = 1; j < 
	gwidth
 - 1; j++)

1202 if (
	gedgeImg
[
i
 * 
width
 + 
j
] != 
ANCHOR_PIXEL
)

1205 int 
	ggrad
 = 
gradImg
[
i
 * 
width
 + 
j
];

1206 
	gC
[
grad
]++;

1211 for (int 
	gi
 = 1; i < 
	gSIZE
; i++)

1212 
	gC
[
i
] += 
C
[i - 1];

1214 int 
	gnoAnchors
 = 
C
[
SIZE
 - 1];

1215 int* 
	gA
 = 
new
 int[
noAnchors
];

1217 for (int 
	gi
 = 1; i < 
	gheight
 - 1; i++)

1219 for (int 
	gj
 = 1; j < 
	gwidth
 - 1; j++)

1221 if (
	gedgeImg
[
i
 * 
width
 + 
j
] != 
ANCHOR_PIXEL
)

1224 int 
	ggrad
 = 
gradImg
[
i
 * 
width
 + 
j
];

1225 int 
	gindex
 = --
C
[
grad
];

1226 
	gA
[
index
] = 
i
 * 
width
 + 
j
;

1230 
	gdelete
[] 
	gC
;

1231 return 
	gA
;

1234 int 
	gEdgeDrawingImpl
::
LongestChain
(
Chain
* 
chains
, int 
root
)

1236 if (
	groot
 == -1 || 
chains
[
root
].
len
 == 0)

1239 int 
	glen0
 = 0;

1240 if (
	gchains
[
root
].
	gchildren
[0] != -1)

1241 
len0
 = 
LongestChain
(
chains
, chains[
root
].
children
[0]);

1243 int 
	glen1
 = 0;

1244 if (
	gchains
[
root
].
	gchildren
[1] != -1)

1245 
len1
 = 
LongestChain
(
chains
, chains[
root
].
children
[1]);

1247 int 
	gmax
 = 0;

1249 if (
	glen0
 >= 
len1
)

1251 
max
 = 
len0
;

1252 
	gchains
[
root
].
	gchildren
[1] = -1;

1256 
	gmax
 = 
len1
;

1257 
	gchains
[
root
].
	gchildren
[0] = -1;

1260 return 
	gchains
[
root
].
	glen
 + 
	gmax
;

1263 int 
	gEdgeDrawingImpl
::
RetrieveChainNos
(
Chain
* 
chains
, int 
root
, int 
chainNos
[])

1265 int 
	gcount
 = 0;

1267 while (
	groot
 != -1)

1269 
chainNos
[
count
] = 
root
;

1270 
	gcount
++;

1272 if (
	gchains
[
root
].
	gchildren
[0] != -1)

1273 
root
 = 
chains
[root].
children
[0];

1275 
	groot
 = 
chains
[
root
].
children
[1];

1278 return 
	gcount
;

1281 void 
	gEdgeDrawingImpl
::
detectLines
(
OutputArray
 
_lines
)

1283 
std
::
vector
<
Vec4f
> 
linePoints
;

1284 if (
	gsegmentPoints
.
size
() < 1)

1286 
Mat
(
linePoints
).
copyTo
(
_lines
);

1290 
	gmin_line_len
 = 
params
.
MinLineLength
;

1291 
	gline_error
 = 
params
.
LineFitErrorThreshold
;

1292 
	gmax_distance_between_two_lines
 = 
params
.
MaxDistanceBetweenTwoLines
;

1293 
	gmax_error
 = 
params
.
MaxErrorThreshold
;

1295 if (
	gmin_line_len
 == -1)

1296 
min_line_len
 = 
ComputeMinLineLength
();

1298 if (
	gmin_line_len
 < 9)

1299 
	gmin_line_len
 = 9;

1302 double* 
	gx
 = 
new
 double[(
width
 + 
height
) * 8];

1303 double* 
	gy
 = 
new
 double[(
width
 + 
height
) * 8];

1305 
	glines
.
clear
();

1306 
	glinesNo
 = 0;

1309 for (
size_t
 
	gsegmentNumber
 = 0; segmentNumber < 
	gsegmentPoints
.
size
(); segmentNumber++)

1311 
	gstd
::
vector
<
Point
> 
segment
 = 
segmentPoints
[
segmentNumber
];

1312 for (int 
	gk
 = 0; k < (int)
	gsegment
.
size
(); k++)

1314 
	gx
[
k
] = 
segment
[k].
x
;

1315 
	gy
[
k
] = 
segment
[k].
y
;

1317 
SplitSegment2Lines
(
x
, 
y
, (int)
segment
.
size
(), (int)
segmentNumber
);

1320 
JoinCollinearLines
();

1322 if (
	gparams
.
	gNFAValidation
)

1323 
ValidateLineSegments
();

1327 int 
	gsize
 = (int)
lines
.
size
();

1328 for (int 
	gi
 = 1; i <= 
size
 - 
linesNo
; i++)

1329 
	glines
.
pop_back
();

1331 
	gsegmentIndicesOfLines
.
clear
();

1332 for (int 
	gi
 = 0; i < 
	glinesNo
; i++)

1334 
Vec4f
 
line
((float)
lines
[
i
].
sx
, (float)lines[i].
sy
, (float)lines[i].
ex
, (float)lines[i].
ey
);

1335 
	glinePoints
.
push_back
(
line
);

1336 
	gsegmentIndicesOfLines
.
push_back
(
lines
[
i
].
segmentNo
);

1338 
Mat
(
linePoints
).
copyTo
(
_lines
);

1340 
	gdelete
[] 
	gx
;

1341 
	gdelete
[] 
	gy
;

1345 int 
	gEdgeDrawingImpl
::
ComputeMinLineLength
()

1353 double 
logNT
 = 2.0 * (
log10
((double)
width
) + log10((double)
height
));

1354 return (int)
round
((-
logNT
 / 
log10
(0.125)) * 0.5);

1361 void 
	gEdgeDrawingImpl
::
SplitSegment2Lines
(double* 
x
, double* 
y
, int 
noPixels
, int 
segmentNo
)

1364 int 
	gfirstPixelIndex
 = 0;

1366 while (
	gnoPixels
 >= 
min_line_len
)

1369 
bool
 
valid
 = 
false
;

1370 double 
lastA
(0), 
lastB
(0), 
error
(0);

1371 int 
lastInvert
(0);

1373 while (
	gnoPixels
 >= 
min_line_len
)

1375 
LineFit
(
x
, 
y
, 
min_line_len
, 
lastA
, 
lastB
, 
error
, 
lastInvert
);

1376 if (
	gerror
 <= 0.5)

1378 
valid
 = 
true
;

1382 
	gnoPixels
 -= 1;

1383 
	gx
 += 1;

1384 
	gy
 += 1;

1385 
	gfirstPixelIndex
 += 1;

1388 if (
	gvalid
 == 
false
)

1392 int 
	gindex
 = 
min_line_len
;

1393 int 
	glen
 = 
min_line_len
;

1395 while (
	gindex
 < 
	gnoPixels
)

1397 int 
	gstartIndex
 = 
index
;

1398 int 
	glastGoodIndex
 = 
index
 - 1;

1399 int 
	ggoodPixelCount
 = 0;

1400 int 
	gbadPixelCount
 = 0;

1402 while (
	gindex
 < 
	gnoPixels
)

1404 double 
	gd
 = 
ComputeMinDistance
(
x
[
index
], 
y
[index], 
lastA
, 
lastB
, 
lastInvert
);

1406 if (
	gd
 <= 
line_error
)

1408 
lastGoodIndex
 = 
index
;

1409 
	ggoodPixelCount
++;

1410 
	gbadPixelCount
 = 0;

1414 
	gbadPixelCount
++;

1415 if (
	gbadPixelCount
 >= 5)

1418 
	gindex
++;

1421 if (
	ggoodPixelCount
 >= 2)

1423 
len
 += 
lastGoodIndex
 - 
startIndex
 + 1;

1424 
LineFit
(
x
, 
y
, 
len
, 
lastA
, 
lastB
, 
lastInvert
);

1425 
	gindex
 = 
lastGoodIndex
 + 1;

1428 if (
	ggoodPixelCount
 < 2 || 
	gindex
 >= 
noPixels
)

1431 double 
sx
, 
sy
, 
ex
, 
ey
;

1433 
	gindex
 = 0;

1434 while (
ComputeMinDistance
(
x
[
index
], 
y
[index], 
lastA
, 
lastB
, 
lastInvert
) > 
	gline_error
)

1435 
	gindex
++;

1436 
ComputeClosestPoint
(
x
[
index
], 
y
[index], 
lastA
, 
lastB
, 
lastInvert
, 
sx
, 
sy
);

1437 int 
	gnoSkippedPixels
 = 
index
;

1439 
	gindex
 = 
lastGoodIndex
;

1440 while (
ComputeMinDistance
(
x
[
index
], 
y
[index], 
lastA
, 
lastB
, 
lastInvert
) > 
	gline_error
)

1441 
	gindex
--;

1442 
ComputeClosestPoint
(
x
[
index
], 
y
[index], 
lastA
, 
lastB
, 
lastInvert
, 
ex
, 
ey
);

1444 if ((
	gsx
 == 
ex
) & (
sy
 == 
ey
))

1448 
	glines
.
push_back
(
EDLineSegment
(
lastA
, 
lastB
, 
lastInvert
, 
sx
, 
sy
, 
ex
, 
ey
, 
segmentNo
, 
firstPixelIndex
 + 
noSkippedPixels
, 
index
 - noSkippedPixels + 1));

1449 
	glinesNo
++;

1450 
	glen
 = 
index
 + 1;

1456 
	gnoPixels
 -= 
len
;

1457 
	gx
 += 
len
;

1458 
	gy
 += 
len
;

1459 
	gfirstPixelIndex
 += 
len
;

1466 void 
	gEdgeDrawingImpl
::
JoinCollinearLines
()

1468 int 
lastLineIndex
 = -1;

1469 int 
	gi
 = 0;

1470 while (
	gi
 < 
	glinesNo
)

1472 int 
	gsegmentNo
 = 
lines
[
i
].
segmentNo
;

1474 
	glastLineIndex
++;

1475 if (
	glastLineIndex
 != 
i
)

1476 
lines
[
lastLineIndex
] = lines[
i
];

1478 int 
	gfirstLineIndex
 = 
lastLineIndex
;

1480 int 
	gcount
 = 1;

1481 for (int 
	gj
 = 
i
 + 1; j < 
	glinesNo
; j++)

1483 if (
	glines
[
j
].
	gsegmentNo
 != 
segmentNo
)

1487 if (
TryToJoinTwoLineSegments
(&
lines
[
lastLineIndex
], &lines[
j
],

1488 
lastLineIndex
) == 
false
)

1490 
lastLineIndex
++;

1491 if (
	glastLineIndex
 != 
j
)

1492 
lines
[
lastLineIndex
] = lines[
j
];

1494 
	gcount
++;

1498 if (
	gfirstLineIndex
 != 
lastLineIndex
)

1500 if (
TryToJoinTwoLineSegments
(&
lines
[
firstLineIndex
], &lines[
lastLineIndex
],

1501 
firstLineIndex
))

1503 
lastLineIndex
--;

1506 
	gi
 += 
count
;

1508 
	glinesNo
 = 
lastLineIndex
 + 1;

1511 void 
	gEdgeDrawingImpl
::
ValidateLineSegments
()

1513 #define 
	#PRECISION_ANGLE
 22.5

	)

1514 
precision
 = (
PRECISION_ANGLE
 / 180) * 
CV_PI
;

1515 #undef 
PRECISION_ANGLE


1517 if (
	gnfa
->
	gLUTSize
 == 1)

1519 int 
lutSize
 = (
width
 + 
height
) / 8;

1520 double 
	gprob
 = 1.0 / 8;

1521 
	gnfa
 = 
new
 
NFALUT
(
lutSize
, 
prob
, 
width
, 
height
);

1524 int* 
	gx
 = 
new
 int[(
width
 + 
height
) * 4];

1525 int* 
	gy
 = 
new
 int[(
width
 + 
height
) * 4];

1527 int 
	gnoValidLines
 = 0;

1529 for (int 
	gi
 = 0; i < 
	glinesNo
; i++)

1531 
EDLineSegment
* 
	gls
 = &
lines
[
i
];

1534 double 
	glineAngle
;

1536 if (
	gls
->
	ginvert
 == 0)

1539 
lineAngle
 = 
atan
(
ls
->
b
);

1544 
	glineAngle
 = 
atan
(1.0 / 
ls
->
b
);

1547 if (
	glineAngle
 < 0)

1548 
	glineAngle
 += 
CV_PI
;

1550 
Point
* 
	gpixels
 = &(
segmentPoints
[
ls
->
segmentNo
][0]);

1551 int 
	gnoPixels
 = 
ls
->
len
;

1553 
bool
 
	gvalid
 = 
false
;

1556 if (
	gls
->
	glen
 >= 80)

1558 
valid
 = 
true
;

1561 else if (
	gls
->
	glen
 <= 25)

1563 
valid
 = 
ValidateLineSegmentRect
(
x
, 
y
, 
ls
);

1570 int 
	galigned
 = 0;

1571 int 
	gcount
 = 0;

1572 for (int 
	gj
 = 0; j < 
	gnoPixels
; j++)

1574 int 
	gr
 = 
pixels
[
j
].
x
;

1575 int 
	gc
 = 
pixels
[
j
].
y
;

1577 if (
	gr
 <= 0 || 
r
 >= 
height
 - 1 || 
c
 <= 0 || c >= 
width
 - 1)

1580 
	gcount
++;

1597 int 
	gcom1
 = 
srcImg
[(
r
 + 1) * 
width
 + 
c
 + 1] - srcImg[(r - 1) * width + c - 1];

1598 int 
	gcom2
 = 
srcImg
[(
r
 - 1) * 
width
 + 
c
 + 1] - srcImg[(r + 1) * width + c - 1];

1600 int 
	ggx
 = 
com1
 + 
com2
 + 
srcImg
[
r
 * 
width
 + 
c
 + 1] - srcImg[r * width + c - 1];

1601 int 
	ggy
 = 
com1
 - 
com2
 + 
srcImg
[(
r
 + 1) * 
width
 + 
c
] - srcImg[(r - 1) * width + c];

1603 double 
	gpixelAngle
 = 
nfa
->
myAtan2
((double)
gx
, (double)-
gy
);

1604 double 
	gdiff
 = 
fabs
(
lineAngle
 - 
pixelAngle
);

1606 if (
	gdiff
 <= 
precision
 || 
diff
 >= 
CV_PI
 - precision)

1607 
aligned
++;

1611 
	gvalid
 = 
nfa
->
checkValidationByNFA
(
count
, 
aligned
) || 
ValidateLineSegmentRect
(
x
, 
y
, 
ls
);

1614 if (
	gvalid
)

1616 if (
	gi
 != 
noValidLines
)

1617 
lines
[
noValidLines
] = lines[
i
];

1618 
	gnoValidLines
++;

1622 
	glinesNo
 = 
noValidLines
;

1624 
	gdelete
[] 
	gx
;

1625 
	gdelete
[] 
	gy
;

1628 
bool
 
	gEdgeDrawingImpl
::
ValidateLineSegmentRect
(int* 
x
, int* 
y
, 
EDLineSegment
* 
ls
)

1631 double 
	glineAngle
;

1633 if (
	gls
->
	ginvert
 == 0)

1636 
lineAngle
 = 
atan
(
ls
->
b
);

1641 
	glineAngle
 = 
atan
(1.0 / 
ls
->
b
);

1644 if (
	glineAngle
 < 0)

1645 
	glineAngle
 += 
CV_PI
;

1647 int 
	gnoPoints
 = 0;

1650 
EnumerateRectPoints
(
ls
->
sx
, ls->
sy
, ls->
ex
, ls->
ey
, 
x
, 
y
, &
noPoints
);

1652 int 
	gcount
 = 0;

1653 int 
	galigned
 = 0;

1655 for (int 
	gi
 = 0; i < 
	gnoPoints
; i++)

1657 int 
	gr
 = 
y
[
i
];

1658 int 
	gc
 = 
x
[
i
];

1660 if (
	gr
 <= 0 || 
r
 >= 
height
 - 1 || 
c
 <= 0 || c >= 
width
 - 1)

1663 
	gcount
++;

1680 int 
	gcom1
 = 
srcImg
[(
r
 + 1) * 
width
 + 
c
 + 1] - srcImg[(r - 1) * width + c - 1];

1681 int 
	gcom2
 = 
srcImg
[(
r
 - 1) * 
width
 + 
c
 + 1] - srcImg[(r + 1) * width + c - 1];

1683 int 
	ggx
 = 
com1
 + 
com2
 + 
srcImg
[
r
 * 
width
 + 
c
 + 1] - srcImg[r * width + c - 1];

1684 int 
	ggy
 = 
com1
 - 
com2
 + 
srcImg
[(
r
 + 1) * 
width
 + 
c
] - srcImg[(r - 1) * width + c];

1685 double 
	gpixelAngle
 = 
nfa
->
myAtan2
((double)
gx
, (double)-
gy
);

1687 double 
	gdiff
 = 
fabs
(
lineAngle
 - 
pixelAngle
);

1689 if (
	gdiff
 <= 
precision
 || 
diff
 >= 
CV_PI
 - precision)

1690 
aligned
++;

1692 return 
	gnfa
->
checkValidationByNFA
(
count
, 
aligned
);

1695 double 
	gEdgeDrawingImpl
::
ComputeMinDistance
(double 
x1
, double 
y1
, double 
a
, double 
b
, int 
invert
)

1697 double 
	gx2
, 
	gy2
;

1699 if (
	ginvert
 == 0)

1701 if (
b
 == 0)

1703 
x2
 = 
x1
;

1704 
	gy2
 = 
a
;

1709 double 
	gd
 = -1.0 / (
b
);

1710 double 
	gc
 = 
y1
 - 
d
 * 
x1
;

1712 
	gx2
 = (
a
 - 
c
) / (
d
 - 
b
);

1713 
	gy2
 = 
a
 + 
b
 * 
x2
;

1719 if (
	gb
 == 0)

1721 
x2
 = 
a
;

1722 
	gy2
 = 
y1
;

1727 double 
	gd
 = -1.0 / (
b
);

1728 double 
	gc
 = 
x1
 - 
d
 * 
y1
;

1730 
	gy2
 = (
a
 - 
c
) / (
d
 - 
b
);

1731 
	gx2
 = 
a
 + 
b
 * 
y2
;

1735 return 
sqrt
((
x1
 - 
x2
) * (x1 - x2) + (
y1
 - 
y2
) * (y1 - y2));

1742 void 
	gEdgeDrawingImpl
::
ComputeClosestPoint
(double 
x1
, double 
y1
, double 
a
, double 
b
, int 
invert
, double& 
xOut
, double& 
yOut
)

1744 double 
	gx2
, 
	gy2
;

1746 if (
	ginvert
 == 0)

1748 if (
b
 == 0)

1750 
x2
 = 
x1
;

1751 
	gy2
 = 
a
;

1756 double 
	gd
 = -1.0 / (
b
);

1757 double 
	gc
 = 
y1
 - 
d
 * 
x1
;

1759 
	gx2
 = (
a
 - 
c
) / (
d
 - 
b
);

1760 
	gy2
 = 
a
 + 
b
 * 
x2
;

1766 if (
	gb
 == 0)

1768 
x2
 = 
a
;

1769 
	gy2
 = 
y1
;

1774 double 
	gd
 = -1.0 / (
b
);

1775 double 
	gc
 = 
x1
 - 
d
 * 
y1
;

1777 
	gy2
 = (
a
 - 
c
) / (
d
 - 
b
);

1778 
	gx2
 = 
a
 + 
b
 * 
y2
;

1782 
	gxOut
 = 
x2
;

1783 
	gyOut
 = 
y2
;

1790 void 
	gEdgeDrawingImpl
::
LineFit
(double* 
x
, double* 
y
, int 
count
, double& 
a
, double& 
b
, int 
invert
)

1792 if (
	gcount
 < 2)

1795 double 
	gS
 = 
count
, 
	gSx
 = 0.0, 
	gSy
 = 0.0, 
	gSxx
 = 0.0, 
	gSxy
 = 0.0;

1796 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1798 
	gSx
 += 
x
[
i
];

1799 
	gSy
 += 
y
[
i
];

1802 if (
	ginvert
)

1805 double* 
	gt
 = 
x
;

1806 
	gx
 = 
y
;

1807 
	gy
 = 
t
;

1809 double 
	gd
 = 
Sx
;

1810 
	gSx
 = 
Sy
;

1811 
	gSy
 = 
d
;

1815 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1817 
	gSxx
 += 
x
[
i
] * x[i];

1818 
	gSxy
 += 
x
[
i
] * 
y
[i];

1821 double 
	gD
 = 
S
 * 
Sxx
 - 
Sx
 * Sx;

1822 
	ga
 = (
Sxx
 * 
Sy
 - 
Sx
 * 
Sxy
) / 
D
;

1823 
	gb
 = (
S
 * 
Sxy
 - 
Sx
 * 
Sy
) / 
D
;

1829 void 
	gEdgeDrawingImpl
::
LineFit
(double* 
x
, double* 
y
, int 
count
, double& 
a
, double& 
b
, double& 
e
, int& 
invert
)

1831 if (
	gcount
 < 2)

1834 double 
	gS
 = 
count
, 
	gSx
 = 0.0, 
	gSy
 = 0.0, 
	gSxx
 = 0.0, 
	gSxy
 = 0.0;

1835 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1837 
	gSx
 += 
x
[
i
];

1838 
	gSy
 += 
y
[
i
];

1841 double 
	gmx
 = 
Sx
 / 
count
;

1842 double 
	gmy
 = 
Sy
 / 
count
;

1844 double 
	gdx
 = 0.0;

1845 double 
	gdy
 = 0.0;

1847 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1849 
	gdx
 += (
x
[
i
] - 
mx
) * (x[i] - mx);

1850 
	gdy
 += (
y
[
i
] - 
my
) * (y[i] - my);

1853 if (
	gdx
 < 
	gdy
)

1856 
	ginvert
 = 1;

1857 double* 
	gt
 = 
x
;

1858 
	gx
 = 
y
;

1859 
	gy
 = 
t
;

1861 double 
	gd
 = 
Sx
;

1862 
	gSx
 = 
Sy
;

1863 
	gSy
 = 
d
;

1867 
	ginvert
 = 0;

1871 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1873 
	gSxx
 += 
x
[
i
] * x[i];

1874 
	gSxy
 += 
x
[
i
] * 
y
[i];

1877 double 
	gD
 = 
S
 * 
Sxx
 - 
Sx
 * Sx;

1878 
	ga
 = (
Sxx
 * 
Sy
 - 
Sx
 * 
Sxy
) / 
D
;

1879 
	gb
 = (
S
 * 
Sxy
 - 
Sx
 * 
Sy
) / 
D
;

1881 if (
	gb
 == 0.0)

1884 double 
error
 = 0.0;

1885 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1887 
	gerror
 += 
fabs
((
a
)-
y
[
i
]);

1889 
	ge
 = 
error
 / 
count
;

1893 double 
	gerror
 = 0.0;

1894 for (int 
	gi
 = 0; i < 
	gcount
; i++)

1897 double 
	gd
 = -1.0 / (
b
);

1898 double 
	gc
 = 
y
[
i
] - 
d
 * 
x
[i];

1899 double 
	gx2
 = ((
a
)-
c
) / (
d
 - (
b
));

1900 double 
	gy2
 = (
a
)+(
b
)*
x2
;

1902 double 
	gdist
 = (
x
[
i
] - 
x2
) * (x[i] - x2) + (
y
[i] - 
y2
) * (y[i] - y2);

1903 
	gerror
 += 
dist
;

1905 
	ge
 = 
sqrt
(
error
 / 
count
);

1914 
bool
 
	gEdgeDrawingImpl
::
TryToJoinTwoLineSegments
(
EDLineSegment
* 
ls1
, EDLineSegment* 
ls2
, int 
changeIndex
)

1916 int 
	gwhich
;

1917 double 
	gdist
 = 
ComputeMinDistanceBetweenTwoLines
(
ls1
, 
ls2
, &
which
);

1918 if (
	gdist
 > 
	gmax_distance_between_two_lines
)

1919 return 
	gfalse
;

1922 double 
	gdx
 = 
ls1
->
sx
 - ls1->
ex
;

1923 double 
	gdy
 = 
ls1
->
sy
 - ls1->
ey
;

1924 double 
	gprevLen
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

1926 
	gdx
 = 
ls2
->
sx
 - ls2->
ex
;

1927 
	gdy
 = 
ls2
->
sy
 - ls2->
ey
;

1928 double 
	gnextLen
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

1931 
EDLineSegment
* 
	gshorter
 = 
ls1
;

1932 
EDLineSegment
* 
	glonger
 = 
ls2
;

1934 if (
	gprevLen
 > 
	gnextLen
)

1936 
	gshorter
 = 
ls2
;

1937 
	glonger
 = 
ls1
;

1941 
	gdist
 = 
ComputeMinDistance
(
shorter
->
sx
, shorter->
sy
, 
longer
->
a
, longer->
b
, longer->
invert
);

1942 
	gdist
 += 
ComputeMinDistance
((
shorter
->
sx
 + shorter->
ex
) / 2.0, (shorter->
sy
 + shorter->
ey
) / 2.0, 
longer
->
a
, longer->
b
, longer->
invert
);

1943 
	gdist
 += 
ComputeMinDistance
(
shorter
->
ex
, shorter->
ey
, 
longer
->
a
, longer->
b
, longer->
invert
);

1945 
	gdist
 /= 3.0;

1947 if (
	gdist
 > 
	gmax_error
)

1948 return 
	gfalse
;

1953 
	gdx
 = 
fabs
(
ls1
->
sx
 - 
ls2
->sx);

1954 
	gdy
 = 
fabs
(
ls1
->
sy
 - 
ls2
->sy);

1955 double 
	gd
 = 
dx
 + 
dy
;

1956 double 
	gmax
 = 
d
;

1957 
	gwhich
 = 1;

1960 
	gdx
 = 
fabs
(
ls1
->
sx
 - 
ls2
->
ex
);

1961 
	gdy
 = 
fabs
(
ls1
->
sy
 - 
ls2
->
ey
);

1962 
	gd
 = 
dx
 + 
dy
;

1963 if (
	gd
 > 
	gmax
)

1965 
	gmax
 = 
d
;

1966 
	gwhich
 = 2;

1970 
	gdx
 = 
fabs
(
ls1
->
ex
 - 
ls2
->
sx
);

1971 
	gdy
 = 
fabs
(
ls1
->
ey
 - 
ls2
->
sy
);

1972 
	gd
 = 
dx
 + 
dy
;

1973 if (
	gd
 > 
	gmax
)

1975 
	gmax
 = 
d
;

1976 
	gwhich
 = 3;

1980 
	gdx
 = 
fabs
(
ls1
->
ex
 - 
ls2
->ex);

1981 
	gdy
 = 
fabs
(
ls1
->
ey
 - 
ls2
->ey);

1982 
	gd
 = 
dx
 + 
dy
;

1983 if (
	gd
 > 
	gmax
)

1985 
	gmax
 = 
d
;

1986 
	gwhich
 = 4;

1989 if (
	gwhich
 == 1)

1992 
ls1
->
ex
 = 
ls2
->
sx
;

1993 
	gls1
->
	gey
 = 
ls2
->
sy
;

1995 else if (
	gwhich
 == 2)

1998 
ls1
->
ex
 = 
ls2
->ex;

1999 
	gls1
->
	gey
 = 
ls2
->
ey
;

2001 else if (
	gwhich
 == 3)

2004 
ls1
->
sx
 = 
ls2
->sx;

2005 
	gls1
->
	gsy
 = 
ls2
->
sy
;

2010 
	gls1
->
	gsx
 = 
ls1
->
ex
;

2011 
	gls1
->
	gsy
 = 
ls1
->
ey
;

2013 
	gls1
->
	gex
 = 
ls2
->
ex
;

2014 
	gls1
->
	gey
 = 
ls2
->
ey
;

2018 if (
	gls1
->
	gfirstPixelIndex
 + ls1->
	glen
 + 5 >= 
ls2
->
firstPixelIndex
)

2019 
ls1
->
len
 += 
ls2
->len;

2020 else if (
	gls2
->
	glen
 > 
	gls1
->len)

2022 
	gls1
->
	gfirstPixelIndex
 = 
ls2
->
firstPixelIndex
;

2023 
	gls1
->
	glen
 = 
ls2
->
len
;

2026 
UpdateLineParameters
(
ls1
);

2027 
	glines
[
changeIndex
] = *
ls1
;

2029 return 
	gtrue
;

2035 double 
	gEdgeDrawingImpl
::
ComputeMinDistanceBetweenTwoLines
(
EDLineSegment
* 
ls1
, EDLineSegment* 
ls2
, int* 
pwhich
)

2037 double 
	gdx
 = 
ls1
->
sx
 - 
ls2
->sx;

2038 double 
	gdy
 = 
ls1
->
sy
 - 
ls2
->sy;

2039 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2040 double 
	gmin
 = 
d
;

2041 int 
	gwhich
 = 
SOUTH_SOUTH
;

2043 
	gdx
 = 
ls1
->
sx
 - 
ls2
->
ex
;

2044 
	gdy
 = 
ls1
->
sy
 - 
ls2
->
ey
;

2045 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2046 if (
	gd
 < 
	gmin
)

2048 
	gmin
 = 
d
;

2049 
	gwhich
 = 
SOUTH_EAST
;

2052 
	gdx
 = 
ls1
->
ex
 - 
ls2
->
sx
;

2053 
	gdy
 = 
ls1
->
ey
 - 
ls2
->
sy
;

2054 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2055 if (
	gd
 < 
	gmin
)

2057 
	gmin
 = 
d
;

2058 
	gwhich
 = 
EAST_SOUTH
;

2061 
	gdx
 = 
ls1
->
ex
 - 
ls2
->ex;

2062 
	gdy
 = 
ls1
->
ey
 - 
ls2
->ey;

2063 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2064 if (
	gd
 < 
	gmin
)

2066 
	gmin
 = 
d
;

2067 
	gwhich
 = 
EAST_EAST
;

2070 if (
	gpwhich
)

2071 *
	gpwhich
 = 
which
;

2072 return 
	gmin
;

2079 void 
	gEdgeDrawingImpl
::
UpdateLineParameters
(
EDLineSegment
* 
ls
)

2081 double 
dx
 = 
ls
->
ex
 - ls->
sx
;

2082 double 
	gdy
 = 
ls
->
ey
 - ls->
sy
;

2084 if (
fabs
(
dx
) >= fabs(
dy
))

2087 
ls
->
invert
 = 0;

2088 if (
fabs
(
dy
) < 1e-3)

2090 
	gls
->
	gb
 = 0;

2091 
	gls
->
	ga
 = (
ls
->
sy
 + ls->
ey
) / 2;

2095 
	gls
->
	gb
 = 
dy
 / 
dx
;

2096 
	gls
->
	ga
 = 
ls
->
sy
 - (ls->
b
) * ls->
sx
;

2102 
	gls
->
	ginvert
 = 1;

2103 if (
fabs
(
dx
) < 1e-3)

2105 
	gls
->
	gb
 = 0;

2106 
	gls
->
	ga
 = (
ls
->
sx
 + ls->
ex
) / 2;

2110 
	gls
->
	gb
 = 
dx
 / 
dy
;

2111 
	gls
->
	ga
 = 
ls
->
sx
 - (ls->
b
) * ls->
sy
;

2116 void 
	gEdgeDrawingImpl
::
EnumerateRectPoints
(double 
sx
, double 
sy
, double 
ex
, double 
ey
, int 
ptsx
[], int 
ptsy
[], int* 
pNoPoints
)

2118 double 
	gvxTmp
[4], 
	gvyTmp
[4];

2119 double 
	gvx
[4], 
	gvy
[4];

2120 int 
	gn
, 
	goffset
;

2122 double 
	gx1
 = 
sx
;

2123 double 
	gy1
 = 
sy
;

2124 double 
	gx2
 = 
ex
;

2125 double 
	gy2
 = 
ey
;

2126 double 
	gwidth
 = 2;

2128 double 
	gdx
 = 
x2
 - 
x1
;

2129 double 
	gdy
 = 
y2
 - 
y1
;

2130 double 
	gvLen
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2133 
	gdx
 = 
dx
 / 
vLen
;

2134 
	gdy
 = 
dy
 / 
vLen
;

2138 
	gvxTmp
[0] = 
x1
 - 
dy
 * 
width
 / 2.0;

2139 
	gvyTmp
[0] = 
y1
 + 
dx
 * 
width
 / 2.0;

2140 
	gvxTmp
[1] = 
x2
 - 
dy
 * 
width
 / 2.0;

2141 
	gvyTmp
[1] = 
y2
 + 
dx
 * 
width
 / 2.0;

2142 
	gvxTmp
[2] = 
x2
 + 
dy
 * 
width
 / 2.0;

2143 
	gvyTmp
[2] = 
y2
 - 
dx
 * 
width
 / 2.0;

2144 
	gvxTmp
[3] = 
x1
 + 
dy
 * 
width
 / 2.0;

2145 
	gvyTmp
[3] = 
y1
 - 
dx
 * 
width
 / 2.0;

2153 if (
	gx1
 < 
	gx2
 && 
	gy1
 <= 
y2
)

2154 
offset
 = 0;

2155 else if (
	gx1
 >= 
x2
 && 
y1
 < 
y2
)

2156 
offset
 = 1;

2157 else if (
	gx1
 > 
	gx2
&& 
	gy1
 >= 
y2
)

2158 
offset
 = 2;

2160 
	goffset
 = 3;

2163 for (
	gn
 = 0; n < 4; n++)

2165 
	gvx
[
n
] = 
vxTmp
[(
offset
 + n) % 4];

2166 
	gvy
[
n
] = 
vyTmp
[(
offset
 + n) % 4];

2185 int 
	gx
 = (int)
ceil
(
vx
[0]) - 1;

2186 int 
	gy
 = (int)
ceil
(
vy
[0]);

2187 double 
	gys
 = -
DBL_MAX
, 
	gye
 = -DBL_MAX;

2189 int 
	gnoPoints
 = 0;

2194 
	gy
++;

2199 while (
	gy
 > 
	gye
&& 
	gx
 <= 
vx
[2])

2202 
x
++;

2205 if (
	gx
 > 
	gvx
[2])

2223 if ((double)
	gx
 < 
	gvx
[3])

2226 if (
fabs
(
vx
[0] - vx[3]) <= 0.01)

2228 if (
vy
[0] < vy[3])

2229 
ys
 = 
vy
[0];

2230 else if (
	gvy
[0] > vy[3])

2231 
	gys
 = 
vy
[3];

2233 
	gys
 = 
vy
[0] + (
x
 - 
vx
[0]) * (vy[3] - vy[0]) / (vx[3] - vx[0]);

2236 
	gys
 = 
vy
[0] + (
x
 - 
vx
[0]) * (vy[3] - vy[0]) / (vx[3] - vx[0]);

2241 if (
fabs
(
vx
[3] - vx[2]) <= 0.01)

2243 if (
vy
[3] < vy[2])

2244 
ys
 = 
vy
[3];

2245 else if (
	gvy
[3] > vy[2])

2246 
	gys
 = 
vy
[2];

2248 
	gys
 = 
vy
[3] + (
x
 - 
vx
[3]) * (
y2
 - vy[3]) / (vx[2] - vx[3]);

2251 
	gys
 = 
vy
[3] + (
x
 - 
vx
[3]) * (vy[2] - vy[3]) / (vx[2] - vx[3]);

2269 if ((double)
	gx
 < 
	gvx
[1])

2272 if (
fabs
(
vx
[0] - vx[1]) <= 0.01)

2274 if (
vy
[0] < vy[1])

2275 
ye
 = 
vy
[1];

2276 else if (
	gvy
[0] > vy[1])

2277 
	gye
 = 
vy
[0];

2279 
	gye
 = 
vy
[0] + (
x
 - 
vx
[0]) * (vy[1] - vy[0]) / (vx[1] - vx[0]);

2282 
	gye
 = 
vy
[0] + (
x
 - 
vx
[0]) * (vy[1] - vy[0]) / (vx[1] - vx[0]);

2287 if (
fabs
(
vx
[1] - vx[2]) <= 0.01)

2289 if (
vy
[1] < vy[2])

2290 
ye
 = 
vy
[2];

2291 else if (
	gvy
[1] > vy[2])

2292 
	gye
 = 
vy
[1];

2294 
	gye
 = 
vy
[1] + (
x
 - 
vx
[1]) * (vy[2] - vy[1]) / (vx[2] - vx[1]);

2297 
	gye
 = 
vy
[1] + (
x
 - 
vx
[1]) * (vy[2] - vy[1]) / (vx[2] - vx[1]);

2300 
	gy
 = (int)
ceil
(
ys
);

2304 if (
	gx
 > 
	gvx
[2])

2307 
	gptsx
[
noPoints
] = 
x
;

2308 
	gptsy
[
noPoints
] = 
y
;

2309 
	gnoPoints
++;

2311 *
	gpNoPoints
 = 
noPoints
;

2320 void 
	gEdgeDrawingImpl
::
TestSegment
(int 
i
, int 
index1
, int 
index2
)

2322 int 
	gchainLen
 = 
index2
 - 
index1
 + 1;

2323 if (
	gchainLen
 < 
	gparams
.
	gMinPathLength
)

2330 int 
	gminGrad
 = 1 << 30;

2331 int 
	gminGradIndex
 = 0;

2333 for (int 
	gk
 = 
index1
; k <= 
index2
; k++) {

2334 int 
	gr
 = 
segmentPoints
[
i
][
k
].
y
;

2335 int 
	gc
 = 
segmentPoints
[
i
][
k
].
x
;

2336 if (
	ggradImg
[
r
 * 
width
 + 
c
] < 
	gminGrad
) { minGrad = 
gradImg
[r * width + c]; 
	gminGradIndex
 = 
k
; }

2339 double 
	gnfa0
 = 
NFA
(
dH
[
minGrad
], (int)(
chainLen
 / 
divForTestSegment
));

2341 if (
	gnfa0
 <= 1.0) {

2342 for (int 
k
 = 
index1
; 
	gk
 <= 
index2
; k++) {

2343 int 
	gr
 = 
segmentPoints
[
i
][
k
].
y
;

2344 int 
	gc
 = 
segmentPoints
[
i
][
k
].
x
;

2346 
	gedgeImg
[
r
 * 
width
 + 
c
] = 255;

2352 int 
	gend
 = 
minGradIndex
 - 1;

2353 while (
	gend
 > 
	gindex1
) {

2354 int 
	gr
 = 
segmentPoints
[
i
][
end
].
y
;

2355 int 
	gc
 = 
segmentPoints
[
i
][
end
].
x
;

2357 if (
	ggradImg
[
r
 * 
width
 + 
c
] <= 
minGrad
) 
end
--;

2361 int 
	gstart
 = 
minGradIndex
 + 1;

2362 while (
	gstart
 < 
	gindex2
) {

2363 int 
	gr
 = 
segmentPoints
[
i
][
start
].
y
;

2364 int 
	gc
 = 
segmentPoints
[
i
][
start
].
x
;

2366 if (
	ggradImg
[
r
 * 
width
 + 
c
] <= 
minGrad
) 
start
++;

2370 
TestSegment
(
i
, 
index1
, 
end
);

2371 
TestSegment
(
i
, 
start
, 
index2
);

2377 void 
	gEdgeDrawingImpl
::
ExtractNewSegments
()

2379 
vector
< vector<
Point
> > 
validSegments
;

2380 int 
	gnoSegments
 = 0;

2382 for (int 
	gi
 = 0; i < 
	gsegmentNos
; i++) {

2383 int 
	gstart
 = 0;

2384 while (
	gstart
 < (int)
	gsegmentPoints
[
i
].
size
()) {

2386 while (
	gstart
 < (int)
	gsegmentPoints
[
i
].
size
()) {

2387 int 
	gr
 = 
segmentPoints
[
i
][
start
].
y
;

2388 int 
	gc
 = 
segmentPoints
[
i
][
start
].
x
;

2390 if (
	gedgeImg
[
r
 * 
width
 + 
c
]) break;

2391 
	gstart
++;

2394 int 
	gend
 = 
start
 + 1;

2395 while (
	gend
 < (int)
	gsegmentPoints
[
i
].
size
()) {

2396 int 
	gr
 = 
segmentPoints
[
i
][
end
].
y
;

2397 int 
	gc
 = 
segmentPoints
[
i
][
end
].
x
;

2399 if (
	gedgeImg
[
r
 * 
width
 + 
c
] == 0) break;

2400 
	gend
++;

2403 int 
	glen
 = 
end
 - 
start
;

2404 if (
	glen
 >= 10) {

2408 
validSegments
.
push_back
(
vector
<
Point
>());

2409 
	gvector
<
	gPoint
> 
subVec
(&
segmentPoints
[
i
][
start
], &segmentPoints[i][
end
 - 1]);

2410 
	gvalidSegments
[
noSegments
] = 
subVec
;

2411 
	gnoSegments
++;

2413 
	gstart
 = 
end
 + 1;

2417 
	gsegmentPoints
 = 
validSegments
;

2418 
	gsegmentNos
 = 
noSegments
;

2421 double 
	gEdgeDrawingImpl
::
NFA
(double 
prob
, int 
len
)

2423 double 
	gnfa0
 = 
np
;

2424 for (int 
	gi
 = 0; i<
	glen
 && 
	gnfa0
 > 1.0; i++)

2425 
	gnfa0
 *= 
prob
;

2427 return 
	gnfa0
;

2432 void 
	gEdgeDrawingImpl
::
detectEllipses
(
OutputArray
 
ellipses
)

2434 
vector
<
Vec6d
> 
_ellipses
;

2435 if (
	gsegmentPoints
.
size
() < 1)

2437 
Mat
(
_ellipses
).
copyTo
(
ellipses
);

2441 
	gmin_line_len
 = 6;

2442 
	gline_error
 = 
params
.
LineFitErrorThreshold
;

2443 
	gCircles
.
clear
();

2444 
	gEllipses
.
clear
();

2445 
	glines
.
clear
();

2449 
	gnoCircles1
 = 0;

2450 
	gcircles1
 = 
new
 
Circle
[(
width
 + 
height
) * 8];

2452 int 
	gbufferSize
 = 0;

2453 for (int 
	gi
 = 0; i < (int)
	gsegmentPoints
.
size
(); i++)

2454 
	gbufferSize
 += (int)
segmentPoints
[
i
].
size
();

2457 
	gsegmentStartLines
 = 
new
 int[
segmentNos
 + 1];

2459 
	gbm
 = 
new
 
BufferManager
(
bufferSize
 * 8);

2461 #define 
	#CIRCLE_MIN_LINE_LEN
 6

	)

2463 for (int 
	gi
 = 0; i < 
	gsegmentNos
; i++)

2466 
	gsegmentStartLines
[
i
] = (int)
lines
.
size
();

2468 int 
	gnoPixels
 = (int)
segmentPoints
[
i
].
size
();

2470 if (
	gnoPixels
 < 2 * 
	gCIRCLE_MIN_LINE_LEN
)

2473 double* 
	gx
 = 
bm
->
getX
();

2474 double* 
	gy
 = 
bm
->
getY
();

2476 for (int 
	gj
 = 0; j < 
	gnoPixels
; j++)

2478 
	gx
[
j
] = 
segmentPoints
[
i
][j].
x
;

2479 
	gy
[
j
] = 
segmentPoints
[
i
][j].
y
;

2483 if (
	gnoPixels
 >= 4 * 
CIRCLE_MIN_LINE_LEN
)

2486 double 
dx
 = 
x
[0] - x[
noPixels
 - 1];

2487 double 
	gdy
 = 
y
[0] - y[
noPixels
 - 1];

2488 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2489 double 
	gr
 = 
noPixels
 / 
CV_2PI
;

2491 double 
	gmaxDistanceBetweenEndPoints
 = 
std
::
max
(3.0, 
r
 / 4.0);

2494 if (
	gd
 <= 
maxDistanceBetweenEndPoints
)

2496 double 
xc
, 
yc
, 
circleFitError
 = 1e10;

2498 
CircleFit
(
x
, 
y
, 
noPixels
, &
xc
, &
yc
, &
r
, &
circleFitError
);

2500 
EllipseEquation
 
	geq
;

2501 double 
	gellipseFitError
 = 1e10;

2503 if (
	gcircleFitError
 > 
	gLONG_ARC_ERROR
)

2506 if (
EllipseFit
(
x
, 
y
, 
noPixels
, &
eq
))

2507 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
x
, 
y
, 
noPixels
);

2510 if (
	gcircleFitError
 <= 
LONG_ARC_ERROR
)

2512 
addCircle
(
circles1
, 
noCircles1
, 
xc
, 
yc
, 
r
, 
circleFitError
, 
x
, 
y
, 
noPixels
);

2513 
	gbm
->
move
(
noPixels
);

2516 else if (
	gellipseFitError
 <= 
ELLIPSE_ERROR
)

2518 double 
major
, 
minor
;

2519 
ComputeEllipseCenterAndAxisLengths
(&
eq
, &
xc
, &
yc
, &
major
, &
minor
);

2522 if (
	gminor
 > 
	gmajor
)

2524 double 
	gtmp
 = 
major
;

2525 
	gmajor
 = 
minor
;

2526 
	gminor
 = 
tmp
;

2529 if (
	gmajor
 < 8 * 
	gminor
)

2531 
addCircle
(
circles1
, 
noCircles1
, 
xc
, 
yc
, 
r
, 
circleFitError
, &
eq
, 
ellipseFitError
, 
x
, 
y
, 
noPixels
);

2532 
	gbm
->
move
(
noPixels
);

2539 
SplitSegment2Lines
(
x
, 
y
, 
noPixels
, 
i
);

2542 
	gmin_line_len
 = 
params
.
MinLineLength
;

2543 
	gsegmentStartLines
[
segmentNos
] = (int)
lines
.
size
();

2547 
	ginfo
 = 
new
 
Info
[
lines
.
size
()];

2550 for (int 
	gi
 = 0; i < 
	gsegmentNos
; i++)

2552 for (int 
	gj
 = 
segmentStartLines
[
i
]; j < 
	gsegmentStartLines
[i + 1]; j++)

2554 
EDLineSegment
* 
	gl1
 = &
lines
[
j
];

2555 
EDLineSegment
* 
	gl2
;

2557 if (
	gj
 == 
segmentStartLines
[
i
 + 1] - 1)

2558 
l2
 = &
lines
[
segmentStartLines
[
i
]];

2560 
	gl2
 = &
lines
[
j
 + 1];

2563 double 
	gdx
 = 
l1
->
ex
 - 
l2
->
sx
;

2564 double 
	gdy
 = 
l1
->
ey
 - 
l2
->
sy
;

2565 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2566 if (
	gd
 >= 15)

2568 
info
[
j
].
angle
 = 10;

2569 
	ginfo
[
j
].
	gsign
 = 2;

2570 
	ginfo
[
j
].
	gtaken
 = 
false
;

2575 double 
	gv1x
 = 
l1
->
ex
 - l1->
sx
;

2576 double 
	gv1y
 = 
l1
->
ey
 - l1->
sy
;

2577 double 
	gv1Len
 = 
sqrt
(
v1x
 * v1x + 
v1y
 * v1y);

2579 double 
	gv2x
 = 
l2
->
ex
 - l2->
sx
;

2580 double 
	gv2y
 = 
l2
->
ey
 - l2->
sy
;

2581 double 
	gv2Len
 = 
sqrt
(
v2x
 * v2x + 
v2y
 * v2y);

2583 double 
	gdotProduct
 = (
v1x
 * 
v2x
 + 
v1y
 * 
v2y
) / (
v1Len
 * 
v2Len
);

2584 if (
	gdotProduct
 > 1.0)

2585 
	gdotProduct
 = 1.0;

2586 else if (
	gdotProduct
 < -1.0)

2587 
	gdotProduct
 = -1.0;

2589 
	ginfo
[
j
].
	gangle
 = 
acos
(
dotProduct
);

2590 
	ginfo
[
j
].
	gsign
 = (
v1x
 * 
v2y
 - 
v2x
 * 
v1y
) >= 0 ? 1 : -1;

2591 
	ginfo
[
j
].
	gtaken
 = 
false
;

2596 int 
	gmaxNoOfCircles
 = (int)
lines
.
size
() / 3 + 
noCircles1
 * 2;

2598 
	gedarcs1
 = 
new
 
EDArcs
(
maxNoOfCircles
);

2599 
DetectArcs
();

2603 
	gedarcs2
 = 
new
 
EDArcs
(
maxNoOfCircles
);

2604 
JoinArcs1
();

2607 
	gedarcs3
 = 
new
 
EDArcs
(
maxNoOfCircles
);

2608 
JoinArcs2
();

2611 
	gedarcs4
 = 
new
 
EDArcs
(
maxNoOfCircles
);

2612 
JoinArcs3
();

2615 
GenerateCandidateCircles
();

2618 
	gnoCircles2
 = 0;

2619 
	gcircles2
 = 
new
 
Circle
[
maxNoOfCircles
];

2620 
GaussianBlur
(
srcImage
, 
smoothImage
, 
Size
(0,0), 0.50);

2622 
ValidateCircles
(
params
.
NFAValidation
);

2625 
	gnoCircles3
 = 0;

2626 
	gcircles3
 = 
new
 
Circle
[
maxNoOfCircles
];

2627 
JoinCircles
();

2629 
	gnoCircles
 = 0;

2630 
	gnoEllipses
 = 0;

2631 for (int 
	gi
 = 0; i < 
	gnoCircles3
; i++)

2633 if (
	gcircles3
[
i
].
	gisEllipse
)

2634 
	gnoEllipses
++;

2636 
	gnoCircles
++;

2639 for (int 
	gi
 = 0; i < 
	gnoCircles3
; i++)

2641 if (
	gcircles3
[
i
].
	gisEllipse
)

2643 
EllipseEquation
 
	geq
 = 
circles3
[
i
].
eq
;

2644 double 
	gxc
;

2645 double 
	gyc
;

2646 double 
	ga
;

2647 double 
	gb
;

2648 double 
	gtheta
 = 
ComputeEllipseCenterAndAxisLengths
(&
eq
, &
xc
, &
yc
, &
a
, &
b
);

2649 
	gEllipses
.
push_back
(
mEllipse
(
Point2d
(
xc
, 
yc
), 
Size2d
(
a
, 
b
), 
theta
));

2650 
	g_ellipses
.
push_back
(
Vec6d
(
xc
, 
yc
, 0, 
a
, 
b
, 
theta
 * 180 / 
CV_PI
));

2654 double 
	gr
 = 
circles3
[
i
].
r
;

2655 double 
	gxc
 = 
circles3
[
i
].
xc
;

2656 double 
	gyc
 = 
circles3
[
i
].
yc
;

2658 
	gCircles
.
push_back
(
mCircle
(
Point2d
(
xc
, 
yc
), 
r
));

2659 
	g_ellipses
.
push_back
(
Vec6d
(
xc
, 
yc
, 
r
, 0, 0, 0));

2663 
Mat
(
_ellipses
).
copyTo
(
ellipses
);

2665 
delete
 
	gedarcs1
;

2666 
delete
 
	gedarcs2
;

2667 
delete
 
	gedarcs3
;

2668 
delete
 
	gedarcs4
;

2670 
	gedarcs1
 = 
NULL
;

2671 
	gedarcs2
 = 
NULL
;

2672 
	gedarcs3
 = 
NULL
;

2673 
	gedarcs4
 = 
NULL
;

2675 
	gdelete
[] 
	gcircles1
;

2676 
	gdelete
[] 
	gcircles2
;

2677 
	gdelete
[] 
	gcircles3
;

2679 
delete
 
	gbm
;

2680 
	gdelete
[] 
	gsegmentStartLines
;

2681 
	gdelete
[] 
	ginfo
;

2684 void 
	gEdgeDrawingImpl
::
GenerateCandidateCircles
()

2687 
MyArc
* 
arcs
 = 
edarcs4
->arcs;

2688 for (int 
	gi
 = 0; i < 
	gedarcs4
->
	gnoArcs
; i++)

2690 if (
	garcs
[
i
].
	gisEllipse
)

2693 if (
	garcs
[
i
].
	gcoverRatio
 >= 
CANDIDATE_ELLIPSE_RATIO
 && 
arcs
[i].
ellipseFitError
 <= 
ELLIPSE_ERROR
)

2695 
addCircle
(
circles1
, 
noCircles1
, 
arcs
[
i
].
xc
, arcs[i].
yc
, arcs[i].
r
, arcs[i].
circleFitError
, &arcs[i].
eq
, arcs[i].
ellipseFitError
,

2696 
arcs
[
i
].
x
, arcs[i].
y
, arcs[i].
noPixels
);

2700 double 
	gcoverRatio
 = 
MAX
(
ArcLength
(
arcs
[
i
].
sTheta
, arcs[i].
eTheta
) / 
CV_2PI
, arcs[i].
coverRatio
);

2701 if ((
	gcoverRatio
 >= 
FULL_CIRCLE_RATIO
 && 
arcs
[
i
].
circleFitError
 <= 
LONG_ARC_ERROR
) ||

2702 (
coverRatio
 >= 
HALF_CIRCLE_RATIO
 && 
arcs
[
i
].
circleFitError
 <= 
HALF_ARC_ERROR
) ||

2703 (
coverRatio
 >= 
CANDIDATE_CIRCLE_RATIO2
 && 
arcs
[
i
].
circleFitError
 <= 
SHORT_ARC_ERROR
))

2705 
addCircle
(
circles1
, 
noCircles1
, 
arcs
[
i
].
xc
, arcs[i].
yc
, arcs[i].
r
, arcs[i].
circleFitError
, arcs[i].
x
, arcs[i].
y
, arcs[i].
noPixels
);

2712 if (
	garcs
[
i
].
	gcoverRatio
 < 
	gCANDIDATE_CIRCLE_RATIO1
)

2716 if ((
	garcs
[
i
].
	gcoverRatio
 >= 
FULL_CIRCLE_RATIO
 && 
arcs
[i].
circleFitError
 <= 
LONG_ARC_ERROR
) ||

2717 (
arcs
[
i
].
coverRatio
 >= 
HALF_CIRCLE_RATIO
 && arcs[i].
circleFitError
 <= 
HALF_ARC_ERROR
) ||

2718 (
arcs
[
i
].
coverRatio
 >= 
CANDIDATE_CIRCLE_RATIO2
 && arcs[i].
circleFitError
 <= 
SHORT_ARC_ERROR
))

2721 
addCircle
(
circles1
, 
noCircles1
, 
arcs
[
i
].
xc
, arcs[i].
yc
, arcs[i].
r
, arcs[i].
circleFitError
, arcs[i].
x
, arcs[i].
y
, arcs[i].
noPixels
);

2726 if (
	garcs
[
i
].
	gcoverRatio
 < 
	gCANDIDATE_CIRCLE_RATIO2
)

2730 
EllipseEquation
 
	geq
;

2731 double 
	gellipseFitError
 = 1e10;

2732 double 
coverRatio
(0);

2734 int 
	gnoPixels
 = 
arcs
[
i
].
noPixels
;

2735 if (
EllipseFit
(
arcs
[
i
].
x
, arcs[i].
y
, 
noPixels
, &
eq
))

2737 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
arcs
[
i
].
x
, arcs[i].
y
, 
noPixels
);

2738 
	gcoverRatio
 = 
noPixels
 / 
computeEllipsePerimeter
(&
eq
);

2741 if (
	garcs
[
i
].
	gcoverRatio
 > coverRatio)

2742 
	gcoverRatio
 = 
arcs
[
i
].
coverRatio
;

2744 if (
	gcoverRatio
 >= 
CANDIDATE_ELLIPSE_RATIO
 && 
ellipseFitError
 <= 
ELLIPSE_ERROR
)

2746 
addCircle
(
circles1
, 
noCircles1
, 
arcs
[
i
].
xc
, arcs[i].
yc
, arcs[i].
r
, arcs[i].
circleFitError
, &
eq
, 
ellipseFitError
, arcs[i].
x
, arcs[i].
y
, arcs[i].
noPixels
);

2752 void 
	gEdgeDrawingImpl
::
DetectArcs
()

2754 double 
maxLineLengthThreshold
 = 
MAX
(
width
, 
height
) / 5;

2756 double 
	gMIN_ANGLE
 = 
CV_PI
 / 30;

2757 double 
	gMAX_ANGLE
 = 
CV_PI
 / 3;

2759 for (int 
	giter
 = 1; iter <= 2; iter++)

2761 if (
	giter
 == 2)

2762 
MAX_ANGLE
 = 
CV_PI
 / 1.9;

2764 for (int 
	gcurSegmentNo
 = 0; curSegmentNo < 
	gsegmentNos
; curSegmentNo++)

2766 int 
	gfirstLine
 = 
segmentStartLines
[
curSegmentNo
];

2767 int 
	gstopLine
 = 
segmentStartLines
[
curSegmentNo
 + 1];

2770 if (
	gstopLine
 - 
	gfirstLine
 <= 1)

2774 while (
	gfirstLine
 < 
	gstopLine
 - 1)

2777 if (
	ginfo
[
firstLine
].
	gtaken
)

2779 
	gfirstLine
++;

2784 if (
	glines
[
firstLine
].
	glen
 >= 
maxLineLengthThreshold
)

2786 
firstLine
++;

2791 if (
	ginfo
[
firstLine
].
	gangle
 < 
	gMIN_ANGLE
 || info[firstLine].angle > 
	gMAX_ANGLE
)

2793 
	gfirstLine
++;

2798 int 
	glastLine
 = 
firstLine
 + 1;

2799 while (
	glastLine
 < 
	gstopLine
 - 1)

2801 if (
	ginfo
[
lastLine
].
	gtaken
)

2803 if (
	ginfo
[
lastLine
].
	gsign
 != 
info
[
firstLine
].
sign
)

2806 if (
	glines
[
lastLine
].
	glen
 >= 
maxLineLengthThreshold
)

2808 if (
	ginfo
[
lastLine
].
	gangle
 < 
	gMIN_ANGLE
)

2810 if (
	ginfo
[
lastLine
].
	gangle
 > 
	gMAX_ANGLE
)

2813 
	glastLine
++;

2816 
bool
 
	gspecialCase
 = 
false
;

2817 int 
	gwrapCase
 = -1;

2819 if (
	glastLine
 - 
	gfirstLine
 == 1)

2822 int 
totalLineLength
 = 
lines
[
firstLine
].
len
 + lines[firstLine + 1].len;

2823 int 
	gshorterLen
 = 
lines
[
firstLine
].
len
;

2824 int 
	glongerLen
 = 
lines
[
firstLine
 + 1].
len
;

2826 if (
	glines
[
firstLine
 + 1].
	glen
 < 
	gshorterLen
)

2828 
	gshorterLen
 = 
lines
[
firstLine
 + 1].
len
;

2829 
	glongerLen
 = 
lines
[
firstLine
].
len
;

2832 if (
	ginfo
[
firstLine
].
	gangle
 >= 
CV_PI
 / 12 && 
info
[firstLine].
angle
 <= CV_PI / 4 && 
totalLineLength
 >= 40 && 
shorterLen
 * 2 >= 
longerLen
)

2834 
specialCase
 = 
true
;

2839 if (
	gspecialCase
 == 
false
)

2842 if (
firstLine
 == 
segmentStartLines
[
curSegmentNo
] && 
info
[
stopLine
 - 1].
angle
 >= 
MIN_ANGLE
 && info[stopLine - 1].angle <= 
MAX_ANGLE
)

2844 
wrapCase
 = 1;

2845 
	gspecialCase
 = 
true
;

2849 else if (
	glastLine
 == 
stopLine
 - 1 && 
info
[
lastLine
].
angle
 >= 
MIN_ANGLE
 && info[lastLine].angle <= 
MAX_ANGLE
)

2851 
wrapCase
 = 2;

2852 
	gspecialCase
 = 
true
;

2857 if (
	gspecialCase
 == 
false
)

2859 
firstLine
 = 
lastLine
;

2865 int 
	gnoPixels
 = 0;

2866 double* 
	gx
 = 
bm
->
getX
();

2867 double* 
	gy
 = 
bm
->
getY
();

2870 if (
	gwrapCase
 == 1)

2872 int 
index
 = 
lines
[
stopLine
 - 1].
firstPixelIndex
;

2874 for (int 
	gn
 = 0; n < 
	glines
[
stopLine
 - 1].
	glen
; n++)

2876 
	gx
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
x
;

2877 
	gy
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
y
;

2878 
	gnoPixels
++;

2882 for (int 
	gm
 = 
firstLine
; m <= 
lastLine
; m++)

2884 int 
	gindex
 = 
lines
[
m
].
firstPixelIndex
;

2886 for (int 
	gn
 = 0; n < 
	glines
[
m
].
	glen
; n++)

2888 
	gx
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
x
;

2889 
	gy
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
y
;

2890 
	gnoPixels
++;

2895 if (
	gwrapCase
 == 2)

2897 int 
index
 = 
lines
[
segmentStartLines
[
curSegmentNo
]].
firstPixelIndex
;

2899 for (int 
	gn
 = 0; n < 
	glines
[
segmentStartLines
[
curSegmentNo
]].
	glen
; n++)

2901 
	gx
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
x
;

2902 
	gy
[
noPixels
] = 
segmentPoints
[
curSegmentNo
][
index
 + 
n
].
y
;

2903 
	gnoPixels
++;

2908 
	gbm
->
move
(
noPixels
);

2911 double 
	gxc
 = -1, 
	gyc
 = -1, 
	gradius
 = -1, 
	gcircleFitError
 = -1;

2912 
CircleFit
(
x
, 
y
, 
noPixels
, &
xc
, &
yc
, &
radius
, &
circleFitError
);

2914 double 
	gcoverage
 = 
noPixels
 / (
CV_2PI
 * 
radius
);

2917 if (
	gspecialCase
 && 
	gcoverage
 < 1.0 / 16)

2919 
	ginfo
[
firstLine
].
	gtaken
 = 
true
;

2920 
	gfirstLine
 = 
lastLine
;

2925 double 
	gMYERROR
 = 
SHORT_ARC_ERROR
;

2926 if (
	glastLine
 - 
	gfirstLine
 >= 3)

2927 
MYERROR
 = 
LONG_ARC_ERROR
;

2928 if (
	gcircleFitError
 <= 
MYERROR
)

2931 if (
wrapCase
 == 1)

2933 
x
 += 
lines
[
stopLine
 - 1].
len
;

2934 
	gy
 += 
lines
[
stopLine
 - 1].
len
;

2935 
	gnoPixels
 -= 
lines
[
stopLine
 - 1].
len
;

2937 else if (
	gwrapCase
 == 2)

2939 
noPixels
 -= 
lines
[
segmentStartLines
[
curSegmentNo
]].
len
;

2942 if ((
	gcoverage
 >= 
FULL_CIRCLE_RATIO
 && 
circleFitError
 <= 
LONG_ARC_ERROR
))

2944 
addCircle
(
circles1
, 
noCircles1
, 
xc
, 
yc
, 
radius
, 
circleFitError
, 
x
, 
y
, 
noPixels
);

2948 double 
	gsTheta
, 
	geTheta
;

2949 
ComputeStartAndEndAngles
(
xc
, 
yc
, 
radius
, 
x
, 
y
, 
noPixels
, &
sTheta
, &
eTheta
);

2951 
addArc
(
edarcs1
->
arcs
, edarcs1->
noArcs
, 
xc
, 
yc
, 
radius
, 
circleFitError
, 
sTheta
, 
eTheta
, 
info
[
firstLine
].
sign
, 
curSegmentNo
,

2952 (int)
x
[0], (int)
y
[0], (int)x[
noPixels
 - 1], (int)y[noPixels - 1], x, y, noPixels);

2955 for (int 
	gm
 = 
firstLine
; m < 
	glastLine
; m++)

2956 
	ginfo
[
m
].
	gtaken
 = 
true
;

2957 
	gfirstLine
 = 
lastLine
;

2962 double 
	gdx
 = 
x
[0] - x[
noPixels
 - 1];

2963 double 
	gdy
 = 
y
[0] - y[
noPixels
 - 1];

2964 double 
	gdistanceBetweenEndPoints
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

2966 
bool
 
	gisAlmostClosedLoop
 = (
distanceBetweenEndPoints
 <= 1.72 * 
radius
 && 
coverage
 >= 
FULL_CIRCLE_RATIO
);

2967 if (
	gisAlmostClosedLoop
 || (
	giter
 == 1 && 
coverage
 >= 0.25))

2969 
EllipseEquation
 
eq
;

2970 double 
	gellipseFitError
 = 1e10;

2972 
bool
 
	gvalid
 = 
EllipseFit
(
x
, 
y
, 
noPixels
, &
eq
);

2973 if (
	gvalid
)

2974 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
x
, 
y
, 
noPixels
);

2976 
	gMYERROR
 = 
ELLIPSE_ERROR
;

2977 if (
	gisAlmostClosedLoop
 == 
false
)

2978 
MYERROR
 = 0.75;

2980 if (
	gellipseFitError
 <= 
MYERROR
)

2983 if (
wrapCase
 == 1)

2985 
x
 += 
lines
[
stopLine
 - 1].
len
;

2986 
	gy
 += 
lines
[
stopLine
 - 1].
len
;

2987 
	gnoPixels
 -= 
lines
[
stopLine
 - 1].
len
;

2989 else if (
	gwrapCase
 == 2)

2991 
noPixels
 -= 
lines
[
segmentStartLines
[
curSegmentNo
]].
len
;

2994 if (
	gisAlmostClosedLoop
)

2996 
addCircle
(
circles1
, 
noCircles1
, 
xc
, 
yc
, 
radius
, 
circleFitError
, &
eq
, 
ellipseFitError
, 
x
, 
y
, 
noPixels
);

3000 double 
	gsTheta
, 
	geTheta
;

3001 
ComputeStartAndEndAngles
(
xc
, 
yc
, 
radius
, 
x
, 
y
, 
noPixels
, &
sTheta
, &
eTheta
);

3003 
addArc
(
edarcs1
->
arcs
, edarcs1->
noArcs
, 
xc
, 
yc
, 
radius
, 
circleFitError
, 
sTheta
, 
eTheta
, 
info
[
firstLine
].
sign
, 
curSegmentNo
, &
eq
, 
ellipseFitError
,

3004 (int)
x
[0], (int)
y
[0], (int)x[
noPixels
 - 1], (int)y[noPixels - 1], x, y, noPixels);

3007 for (int 
	gm
 = 
firstLine
; m < 
	glastLine
; m++)

3008 
	ginfo
[
m
].
	gtaken
 = 
true
;

3009 
	gfirstLine
 = 
lastLine
;

3014 if (
	gspecialCase
)

3016 
	ginfo
[
firstLine
].
	gtaken
 = 
true
;

3017 
	gfirstLine
 = 
lastLine
;

3022 while (
	gfirstLine
 <= 
lastLine
 - 2)

3025 int 
curLine
 = 
firstLine
 + 2;

3028 double 
XC
(0), 
YC
(0), 
R
(0), 
	gError
 = 1e10;

3029 
bool
 
	gfound
 = 
false
;

3031 
	gnoPixels
 = 0;

3032 while (
	gcurLine
 <= 
lastLine
)

3034 
noPixels
 = 0;

3035 for (int 
	gm
 = 
firstLine
; m <= 
curLine
; m++)

3036 
	gnoPixels
 += 
lines
[
m
].
len
;

3039 
CircleFit
(
x
, 
y
, 
noPixels
, &
XC
, &
YC
, &
R
, &
Error
);

3040 if (
	gError
 <= 
SHORT_ARC_ERROR
)

3042 
found
 = 
true
;

3047 
	gx
 += 
lines
[
firstLine
].
len
;

3048 
	gy
 += 
lines
[
firstLine
].
len
;

3050 
	gfirstLine
++;

3051 
	gcurLine
++;

3055 if (!
	gfound
)

3059 for (int 
	gm
 = 
curLine
 - 2; m <= curLine; m++)

3060 
	ginfo
[
m
].
	gtaken
 = 
true
;

3061 
	gcurLine
++;

3063 while (
	gcurLine
 <= 
lastLine
)

3065 int 
noPixelsSave
 = 
noPixels
;

3067 
	gnoPixels
 += 
lines
[
curLine
].
len
;

3069 double 
	gr
, 
	gerror
;

3070 
CircleFit
(
x
, 
y
, 
noPixels
, &
xc
, &
yc
, &
r
, &
error
);

3071 if (
	gerror
 > 
	gLONG_ARC_ERROR
)

3073 
	gnoPixels
 = 
noPixelsSave
;

3078 
	gXC
 = 
xc
;

3079 
	gYC
 = 
yc
;

3080 
	gR
 = 
r
;

3081 
	gError
 = 
error
;

3083 
	ginfo
[
curLine
].
	gtaken
 = 
true
;

3084 
	gcurLine
++;

3087 
	gcoverage
 = 
noPixels
 / (
CV_2PI
 * 
radius
);

3088 if ((
	gcoverage
 >= 
FULL_CIRCLE_RATIO
 && 
circleFitError
 <= 
LONG_ARC_ERROR
))

3090 
addCircle
(
circles1
, 
noCircles1
, 
XC
, 
YC
, 
R
, 
Error
, 
x
, 
y
, 
noPixels
);

3095 double 
	gsTheta
, 
	geTheta
;

3096 
ComputeStartAndEndAngles
(
XC
, 
YC
, 
R
, 
x
, 
y
, 
noPixels
, &
sTheta
, &
eTheta
);

3098 
addArc
(
edarcs1
->
arcs
, edarcs1->
noArcs
, 
XC
, 
YC
, 
R
, 
Error
, 
sTheta
, 
eTheta
, 
info
[
firstLine
].
sign
, 
curSegmentNo
,

3099 (int)
x
[0], (int)
y
[0], (int)x[
noPixels
 - 1], (int)y[noPixels - 1], x, y, noPixels);

3102 
	gx
 += 
noPixels
;

3103 
	gy
 += 
noPixels
;

3105 
	gfirstLine
 = 
curLine
;

3107 
	gfirstLine
 = 
lastLine
;

3116 void 
	gEdgeDrawingImpl
::
ValidateCircles
(
bool
 
validate
)

3118 
precision
 = 
CV_PI
 / 16;

3120 int 
	gpoints_buffer_size
 = 8 * (
width
 + 
height
);

3121 double *
	gpx
 = 
new
 double[
points_buffer_size
];

3122 double *
	gpy
 = 
new
 double[
points_buffer_size
];

3124 if (
	gnfa
->
	gLUTSize
 == 1 && 
params
.
NFAValidation
)

3126 int 
lutSize
 = (
width
 + 
height
) / 8;

3127 double 
	gprob
 = 1.0 / 8;

3128 
	gnfa
 = 
new
 
NFALUT
(
lutSize
, 
prob
, 
width
, 
height
);

3132 
bool
 
	gvalidateAgain
;

3133 int 
	gcount
 = 0;

3134 for (int 
	gi
 = 0; i < 
	gnoCircles1
; )

3136 
Circle
* 
	gcircle
 = &
circles1
[
i
];

3137 double 
	gxc
 = 
circle
->
xc
;

3138 double 
	gyc
 = 
circle
->
yc
;

3139 double 
	gradius
 = 
circle
->
r
;

3142 if (
	gradius
 > 
MAX
(
width
, 
height
))

3144 
	gi
++;

3148 
	gvalidateAgain
 = 
false
;

3150 int 
	gnoPoints
 = (int)(
computeEllipsePerimeter
(&
circle
->
eq
));

3152 if (
	gnoPoints
 > 
	gpoints_buffer_size
)

3154 
	gi
++;

3158 if (
	gcircle
->
	gisEllipse
)

3160 
ComputeEllipsePoints
(
circle
->
eq
.
coeff
, 
px
, 
py
, 
noPoints
);

3164 
ComputeCirclePoints
(
xc
, 
yc
, 
radius
, 
px
, 
py
, &
noPoints
);

3167 int 
	gpr
 = -1;

3168 int 
	gpc
 = -1;

3170 int 
	gtr
 = -100;

3171 int 
	gtc
 = -100;

3173 int 
	gnoPeripheryPixels
 = 0;

3174 int 
	galigned
 = 0;

3175 for (int 
	gj
 = 0; j < 
	gnoPoints
; j++)

3177 int 
	gr
 = (int)(
py
[
j
] + 0.5);

3178 int 
	gc
 = (int)(
px
[
j
] + 0.5);

3180 if (
	gr
 == 
pr
 && 
c
 == 
pc
)

3182 
	gnoPeripheryPixels
++;

3184 if (
	gr
 <= 0 || 
r
 >= 
height
 - 1)

3186 if (
	gc
 <= 0 || 
c
 >= 
width
 - 1)

3189 
	gpr
 = 
r
;

3190 
	gpc
 = 
c
;

3192 int 
	gdr
 = 
abs
(
r
 - 
tr
);

3193 int 
	gdc
 = 
abs
(
c
 - 
tc
);

3194 if (
	gdr
 + 
	gdc
 >= 2)

3196 
tr
 = 
r
;

3197 
	gtc
 = 
c
;

3203 if (
	gedgeImg
[
r
 * 
width
 + 
c
] != 255)

3219 int 
x
 = 
c
;

3220 int 
	gy
 = 
r
;

3222 int 
	gdiff1
 = (int)(
y
 - 
yc
 - 
x
 + 
xc
);

3223 int 
	gdiff2
 = (int)(
y
 - 
yc
 + 
x
 - 
xc
);

3225 if (
	gdiff1
 < 0)

3227 if (
	gdiff2
 > 0)

3230 
	gc
 = 
x
 - 1;

3231 if (
	gc
 >= 1 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3232 goto 
out
;

3233 
	gc
 = 
x
 + 1;

3234 if (
	gc
 < 
	gwidth
 - 1 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3235 goto 
out
;

3237 
	gc
 = 
x
 - 2;

3238 if (
	gc
 >= 2 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3239 goto 
out
;

3240 
	gc
 = 
x
 + 2;

3241 if (
	gc
 < 
	gwidth
 - 2 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3242 goto 
out
;

3247 
	gr
 = 
y
 - 1;

3248 if (
	gr
 >= 1 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3249 goto 
out
;

3250 
	gr
 = 
y
 + 1;

3251 if (
	gr
 < 
	gheight
 - 1 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3252 goto 
out
;

3254 
	gr
 = 
y
 - 2;

3255 if (
	gr
 >= 2 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3256 goto 
out
;

3257 
	gr
 = 
y
 + 2;

3258 if (
	gr
 < 
	gheight
 - 2 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3259 goto 
out
;

3264 if (
	gdiff2
 > 0)

3267 
	gr
 = 
y
 - 1;

3268 if (
	gr
 >= 1 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3269 goto 
out
;

3270 
	gr
 = 
y
 + 1;

3271 if (
	gr
 < 
	gheight
 - 1 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3272 goto 
out
;

3274 
	gr
 = 
y
 - 2;

3275 if (
	gr
 >= 2 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3276 goto 
out
;

3277 
	gr
 = 
y
 + 2;

3278 if (
	gr
 < 
	gheight
 - 2 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3279 goto 
out
;

3284 
	gc
 = 
x
 - 1;

3285 if (
	gc
 >= 1 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3286 goto 
out
;

3287 
	gc
 = 
x
 + 1;

3288 if (
	gc
 < 
	gwidth
 - 1 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3289 goto 
out
;

3291 
	gc
 = 
x
 - 2;

3292 if (
	gc
 >= 2 && 
edgeImg
[
r
 * 
width
 + 
c
] == 255)

3293 goto 
out
;

3294 
	gc
 = 
x
 + 2;

3295 if (
	gc
 < 
	gwidth
 - 2 && 
	gedgeImg
[
r
 * 
width
 + 
c
] == 255)

3296 goto 
out
;

3300 
	gr
 = 
pr
;

3301 
	gc
 = 
pc
;

3305 
	gout
:

3307 int 
com1
 = 
smoothImg
[(
r
 + 1) * 
width
 + 
c
 + 1] - smoothImg[(r - 1) * width + c - 1];

3308 int 
	gcom2
 = 
smoothImg
[(
r
 - 1) * 
width
 + 
c
 + 1] - smoothImg[(r + 1) * width + c - 1];

3310 int 
	ggx
 = 
com1
 + 
com2
 + 
smoothImg
[
r
 * 
width
 + 
c
 + 1] - smoothImg[r * width + c - 1];

3311 int 
	ggy
 = 
com1
 - 
com2
 + 
smoothImg
[(
r
 + 1) * 
width
 + 
c
] - smoothImg[(r - 1) * width + c];

3312 double 
	gpixelAngle
 = 
nfa
->
myAtan2
((double)
gx
, (double)-
gy
);

3314 double 
	gderivX
, 
	gderivY
;

3315 if (
	gcircle
->
	gisEllipse
)

3318 
	gderivX
 = 2 * 
circle
->
eq
.
A
() * 
c
 + circle->eq.
B
() * 
r
 + circle->eq.
D
();

3319 
	gderivY
 = 
circle
->
eq
.
B
() * 
c
 + 2 * circle->eq.
C
() * 
r
 + circle->eq.
E
();

3324 
	gderivX
 = 
c
 - 
xc
;

3325 
	gderivY
 = 
r
 - 
yc
;

3328 double 
	gidealPixelAngle
 = 
nfa
->
myAtan2
(
derivX
, -
derivY
);

3329 double 
	gdiff
 = 
fabs
(
pixelAngle
 - 
idealPixelAngle
);

3330 if (
	gdiff
 <= 
precision
 || 
diff
 >= 
CV_PI
 - precision)

3331 
aligned
++;

3334 
bool
 
	gisValid
 = !
validate
 || 
nfa
->
checkValidationByNFA
(
noPeripheryPixels
, 
aligned
);

3336 if (
	gisValid
)

3338 
	gcircles2
[
count
++] = 
circles1
[
i
];

3340 else if (
	gcircle
->
	gisEllipse
 == 
false
 && 
circle
->
coverRatio
 >= 
CANDIDATE_ELLIPSE_RATIO
)

3343 double 
ellipseFitError
 = 1e10;

3344 
EllipseEquation
 
	geq
;

3346 if (
EllipseFit
(
circle
->
x
, circle->
y
, circle->
noPixels
, &
eq
))

3348 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
circle
->
x
, circle->
y
, circle->
noPixels
);

3351 if (
	gellipseFitError
 <= 
ELLIPSE_ERROR
)

3353 
circle
->
isEllipse
 = 
true
;

3354 
	gcircle
->
	gellipseFitError
 = 
ellipseFitError
;

3355 
	gcircle
->
	geq
 = 
eq
;

3357 
	gvalidateAgain
 = 
true
;

3361 if (
	gvalidateAgain
 == 
false
)

3362 
i
++;

3365 
	gnoCircles2
 = 
count
;

3367 
	gdelete
[] 
	gpx
;

3368 
	gdelete
[] 
	gpy
;

3371 void 
	gEdgeDrawingImpl
::
JoinCircles
()

3374 
sortCircles
(
circles2
, 
noCircles2
);

3376 
	gnoCircles
 = 
noCircles2
;

3377 
Circle
* 
	gcircles
 = 
circles2
;

3379 
	gvector
<
	gbool
> 
	gtaken
;

3380 
	gvector
<int> 
	gcandidateCircles
;

3381 int 
	gnoCandidateCircles
;

3383 for (int 
	gi
 = 0; i < 
	gnoCircles
; i++)

3385 
	gtaken
.
push_back
(
false
);

3386 
	gcandidateCircles
.
push_back
(0);

3388 if (
	gcircles
[
i
].
	gisEllipse
)

3390 
ComputeEllipseCenterAndAxisLengths
(&
circles
[
i
].
eq
, &circles[i].
xc
, &circles[i].
yc
, &circles[i].
majorAxisLength
, &circles[i].
minorAxisLength
);

3394 for (int 
	gi
 = 0; i < 
	gnoCircles
; i++)

3396 if (
	gtaken
[
i
])

3400 double 
	gmajorAxisLength
, 
	gminorAxisLength
;

3402 if (
	gcircles
[
i
].
	gisEllipse
)

3404 
	gmajorAxisLength
 = 
circles
[
i
].
majorAxisLength
;

3405 
	gminorAxisLength
 = 
circles
[
i
].
minorAxisLength
;

3409 
	gmajorAxisLength
 = 
circles
[
i
].
r
;

3410 
	gminorAxisLength
 = 
circles
[
i
].
r
;

3414 
	gnoCandidateCircles
 = 0;

3416 for (int 
	gj
 = 
i
 + 1; j < 
	gnoCircles
; j++)

3418 if (
	gtaken
[
j
])

3421 #define 
	#JOINED_SHORT_ARC_ERROR_THRESHOLD
 2

	)

3422 #define 
	#AXIS_LENGTH_DIFF_THRESHOLD
 6

3423 #define 
	#CENTER_DISTANCE_THRESHOLD
 12

3424 

	)

3425 double 
	gdx
 = 
circles
[
i
].
xc
 - circles[
j
].xc;

3426 double 
	gdy
 = 
circles
[
i
].
yc
 - circles[
j
].yc;

3427 double 
	gcenterDistance
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3428 if (
	gcenterDistance
 > 
	gCENTER_DISTANCE_THRESHOLD
)

3431 double 
	gdiff1
, 
	gdiff2
;

3432 if (
	gcircles
[
j
].
	gisEllipse
)

3434 
	gdiff1
 = 
fabs
(
majorAxisLength
 - 
circles
[
j
].majorAxisLength);

3435 
	gdiff2
 = 
fabs
(
minorAxisLength
 - 
circles
[
j
].minorAxisLength);

3439 
	gdiff1
 = 
fabs
(
majorAxisLength
 - 
circles
[
j
].
r
);

3440 
	gdiff2
 = 
fabs
(
minorAxisLength
 - 
circles
[
j
].
r
);

3443 if (
	gdiff1
 > 
	gAXIS_LENGTH_DIFF_THRESHOLD
)

3445 if (
	gdiff2
 > 
	gAXIS_LENGTH_DIFF_THRESHOLD
)

3449 
	gcandidateCircles
[
noCandidateCircles
] = 
j
;

3450 
	gnoCandidateCircles
++;

3454 double 
	gXC
 = 
circles
[
i
].
xc
;

3455 double 
	gYC
 = 
circles
[
i
].
yc
;

3456 double 
	gR
 = 
circles
[
i
].
r
;

3458 double 
	gCircleFitError
 = 
circles
[
i
].
circleFitError
;

3459 
bool
 
	gCircleFitValid
 = 
false
;

3461 
EllipseEquation
 
	gEq
;

3462 double 
EllipseFitError
(0);

3463 
bool
 
	gEllipseFitValid
 = 
false
;

3465 if (
	gnoCandidateCircles
 > 0)

3467 int 
	gnoPixels
 = 
circles
[
i
].
noPixels
;

3468 double* 
	gx
 = 
bm
->
getX
();

3469 double* 
	gy
 = 
bm
->
getY
();

3470 
memcpy
(
x
, 
circles
[
i
].x, 
noPixels
 * sizeof(double));

3471 
memcpy
(
y
, 
circles
[
i
].y, 
noPixels
 * sizeof(double));

3473 for (int 
	gj
 = 0; j < 
	gnoCandidateCircles
; j++)

3475 int 
	gCandidateArcNo
 = 
candidateCircles
[
j
];

3477 int 
	gnoPixelsSave
 = 
noPixels
;

3478 
memcpy
(
x
 + 
noPixels
, 
circles
[
CandidateArcNo
].x, circles[CandidateArcNo].noPixels * sizeof(double));

3479 
memcpy
(
y
 + 
noPixels
, 
circles
[
CandidateArcNo
].y, circles[CandidateArcNo].noPixels * sizeof(double));

3480 
	gnoPixels
 += 
circles
[
CandidateArcNo
].
noPixels
;

3482 
bool
 
	gcircleFitOK
 = 
false
;

3483 if (
	gEllipseFitValid
 == 
false
 && 
circles
[
i
].
isEllipse
 == false && circles[
CandidateArcNo
].isEllipse == false)

3485 double 
xc
, 
yc
, 
r
, 
error
 = 1e10;

3486 
CircleFit
(
x
, 
y
, 
noPixels
, &
xc
, &
yc
, &
r
, &
error
);

3488 if (
	gerror
 <= 
JOINED_SHORT_ARC_ERROR_THRESHOLD
)

3490 
taken
[
CandidateArcNo
] = 
true
;

3492 
	gXC
 = 
xc
;

3493 
	gYC
 = 
yc
;

3494 
	gR
 = 
r
;

3495 
	gCircleFitError
 = 
error
;

3497 
	gcircleFitOK
 = 
true
;

3498 
	gCircleFitValid
 = 
true
;

3502 
bool
 
	gellipseFitOK
 = 
false
;

3503 if (
	gcircleFitOK
 == 
false
)

3506 double 
error
 = 1e10;

3507 
EllipseEquation
 
	geq
;

3508 if (
EllipseFit
(
x
, 
y
, 
noPixels
, &
eq
))

3510 
	gerror
 = 
ComputeEllipseError
(&
eq
, 
x
, 
y
, 
noPixels
);

3513 if (
	gerror
 <= 
JOINED_SHORT_ARC_ERROR_THRESHOLD
)

3515 
taken
[
CandidateArcNo
] = 
true
;

3517 
	gEq
 = 
eq
;

3518 
	gEllipseFitError
 = 
error
;

3520 
	gellipseFitOK
 = 
true
;

3521 
	gEllipseFitValid
 = 
true
;

3522 
	gCircleFitValid
 = 
false
;

3526 if (
	gcircleFitOK
 == 
false
 && 
ellipseFitOK
 == false)

3528 
noPixels
 = 
noPixelsSave
;

3534 if (
	gCircleFitValid
)

3536 
addCircle
(
circles3
, 
noCircles3
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
NULL
, NULL, 0);

3538 else if (
	gEllipseFitValid
)

3540 
addCircle
(
circles3
, 
noCircles3
, 
XC
, 
YC
, 
R
, 
CircleFitError
, &
Eq
, 
EllipseFitError
, 
NULL
, NULL, 0);

3544 
	gcircles3
[
noCircles3
] = 
circles
[
i
];

3545 
	gnoCircles3
++;

3550 void 
	gEdgeDrawingImpl
::
JoinArcs1
()

3552 
AngleSet
 
angles
;

3555 
sortArc
(
edarcs1
->
arcs
, edarcs1->
noArcs
);

3557 int 
	gnoArcs
 = 
edarcs1
->
noArcs
;

3558 
MyArc
* 
	garcs
 = 
edarcs1
->
arcs
;

3560 
bool
* 
	gtaken
 = 
new
 bool[
noArcs
];

3561 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

3562 
	gtaken
[
i
] = 
false
;

3564 struct 
	sCandidateArc


3566 int 
	garcNo
;

3567 int 
	gwhich
;

3568 double 
	gdist
;

3571 
CandidateArc
* 
	gcandidateArcs
 = 
new
 CandidateArc[
noArcs
];

3572 int 
	gnoCandidateArcs
;

3574 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

3576 if (
	gtaken
[
i
])

3578 if (
	garcs
[
i
].
	gisEllipse
)

3580 
	gedarcs2
->
	garcs
[
edarcs2
->
noArcs
++] = 
arcs
[
i
];

3585 
bool
 
	gCircleEqValid
 = 
false
;

3586 double 
	gXC
 = 
arcs
[
i
].
xc
;

3587 double 
	gYC
 = 
arcs
[
i
].
yc
;

3588 double 
	gR
 = 
arcs
[
i
].
r
;

3589 double 
	gCircleFitError
 = 
arcs
[
i
].
circleFitError
;

3590 int 
	gTurn
 = 
arcs
[
i
].
turn
;

3591 int 
	gNoPixels
 = 
arcs
[
i
].
noPixels
;

3593 int 
	gSX
 = 
arcs
[
i
].
sx
;

3594 int 
	gSY
 = 
arcs
[
i
].
sy
;

3595 int 
	gEX
 = 
arcs
[
i
].
ex
;

3596 int 
	gEY
 = 
arcs
[
i
].
ey
;

3599 int 
	gnoPixels
 = 
arcs
[
i
].
noPixels
;

3601 double* 
	gx
 = 
bm
->
getX
();

3602 double* 
	gy
 = 
bm
->
getY
();

3603 
memcpy
(
x
, 
arcs
[
i
].x, 
noPixels
 * sizeof(double));

3604 
memcpy
(
y
, 
arcs
[
i
].y, 
noPixels
 * sizeof(double));

3606 
	gangles
.
clear
();

3607 
	gangles
.
set
(
arcs
[
i
].
sTheta
, arcs[i].
eTheta
);

3611 
bool
 
	gextendedArc
 = 
false
;

3614 
	gnoCandidateArcs
 = 0;

3616 for (int 
	gj
 = 
i
 + 1; j < 
	gnoArcs
; j++)

3618 if (
	gtaken
[
j
])

3620 if (
	garcs
[
j
].
	gisEllipse
)

3623 double 
	gminR
 = 
MIN
(
R
, 
arcs
[
j
].
r
);

3624 double 
	gradiusDiffThreshold
 = 
minR
 * 0.25;

3626 double 
	gdiff
 = 
fabs
(
R
 - 
arcs
[
j
].
r
);

3627 if (
	gdiff
 > 
	gradiusDiffThreshold
)

3631 if (
	gangles
.
overlap
(
arcs
[
j
].
sTheta
, arcs[j].
eTheta
) >= 0.50)

3636 double 
	gdx
 = 
SX
 - 
arcs
[
j
].
sx
;

3637 double 
	gdy
 = 
SY
 - 
arcs
[
j
].
sy
;

3638 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3639 int 
	gwhich
 = 1;

3642 
	gdx
 = 
SX
 - 
arcs
[
j
].
ex
;

3643 
	gdy
 = 
SY
 - 
arcs
[
j
].
ey
;

3644 double 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3646 if (
	gd2
 < 
	gd
)

3648 
	gd
 = 
d2
;

3649 
	gwhich
 = 2;

3653 
	gdx
 = 
EX
 - 
arcs
[
j
].
sx
;

3654 
	gdy
 = 
EY
 - 
arcs
[
j
].
sy
;

3655 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3657 if (
	gd2
 < 
	gd
)

3659 
	gd
 = 
d2
;

3660 
	gwhich
 = 3;

3664 
	gdx
 = 
EX
 - 
arcs
[
j
].
ex
;

3665 
	gdy
 = 
EY
 - 
arcs
[
j
].
ey
;

3666 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3668 if (
	gd2
 < 
	gd
)

3670 
	gd
 = 
d2
;

3671 
	gwhich
 = 4;

3675 double 
	gmaxDistanceBetweenEndpoints
 = 
minR
 * 1.75;

3676 if (
	gd
 > 
	gmaxDistanceBetweenEndpoints
)

3680 
	gd
 += 
diff
;

3683 if (
	gwhich
 == 2 || 
which
 == 3)

3685 if (
Turn
 != 
arcs
[
j
].
turn
)

3690 if (
	gTurn
 == 
arcs
[
j
].
turn
)

3695 int 
	gindex
 = 
noCandidateArcs
 - 1;

3697 while (
	gindex
 >= 0)

3699 if (
candidateArcs
[
index
].
dist
 < 
d
)

3702 
	gcandidateArcs
[
index
 + 1] = 
candidateArcs
[index];

3703 
	gindex
--;

3707 
	gindex
++;

3708 
	gcandidateArcs
[
index
].
	garcNo
 = 
j
;

3709 
	gcandidateArcs
[
index
].
	gwhich
 = 
which
;

3710 
	gcandidateArcs
[
index
].
	gdist
 = 
d
;

3711 
	gnoCandidateArcs
++;

3715 if (
	gnoCandidateArcs
 > 0)

3717 for (int 
	gj
 = 0; j < 
	gnoCandidateArcs
; j++)

3719 int 
	gCandidateArcNo
 = 
candidateArcs
[
j
].
arcNo
;

3720 int 
	gWhich
 = 
candidateArcs
[
j
].
which
;

3722 int 
	gnoPixelsSave
 = 
noPixels
;

3723 
memcpy
(
x
 + 
noPixels
, 
arcs
[
CandidateArcNo
].x, arcs[CandidateArcNo].noPixels * sizeof(double));

3724 
memcpy
(
y
 + 
noPixels
, 
arcs
[
CandidateArcNo
].y, arcs[CandidateArcNo].noPixels * sizeof(double));

3725 
	gnoPixels
 += 
arcs
[
CandidateArcNo
].
noPixels
;

3727 double 
	gxc
, 
	gyc
, 
	gr
, 
	gcircleFitError
;

3728 
CircleFit
(
x
, 
y
, 
noPixels
, &
xc
, &
yc
, &
r
, &
circleFitError
);

3730 if (
	gcircleFitError
 > 
	gLONG_ARC_ERROR
)

3733 
	gnoPixels
 = 
noPixelsSave
;

3738 
	gextendedArc
 = 
true
;

3739 
	gCircleEqValid
 = 
true
;

3740 
	gXC
 = 
xc
;

3741 
	gYC
 = 
yc
;

3742 
	gR
 = 
r
;

3743 
	gCircleFitError
 = 
circleFitError
;

3744 
	gNoPixels
 = 
noPixels
;

3746 
	gtaken
[
CandidateArcNo
] = 
true
;

3747 
	gtaken
[
i
] = 
true
;

3749 
	gangles
.
set
(
arcs
[
CandidateArcNo
].
sTheta
, arcs[CandidateArcNo].
eTheta
);

3752 switch (
	gWhich
)

3756 
SX
 = 
EX
, 
	gSY
 = 
EY
;

3757 
	gEX
 = 
arcs
[
CandidateArcNo
].
ex
;

3758 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

3759 if (
	gTurn
 == 1)

3760 
Turn
 = -1;

3762 
	gTurn
 = 1;

3767 
SX
 = 
EX
, 
	gSY
 = 
EY
;

3768 
	gEX
 = 
arcs
[
CandidateArcNo
].
sx
;

3769 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

3770 if (
	gTurn
 == 1)

3771 
Turn
 = -1;

3773 
	gTurn
 = 1;

3778 
EX
 = 
arcs
[
CandidateArcNo
].
ex
;

3779 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

3784 
EX
 = 
arcs
[
CandidateArcNo
].
sx
;

3785 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

3794 if (
	gextendedArc
 == 
false
)

3798 if (
	gCircleEqValid
 == 
false
)

3801 
edarcs2
->
arcs
[edarcs2->
noArcs
++] = arcs[
i
];

3806 double 
	gsTheta
, 
	geTheta
;

3807 
	gangles
.
computeStartEndTheta
(
sTheta
, 
eTheta
);

3809 double 
	gcoverage
 = 
ArcLength
(
sTheta
, 
eTheta
) / 
	gCV_2PI
;

3810 if ((
	gcoverage
 >= 
FULL_CIRCLE_RATIO
 && 
CircleFitError
 <= 
LONG_ARC_ERROR
))

3811 
addCircle
(
circles1
, 
noCircles1
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
x
, 
y
, 
NoPixels
);

3813 
addArc
(
edarcs2
->
arcs
, edarcs2->
noArcs
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
sTheta
, 
eTheta
, 
Turn
, arcs[
i
].
segmentNo
, 
SX
, 
SY
, 
EX
, 
EY
, 
x
, 
y
, 
NoPixels
, 
angles
.
overlapRatio
());

3815 
	gbm
->
move
(
NoPixels
);

3819 
	gdelete
[] 
	gtaken
;

3820 
	gdelete
[] 
	gcandidateArcs
;

3823 void 
	gEdgeDrawingImpl
::
JoinArcs2
()

3825 
AngleSet
 
angles
;

3828 
sortArc
(
edarcs2
->
arcs
, edarcs2->
noArcs
);

3830 int 
	gnoArcs
 = 
edarcs2
->
noArcs
;

3831 
MyArc
* 
	garcs
 = 
edarcs2
->
arcs
;

3833 
bool
* 
	gtaken
 = 
new
 bool[
noArcs
];

3834 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

3835 
	gtaken
[
i
] = 
false
;

3837 struct 
	sCandidateArc


3839 int 
	garcNo
;

3840 int 
	gwhich
;

3841 double 
	gdist
;

3844 
CandidateArc
* 
	gcandidateArcs
 = 
new
 CandidateArc[
noArcs
];

3845 int 
	gnoCandidateArcs
;

3847 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

3849 if (
	gtaken
[
i
])

3853 
bool
 
	gEllipseEqValid
 = 
false
;

3854 
EllipseEquation
 
	gEq
;

3855 double 
EllipseFitError
(0);

3857 double 
	gR
 = 
arcs
[
i
].
r
;

3858 int 
	gTurn
 = 
arcs
[
i
].
turn
;

3859 int 
	gNoPixels
 = 
arcs
[
i
].
noPixels
;

3861 int 
	gSX
 = 
arcs
[
i
].
sx
;

3862 int 
	gSY
 = 
arcs
[
i
].
sy
;

3863 int 
	gEX
 = 
arcs
[
i
].
ex
;

3864 int 
	gEY
 = 
arcs
[
i
].
ey
;

3867 int 
	gnoPixels
 = 
arcs
[
i
].
noPixels
;

3869 double* 
	gx
 = 
bm
->
getX
();

3870 double* 
	gy
 = 
bm
->
getY
();

3871 
memcpy
(
x
, 
arcs
[
i
].x, 
noPixels
 * sizeof(double));

3872 
memcpy
(
y
, 
arcs
[
i
].y, 
noPixels
 * sizeof(double));

3874 
	gangles
.
clear
();

3875 
	gangles
.
set
(
arcs
[
i
].
sTheta
, arcs[i].
eTheta
);

3879 
bool
 
	gextendedArc
 = 
false
;

3882 
	gnoCandidateArcs
 = 0;

3884 for (int 
	gj
 = 
i
 + 1; j < 
	gnoArcs
; j++)

3886 if (
	gtaken
[
j
])

3888 if (
	garcs
[
j
].
	gsegmentNo
 != 
arcs
[
i
].
segmentNo
)

3890 if (
	garcs
[
j
].
	gturn
 != 
Turn
)

3893 double 
	gminR
 = 
MIN
(
R
, 
arcs
[
j
].
r
);

3894 double 
	gradiusDiffThreshold
 = 
minR
 * 2.5;

3896 double 
	gdiff
 = 
fabs
(
R
 - 
arcs
[
j
].
r
);

3897 if (
	gdiff
 > 
	gradiusDiffThreshold
)

3901 if (
	gangles
.
overlap
(
arcs
[
j
].
sTheta
, arcs[j].
eTheta
) >= 0.75)

3906 double 
	gdx
 = 
SX
 - 
arcs
[
j
].
sx
;

3907 double 
	gdy
 = 
SY
 - 
arcs
[
j
].
sy
;

3908 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3909 int 
	gwhich
 = 1;

3912 
	gdx
 = 
SX
 - 
arcs
[
j
].
ex
;

3913 
	gdy
 = 
SY
 - 
arcs
[
j
].
ey
;

3914 double 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3916 if (
	gd2
 < 
	gd
)

3918 
	gd
 = 
d2
;

3919 
	gwhich
 = 2;

3923 
	gdx
 = 
EX
 - 
arcs
[
j
].
sx
;

3924 
	gdy
 = 
EY
 - 
arcs
[
j
].
sy
;

3925 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3927 if (
	gd2
 < 
	gd
)

3929 
	gd
 = 
d2
;

3930 
	gwhich
 = 3;

3934 
	gdx
 = 
EX
 - 
arcs
[
j
].
ex
;

3935 
	gdy
 = 
EY
 - 
arcs
[
j
].
ey
;

3936 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

3938 if (
	gd2
 < 
	gd
)

3940 
	gd
 = 
d2
;

3941 
	gwhich
 = 4;

3945 double 
	gmaxDistanceBetweenEndpoints
 = 5;

3946 if (
	gd
 > 
	gmaxDistanceBetweenEndpoints
)

3950 int 
	gindex
 = 
noCandidateArcs
 - 1;

3951 while (
	gindex
 >= 0)

3953 if (
candidateArcs
[
index
].
dist
 < 
d
)

3956 
	gcandidateArcs
[
index
 + 1] = 
candidateArcs
[index];

3957 
	gindex
--;

3961 
	gindex
++;

3962 
	gcandidateArcs
[
index
].
	garcNo
 = 
j
;

3963 
	gcandidateArcs
[
index
].
	gwhich
 = 
which
;

3964 
	gcandidateArcs
[
index
].
	gdist
 = 
d
;

3965 
	gnoCandidateArcs
++;

3969 if (
	gnoCandidateArcs
 > 0)

3971 for (int 
	gj
 = 0; j < 
	gnoCandidateArcs
; j++)

3973 int 
	gCandidateArcNo
 = 
candidateArcs
[
j
].
arcNo
;

3974 int 
	gWhich
 = 
candidateArcs
[
j
].
which
;

3976 int 
	gnoPixelsSave
 = 
noPixels
;

3977 
memcpy
(
x
 + 
noPixels
, 
arcs
[
CandidateArcNo
].x, arcs[CandidateArcNo].noPixels * sizeof(double));

3978 
memcpy
(
y
 + 
noPixels
, 
arcs
[
CandidateArcNo
].y, arcs[CandidateArcNo].noPixels * sizeof(double));

3979 
	gnoPixels
 += 
arcs
[
CandidateArcNo
].
noPixels
;

3982 
EllipseEquation
 
	geq
;

3983 double 
	gellipseFitError
 = 1e10;

3984 if (
EllipseFit
(
x
, 
y
, 
noPixels
, &
eq
))

3985 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
x
, 
y
, 
noPixels
);

3987 if (
	gellipseFitError
 > 
	gELLIPSE_ERROR
)

3990 
	gnoPixels
 = 
noPixelsSave
;

3995 
	gextendedArc
 = 
true
;

3996 
	gEllipseEqValid
 = 
true
;

3997 
	gEq
 = 
eq
;

3998 
	gEllipseFitError
 = 
ellipseFitError
;

3999 
	gNoPixels
 = 
noPixels
;

4001 
	gtaken
[
CandidateArcNo
] = 
true
;

4002 
	gtaken
[
i
] = 
true
;

4004 
	gR
 = (
R
 + 
arcs
[
CandidateArcNo
].
r
) / 2.0;

4006 
	gangles
.
set
(
arcs
[
CandidateArcNo
].
sTheta
, arcs[CandidateArcNo].
eTheta
);

4009 switch (
	gWhich
)

4013 
SX
 = 
EX
, 
	gSY
 = 
EY
;

4014 
	gEX
 = 
arcs
[
CandidateArcNo
].
ex
;

4015 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

4016 if (
	gTurn
 == 1)

4017 
Turn
 = -1;

4019 
	gTurn
 = 1;

4024 
SX
 = 
EX
, 
	gSY
 = 
EY
;

4025 
	gEX
 = 
arcs
[
CandidateArcNo
].
sx
;

4026 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

4027 if (
	gTurn
 == 1)

4028 
Turn
 = -1;

4030 
	gTurn
 = 1;

4035 
EX
 = 
arcs
[
CandidateArcNo
].
ex
;

4036 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

4041 
EX
 = 
arcs
[
CandidateArcNo
].
sx
;

4042 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

4051 if (
	gextendedArc
 == 
false
)

4055 if (
	gEllipseEqValid
 == 
false
)

4058 
edarcs3
->
arcs
[edarcs3->
noArcs
++] = arcs[
i
];

4063 double 
	gsTheta
, 
	geTheta
;

4064 
	gangles
.
computeStartEndTheta
(
sTheta
, 
eTheta
);

4066 double 
	gXC
, 
	gYC
, 
	gCircleFitError
;

4067 
CircleFit
(
x
, 
y
, 
NoPixels
, &
XC
, &
YC
, &
R
, &
CircleFitError
);

4069 double 
	gcoverage
 = 
ArcLength
(
sTheta
, 
eTheta
) / 
	gCV_2PI
;

4070 if ((
	gcoverage
 >= 
FULL_CIRCLE_RATIO
 && 
CircleFitError
 <= 
LONG_ARC_ERROR
))

4071 
addCircle
(
circles1
, 
noCircles1
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
x
, 
y
, 
NoPixels
);

4073 
addArc
(
edarcs3
->
arcs
, edarcs3->
noArcs
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
sTheta
, 
eTheta
, 
Turn
, arcs[
i
].
segmentNo
, &
Eq
, 
EllipseFitError
, 
SX
, 
SY
, 
EX
, 
EY
, 
x
, 
y
, 
NoPixels
, 
angles
.
overlapRatio
());

4076 
	gbm
->
move
(
NoPixels
);

4080 
	gdelete
[] 
	gtaken
;

4081 
	gdelete
[] 
	gcandidateArcs
;

4084 void 
	gEdgeDrawingImpl
::
JoinArcs3
()

4086 
AngleSet
 
angles
;

4089 
sortArc
(
edarcs3
->
arcs
, edarcs3->
noArcs
);

4091 int 
	gnoArcs
 = 
edarcs3
->
noArcs
;

4092 
MyArc
* 
	garcs
 = 
edarcs3
->
arcs
;

4094 
bool
* 
	gtaken
 = 
new
 bool[
noArcs
];

4095 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

4096 
	gtaken
[
i
] = 
false
;

4098 struct 
	sCandidateArc


4100 int 
	garcNo
;

4101 int 
	gwhich
;

4102 double 
	gdist
;

4105 
CandidateArc
* 
	gcandidateArcs
 = 
new
 CandidateArc[
noArcs
];

4106 int 
	gnoCandidateArcs
;

4108 for (int 
	gi
 = 0; i < 
	gnoArcs
; i++)

4110 if (
	gtaken
[
i
])

4114 
bool
 
	gEllipseEqValid
 = 
false
;

4115 
EllipseEquation
 
	gEq
;

4116 double 
EllipseFitError
(0);

4118 double 
	gR
 = 
arcs
[
i
].
r
;

4119 int 
	gTurn
 = 
arcs
[
i
].
turn
;

4120 int 
	gNoPixels
 = 
arcs
[
i
].
noPixels
;

4122 int 
	gSX
 = 
arcs
[
i
].
sx
;

4123 int 
	gSY
 = 
arcs
[
i
].
sy
;

4124 int 
	gEX
 = 
arcs
[
i
].
ex
;

4125 int 
	gEY
 = 
arcs
[
i
].
ey
;

4128 int 
	gnoPixels
 = 
arcs
[
i
].
noPixels
;

4130 double* 
	gx
 = 
bm
->
getX
();

4131 double* 
	gy
 = 
bm
->
getY
();

4132 
memcpy
(
x
, 
arcs
[
i
].x, 
noPixels
 * sizeof(double));

4133 
memcpy
(
y
, 
arcs
[
i
].y, 
noPixels
 * sizeof(double));

4135 
	gangles
.
clear
();

4136 
	gangles
.
set
(
arcs
[
i
].
sTheta
, arcs[i].
eTheta
);

4140 
bool
 
	gextendedArc
 = 
false
;

4143 
	gnoCandidateArcs
 = 0;

4145 for (int 
	gj
 = 
i
 + 1; j < 
	gnoArcs
; j++)

4147 if (
	gtaken
[
j
])

4156 double 
	gminR
 = 
MIN
(
R
, 
arcs
[
j
].
r
);

4157 double 
	gdiff
 = 
fabs
(
R
 - 
arcs
[
j
].
r
);

4158 if (
	gdiff
 > 
	gminR
)

4162 if (
	gangles
.
overlap
(
arcs
[
j
].
sTheta
, arcs[j].
eTheta
) >= 0.50)

4167 double 
	gdx
 = 
SX
 - 
arcs
[
j
].
sx
;

4168 double 
	gdy
 = 
SY
 - 
arcs
[
j
].
sy
;

4169 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

4170 int 
	gwhich
 = 1;

4173 
	gdx
 = 
SX
 - 
arcs
[
j
].
ex
;

4174 
	gdy
 = 
SY
 - 
arcs
[
j
].
ey
;

4175 double 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

4177 if (
	gd2
 < 
	gd
)

4179 
	gd
 = 
d2
;

4180 
	gwhich
 = 2;

4184 
	gdx
 = 
EX
 - 
arcs
[
j
].
sx
;

4185 
	gdy
 = 
EY
 - 
arcs
[
j
].
sy
;

4186 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

4188 if (
	gd2
 < 
	gd
)

4190 
	gd
 = 
d2
;

4191 
	gwhich
 = 3;

4195 
	gdx
 = 
EX
 - 
arcs
[
j
].
ex
;

4196 
	gdy
 = 
EY
 - 
arcs
[
j
].
ey
;

4197 
	gd2
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

4199 if (
	gd2
 < 
	gd
)

4201 
	gd
 = 
d2
;

4202 
	gwhich
 = 4;

4206 if (
	gdiff
 <= 0.50 * 
minR
)

4208 if (
d
 > 
minR
 * 0.75)

4211 else if (
	gdiff
 <= 0.75 * 
minR
)

4213 if (
d
 > 
minR
 * 0.50)

4216 else if (
	gdiff
 <= 1.00 * 
minR
)

4218 if (
d
 > 
minR
 * 0.25)

4225 
	gd
 += 
diff
;

4228 if (
	gwhich
 == 2 || 
which
 == 3)

4230 if (
Turn
 != 
arcs
[
j
].
turn
)

4235 if (
	gTurn
 == 
arcs
[
j
].
turn
)

4240 int 
	gindex
 = 
noCandidateArcs
 - 1;

4241 while (
	gindex
 >= 0)

4243 if (
candidateArcs
[
index
].
dist
 < 
d
)

4246 
	gcandidateArcs
[
index
 + 1] = 
candidateArcs
[index];

4247 
	gindex
--;

4251 
	gindex
++;

4252 
	gcandidateArcs
[
index
].
	garcNo
 = 
j
;

4253 
	gcandidateArcs
[
index
].
	gwhich
 = 
which
;

4254 
	gcandidateArcs
[
index
].
	gdist
 = 
d
;

4255 
	gnoCandidateArcs
++;

4259 if (
	gnoCandidateArcs
 > 0)

4261 for (int 
	gj
 = 0; j < 
	gnoCandidateArcs
; j++)

4263 int 
	gCandidateArcNo
 = 
candidateArcs
[
j
].
arcNo
;

4264 int 
	gWhich
 = 
candidateArcs
[
j
].
which
;

4266 int 
	gnoPixelsSave
 = 
noPixels
;

4267 
memcpy
(
x
 + 
noPixels
, 
arcs
[
CandidateArcNo
].x, arcs[CandidateArcNo].noPixels * sizeof(double));

4268 
memcpy
(
y
 + 
noPixels
, 
arcs
[
CandidateArcNo
].y, arcs[CandidateArcNo].noPixels * sizeof(double));

4269 
	gnoPixels
 += 
arcs
[
CandidateArcNo
].
noPixels
;

4272 
EllipseEquation
 
	geq
;

4273 double 
	gellipseFitError
 = 1e10;

4274 if (
EllipseFit
(
x
, 
y
, 
noPixels
, &
eq
))

4275 
	gellipseFitError
 = 
ComputeEllipseError
(&
eq
, 
x
, 
y
, 
noPixels
);

4277 if (
	gellipseFitError
 > 
	gELLIPSE_ERROR
)

4280 
	gnoPixels
 = 
noPixelsSave
;

4285 
	gextendedArc
 = 
true
;

4286 
	gEllipseEqValid
 = 
true
;

4287 
	gEq
 = 
eq
;

4288 
	gEllipseFitError
 = 
ellipseFitError
;

4289 
	gNoPixels
 = 
noPixels
;

4291 
	gtaken
[
CandidateArcNo
] = 
true
;

4292 
	gtaken
[
i
] = 
true
;

4294 
	gR
 = (
R
 + 
arcs
[
CandidateArcNo
].
r
) / 2.0;

4296 
	gangles
.
set
(
arcs
[
CandidateArcNo
].
sTheta
, arcs[CandidateArcNo].
eTheta
);

4299 switch (
	gWhich
)

4303 
SX
 = 
EX
, 
	gSY
 = 
EY
;

4304 
	gEX
 = 
arcs
[
CandidateArcNo
].
ex
;

4305 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

4306 if (
	gTurn
 == 1)

4307 
Turn
 = -1;

4309 
	gTurn
 = 1;

4314 
SX
 = 
EX
, 
	gSY
 = 
EY
;

4315 
	gEX
 = 
arcs
[
CandidateArcNo
].
sx
;

4316 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

4317 if (
	gTurn
 == 1)

4318 
Turn
 = -1;

4320 
	gTurn
 = 1;

4325 
EX
 = 
arcs
[
CandidateArcNo
].
ex
;

4326 
	gEY
 = 
arcs
[
CandidateArcNo
].
ey
;

4331 
EX
 = 
arcs
[
CandidateArcNo
].
sx
;

4332 
	gEY
 = 
arcs
[
CandidateArcNo
].
sy
;

4340 if (
	gextendedArc
 == 
false
)

4344 if (
	gEllipseEqValid
 == 
false
)

4347 
edarcs4
->
arcs
[edarcs4->
noArcs
++] = arcs[
i
];

4352 double 
	gsTheta
, 
	geTheta
;

4353 
	gangles
.
computeStartEndTheta
(
sTheta
, 
eTheta
);

4355 double 
	gXC
, 
	gYC
, 
	gCircleFitError
;

4356 
CircleFit
(
x
, 
y
, 
NoPixels
, &
XC
, &
YC
, &
R
, &
CircleFitError
);

4358 double 
	gcoverage
 = 
ArcLength
(
sTheta
, 
eTheta
) / 
	gCV_2PI
;

4359 if ((
	gcoverage
 >= 
FULL_CIRCLE_RATIO
 && 
CircleFitError
 <= 
LONG_ARC_ERROR
))

4360 
addCircle
(
circles1
, 
noCircles1
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
x
, 
y
, 
NoPixels
);

4362 
addArc
(
edarcs4
->
arcs
, edarcs4->
noArcs
, 
XC
, 
YC
, 
R
, 
CircleFitError
, 
sTheta
, 
eTheta
, 
Turn
, arcs[
i
].
segmentNo
, &
Eq
, 
EllipseFitError
, 
SX
, 
SY
, 
EX
, 
EY
, 
x
, 
y
, 
NoPixels
, 
angles
.
overlapRatio
());

4364 
	gbm
->
move
(
NoPixels
);

4368 
	gdelete
[] 
	gtaken
;

4369 
	gdelete
[] 
	gcandidateArcs
;

4372 void 
	gEdgeDrawingImpl
::
addCircle
(
Circle
* 
circles
, int& 
noCircles
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, double* 
x
, double* 
y
, int 
noPixels
)

4374 
	gcircles
[
noCircles
].
	gxc
 = 
xc
;

4375 
	gcircles
[
noCircles
].
	gyc
 = 
yc
;

4376 
	gcircles
[
noCircles
].
	gr
 = 
r
;

4377 
	gcircles
[
noCircles
].
	gcircleFitError
 = 
circleFitError
;

4378 
	gcircles
[
noCircles
].
	gcoverRatio
 = 
noPixels
 / 
CV_2PI
 * 
r
;

4380 
	gcircles
[
noCircles
].
	gx
 = 
x
;

4381 
	gcircles
[
noCircles
].
	gy
 = 
y
;

4382 
	gcircles
[
noCircles
].
	gnoPixels
 = 
noPixels
;

4384 
	gcircles
[
noCircles
].
	gisEllipse
 = 
false
;

4386 
	gnoCircles
++;

4389 void 
	gEdgeDrawingImpl
::
addCircle
(
Circle
* 
circles
, int& 
noCircles
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, 
EllipseEquation
* 
pEq
, double 
ellipseFitError
, double* 
x
, double* 
y
, int 
noPixels
)

4391 
	gcircles
[
noCircles
].
	gxc
 = 
xc
;

4392 
	gcircles
[
noCircles
].
	gyc
 = 
yc
;

4393 
	gcircles
[
noCircles
].
	gr
 = 
r
;

4394 
	gcircles
[
noCircles
].
	gcircleFitError
 = 
circleFitError
;

4395 
	gcircles
[
noCircles
].
	gcoverRatio
 = 
noPixels
 / 
computeEllipsePerimeter
(
pEq
);

4397 
	gcircles
[
noCircles
].
	gx
 = 
x
;

4398 
	gcircles
[
noCircles
].
	gy
 = 
y
;

4399 
	gcircles
[
noCircles
].
	gnoPixels
 = 
noPixels
;

4401 
	gcircles
[
noCircles
].
	geq
 = *
pEq
;

4402 
	gcircles
[
noCircles
].
	gellipseFitError
 = 
ellipseFitError
;

4403 
	gcircles
[
noCircles
].
	gisEllipse
 = 
true
;

4405 
	gnoCircles
++;

4408 void 
	gEdgeDrawingImpl
::
sortCircles
(
Circle
* 
circles
, int 
noCircles
)

4410 for (int 
	gi
 = 0; i < 
	gnoCircles
 - 1; i++)

4412 int 
	gmax
 = 
i
;

4413 for (int 
	gj
 = 
i
 + 1; j < 
	gnoCircles
; j++)

4415 if (
	gcircles
[
j
].
	gr
 > circles[
max
].r)

4416 
	gmax
 = 
j
;

4419 if (
	gmax
 != 
i
)

4421 
Circle
 
t
 = 
circles
[
i
];

4422 
	gcircles
[
i
] = 
circles
[
max
];

4423 
	gcircles
[
max
] = 
t
;

4433 double 
	gEdgeDrawingImpl
::
computeEllipsePerimeter
(
EllipseEquation
* 
eq
)

4435 double 
mult
 = 1;

4437 double 
	gA
 = 
eq
->
A
() * 
mult
;

4438 double 
	gB
 = 
eq
->
B
() * 
mult
;

4439 double 
	gC
 = 
eq
->
C
() * 
mult
;

4440 double 
	gD
 = 
eq
->
D
() * 
mult
;

4441 double 
	gE
 = 
eq
->
E
() * 
mult
;

4442 double 
	gF
 = 
eq
->
F
() * 
mult
;

4444 double 
A2
(0), 
C2
(0), 
D2
(0), 
E2
(0), 
F2
(0), 
theta
(0);

4445 double 
	gD3
, 
	gE3
, 
	gF3
;

4446 double 
	gcX
, 
	gcY
, 
	ga
, 
	gb
;

4447 double 
	gh
;

4448 
bool
 
	grotation
 = 
false
;

4451 
	gB
 /= 
A
;

4452 
	gC
 /= 
A
;

4453 
	gD
 /= 
A
;

4454 
	gE
 /= 
A
;

4455 
	gF
 /= 
A
;

4456 
	gA
 /= 
A
;

4458 if (
	gB
 == 0)

4460 
A2
 = 
A
;

4461 
	gC2
 = 
C
;

4462 
	gD2
 = 
D
;

4463 
	gE2
 = 
E
;

4464 
	gF2
 = 
F
;

4467 else if (
	gB
 != 0)

4469 
rotation
 = 
true
;

4472 
	gtheta
 = 
atan
(
B
 / (
A
 - 
C
)) / 2;

4475 
	gA2
 = 0.5 * (
A
 * (1 + 
cos
(2 * 
theta
) + 
B
 * 
sin
(2 * theta) + 
C
 * (1 - cos(2 * theta))));

4477 
	gC2
 = 0.5 * (
A
 * (1 - 
cos
(2 * 
theta
) - 
B
 * 
sin
(2 * theta) + 
C
 * (1 + cos(2 * theta))));

4479 
	gD2
 = 
D
 * 
cos
(
theta
) + 
E
 * 
sin
(theta);

4481 
	gE2
 = -
D
 * 
sin
(
theta
) + 
E
 * 
cos
(theta);

4483 
	gF2
 = 
F
;

4487 
	gD3
 = 
D2
 / 
A2
;

4489 
	gE3
 = 
E2
 / 
C2
;

4491 
	gcX
 = -(
D3
 / 2);

4492 
	gcY
 = -(
E3
 / 2);

4494 
	gF3
 = 
A2
 * 
pow
(
cX
, 2.0) + 
C2
 * pow(
cY
, 2.0) - 
	gF2
;

4497 
	ga
 = 
sqrt
(
F3
 / 
A2
);

4499 
	gb
 = 
sqrt
(
F3
 / 
C2
);

4502 if (
	grotation
)

4504 double 
	gtmpX
 = 
cX
, 
	gtmpY
 = 
cY
;

4505 
	gcX
 = 
tmpX
 * 
cos
(
theta
) - 
tmpY
 * 
sin
(theta);

4506 
	gcY
 = 
tmpX
 * 
sin
(
theta
) + 
tmpY
 * 
cos
(theta);

4510 
	gh
 = 
pow
((
a
 - 
b
), 2.0) / pow((a + b), 2.0);

4513 double 
	gP2
 = 
CV_PI
 * (
a
 + 
b
) * (1 + 3 * 
h
 / (10 + 
sqrt
(4 - 3 * h)));

4515 return 
	gP2
;

4518 double 
	gEdgeDrawingImpl
::
ComputeEllipseError
(
EllipseEquation
* 
eq
, double* 
px
, double* 
py
, int 
noPoints
)

4520 double 
	gerror
 = 0;

4522 double 
	gA
 = 
eq
->
A
();

4523 double 
	gB
 = 
eq
->
B
();

4524 double 
	gC
 = 
eq
->
C
();

4525 double 
	gD
 = 
eq
->
D
();

4526 double 
	gE
 = 
eq
->
E
();

4527 double 
	gF
 = 
eq
->
F
();

4529 double 
	gxc
, 
	gyc
, 
	gmajor
, 
	gminor
;

4530 
ComputeEllipseCenterAndAxisLengths
(
eq
, &
xc
, &
yc
, &
major
, &
minor
);

4532 for (int 
	gi
 = 0; i < 
	gnoPoints
; i++)

4534 double 
	gdx
 = 
px
[
i
] - 
xc
;

4535 double 
	gdy
 = 
py
[
i
] - 
yc
;

4537 double 
	gmin
;

4538 double 
	gxs
;

4540 if (
fabs
(
dx
) > fabs(
dy
))

4543 double 
	gm
 = 
dy
 / 
dx
;

4544 double 
	gn
 = 
yc
 - 
m
 * 
xc
;

4547 double 
	ga
 = 
A
 + 
B
 * 
m
 + 
C
 * m * m;

4548 double 
	gb
 = 
B
 * 
n
 + 2 * 
C
 * 
m
 * n + 
D
 + 
E
 * m;

4549 double 
	gc
 = 
C
 * 
n
 * n + 
E
 * n + 
F
;

4550 double 
	gdet
 = 
b
 * b - 4 * 
a
 * 
c
;

4551 if (
	gdet
 < 0)

4552 
	gdet
 = 0;

4553 double 
	gx1
 = -(
b
 + 
sqrt
(
det
)) / (2 * 
a
);

4554 double 
	gx2
 = -(
b
 - 
sqrt
(
det
)) / (2 * 
a
);

4556 double 
	gy1
 = 
m
 * 
x1
 + 
n
;

4557 double 
	gy2
 = 
m
 * 
x2
 + 
n
;

4559 
	gdx
 = 
px
[
i
] - 
x1
;

4560 
	gdy
 = 
py
[
i
] - 
y1
;

4561 double 
	gd1
 = 
dx
 * dx + 
dy
 * dy;

4563 
	gdx
 = 
px
[
i
] - 
x2
;

4564 
	gdy
 = 
py
[
i
] - 
y2
;

4565 double 
	gd2
 = 
dx
 * dx + 
dy
 * dy;

4567 if (
	gd1
 < 
	gd2
)

4569 
	gmin
 = 
d1
;

4570 
	gxs
 = 
x1
;

4574 
	gmin
 = 
d2
;

4575 
	gxs
 = 
x2
;

4581 double 
	gm
 = 
dx
 / 
dy
;

4582 double 
	gn
 = 
xc
 - 
m
 * 
yc
;

4585 double 
	ga
 = 
A
 * 
m
 * m + 
B
 * m + 
C
;

4586 double 
	gb
 = 2 * 
A
 * 
m
 * 
n
 + 
B
 * n + 
D
 * m + 
E
;

4587 double 
	gc
 = 
A
 * 
n
 * n + 
D
 * n + 
F
;

4588 double 
	gdet
 = 
b
 * b - 4 * 
a
 * 
c
;

4589 if (
	gdet
 < 0)

4590 
	gdet
 = 0;

4591 double 
	gy1
 = -(
b
 + 
sqrt
(
det
)) / (2 * 
a
);

4592 double 
	gy2
 = -(
b
 - 
sqrt
(
det
)) / (2 * 
a
);

4594 double 
	gx1
 = 
m
 * 
y1
 + 
n
;

4595 double 
	gx2
 = 
m
 * 
y2
 + 
n
;

4597 
	gdx
 = 
px
[
i
] - 
x1
;

4598 
	gdy
 = 
py
[
i
] - 
y1
;

4599 double 
	gd1
 = 
dx
 * dx + 
dy
 * dy;

4601 
	gdx
 = 
px
[
i
] - 
x2
;

4602 
	gdy
 = 
py
[
i
] - 
y2
;

4603 double 
	gd2
 = 
dx
 * dx + 
dy
 * dy;

4605 if (
	gd1
 < 
	gd2
)

4607 
	gmin
 = 
d1
;

4608 
	gxs
 = 
x1
;

4612 
	gmin
 = 
d2
;

4613 
	gxs
 = 
x2
;

4618 double 
	gdelta
 = 0.5;

4619 double 
	gx
 = 
xs
;

4622 
	gx
 += 
delta
;

4624 double 
	ga
 = 
C
;

4625 double 
	gb
 = 
B
 * 
x
 + 
E
;

4626 double 
	gc
 = 
A
 * 
x
 * x + 
D
 * x + 
F
;

4627 double 
	gdet
 = 
b
 * b - 4 * 
a
 * 
c
;

4628 if (
	gdet
 < 0)

4629 
	gdet
 = 0;

4631 double 
	gy1
 = -(
b
 + 
sqrt
(
det
)) / (2 * 
a
);

4632 double 
	gy2
 = -(
b
 - 
sqrt
(
det
)) / (2 * 
a
);

4634 
	gdx
 = 
px
[
i
] - 
x
;

4635 
	gdy
 = 
py
[
i
] - 
y1
;

4636 double 
	gd1
 = 
dx
 * dx + 
dy
 * dy;

4638 
	gdy
 = 
py
[
i
] - 
y2
;

4639 double 
	gd2
 = 
dx
 * dx + 
dy
 * dy;

4641 if (
	gd1
 <= 
min
)

4643 
min
 = 
d1
;

4645 else if (
	gd2
 <= 
min
)

4647 
min
 = 
d2
;

4653 
	gx
 = 
xs
;

4656 
	gx
 -= 
delta
;

4658 double 
	ga
 = 
C
;

4659 double 
	gb
 = 
B
 * 
x
 + 
E
;

4660 double 
	gc
 = 
A
 * 
x
 * x + 
D
 * x + 
F
;

4661 double 
	gdet
 = 
b
 * b - 4 * 
a
 * 
c
;

4662 if (
	gdet
 < 0)

4663 
	gdet
 = 0;

4665 double 
	gy1
 = -(
b
 + 
sqrt
(
det
)) / (2 * 
a
);

4666 double 
	gy2
 = -(
b
 - 
sqrt
(
det
)) / (2 * 
a
);

4668 
	gdx
 = 
px
[
i
] - 
x
;

4669 
	gdy
 = 
py
[
i
] - 
y1
;

4670 double 
	gd1
 = 
dx
 * dx + 
dy
 * dy;

4672 
	gdy
 = 
py
[
i
] - 
y2
;

4673 double 
	gd2
 = 
dx
 * dx + 
dy
 * dy;

4675 if (
	gd1
 <= 
min
)

4677 
min
 = 
d1
;

4679 else if (
	gd2
 <= 
min
)

4681 
min
 = 
d2
;

4686 
	gerror
 += 
min
;

4689 
	gerror
 = 
sqrt
(
error
 / 
noPoints
);

4691 return 
	gerror
;

4695 double 
	gEdgeDrawingImpl
::
ComputeEllipseCenterAndAxisLengths
(
EllipseEquation
* 
eq
, double* 
pxc
, double* 
pyc
, double* 
pmajorAxisLength
, double* 
pminorAxisLength
)

4697 double 
	gmult
 = 1;

4699 double 
	gA
 = 
eq
->
A
() * 
mult
;

4700 double 
	gB
 = 
eq
->
B
() * 
mult
;

4701 double 
	gC
 = 
eq
->
C
() * 
mult
;

4702 double 
	gD
 = 
eq
->
D
() * 
mult
;

4703 double 
	gE
 = 
eq
->
E
() * 
mult
;

4704 double 
	gF
 = 
eq
->
F
() * 
mult
;

4706 double 
A2
(0), 
C2
(0), 
D2
(0), 
E2
(0), 
F2
(0), 
theta
(0);

4707 double 
	gD3
, 
	gE3
, 
	gF3
;

4708 double 
	gcX
, 
	gcY
, 
	ga
, 
	gb
;

4709 
bool
 
	grotation
 = 
false
;

4712 
	gB
 /= 
A
;

4713 
	gC
 /= 
A
;

4714 
	gD
 /= 
A
;

4715 
	gE
 /= 
A
;

4716 
	gF
 /= 
A
;

4717 
	gA
 /= 
A
;

4719 if (
	gB
 == 0)

4721 
A2
 = 
A
;

4722 
	gC2
 = 
C
;

4723 
	gD2
 = 
D
;

4724 
	gE2
 = 
E
;

4725 
	gF2
 = 
F
;

4727 else if (
	gB
 != 0)

4729 
rotation
 = 
true
;

4732 
	gtheta
 = 
atan
(
B
 / (
A
 - 
C
)) / 2;

4735 
	gA2
 = 0.5 * (
A
 * (1 + 
cos
(2 * 
theta
) + 
B
 * 
sin
(2 * theta) + 
C
 * (1 - cos(2 * theta))));

4737 
	gC2
 = 0.5 * (
A
 * (1 - 
cos
(2 * 
theta
) - 
B
 * 
sin
(2 * theta) + 
C
 * (1 + cos(2 * theta))));

4739 
	gD2
 = 
D
 * 
cos
(
theta
) + 
E
 * 
sin
(theta);

4741 
	gE2
 = -
D
 * 
sin
(
theta
) + 
E
 * 
cos
(theta);

4743 
	gF2
 = 
F
;

4747 
	gD3
 = 
D2
 / 
A2
;

4749 
	gE3
 = 
E2
 / 
C2
;

4751 
	gcX
 = -(
D3
 / 2);

4752 
	gcY
 = -(
E3
 / 2);

4754 
	gF3
 = 
A2
 * 
pow
(
cX
, 2.0) + 
C2
 * pow(
cY
, 2.0) - 
	gF2
;

4757 
	ga
 = 
sqrt
(
F3
 / 
A2
);

4759 
	gb
 = 
sqrt
(
F3
 / 
C2
);

4762 if (
	grotation
)

4764 double 
	gtmpX
 = 
cX
, 
	gtmpY
 = 
cY
;

4765 
	gcX
 = 
tmpX
 * 
cos
(
theta
) - 
tmpY
 * 
sin
(theta);

4766 
	gcY
 = 
tmpX
 * 
sin
(
theta
) + 
tmpY
 * 
cos
(theta);

4769 *
	gpxc
 = 
cX
;

4770 *
	gpyc
 = 
cY
;

4772 *
	gpmajorAxisLength
 = 
a
;

4773 *
	gpminorAxisLength
 = 
b
;

4775 return 
	gtheta
;

4782 void 
	gEdgeDrawingImpl
::
ComputeEllipsePoints
(double* 
pvec
, double* 
px
, double* 
py
, int 
noPoints
)

4784 int 
	gnpts
 = 
noPoints
 / 2;

4786 double** 
	gu
 = 
AllocateMatrix
(3, 
npts
 + 1);

4787 double** 
	gAiu
 = 
AllocateMatrix
(3, 
npts
 + 1);

4788 double** 
	gL
 = 
AllocateMatrix
(3, 
npts
 + 1);

4789 double** 
	gB
 = 
AllocateMatrix
(3, 
npts
 + 1);

4790 double** 
	gXpos
 = 
AllocateMatrix
(3, 
npts
 + 1);

4791 double** 
	gXneg
 = 
AllocateMatrix
(3, 
npts
 + 1);

4792 double** 
	gss1
 = 
AllocateMatrix
(3, 
npts
 + 1);

4793 double** 
	gss2
 = 
AllocateMatrix
(3, 
npts
 + 1);

4794 double* 
	glambda
 = 
new
 double[
npts
 + 1];

4795 double** 
	guAiu
 = 
AllocateMatrix
(3, 
npts
 + 1);

4796 double** 
	gA
 = 
AllocateMatrix
(3, 3);

4797 double** 
	gAi
 = 
AllocateMatrix
(3, 3);

4798 double** 
	gAib
 = 
AllocateMatrix
(3, 2);

4799 double** 
	gb
 = 
AllocateMatrix
(3, 2);

4800 double** 
	gr1
 = 
AllocateMatrix
(2, 2);

4801 double 
	gAo
, 
	gAx
, 
	gAy
, 
	gAxx
, 
	gAyy
, 
	gAxy
;

4802 double 
	gtheta
;

4803 int 
	gi
;

4804 int 
	gj
;

4805 double 
	gkk
;

4807 
memset
(
lambda
, 0, sizeof(double) * (
npts
 + 1));

4809 
	gAo
 = 
pvec
[6];

4810 
	gAx
 = 
pvec
[4];

4811 
	gAy
 = 
pvec
[5];

4812 
	gAxx
 = 
pvec
[1];

4813 
	gAyy
 = 
pvec
[3];

4814 
	gAxy
 = 
pvec
[2];

4816 
	gA
[1][1] = 
Axx
;

4817 
	gA
[1][2] = 
Axy
 / 2;

4818 
	gA
[2][1] = 
Axy
 / 2;

4819 
	gA
[2][2] = 
Ayy
;

4820 
	gb
[1][1] = 
Ax
;

4821 
	gb
[2][1] = 
Ay
;

4824 for (
	gi
 = 1, 
	gtheta
 = 0.0; i <= 
npts
; i++, theta += (
CV_PI
 / npts))

4826 
u
[1][
i
] = 
cos
(
theta
);

4827 
	gu
[2][
i
] = 
sin
(
theta
);

4830 
inverse
(
A
, 
Ai
, 2);

4832 
AperB
(
Ai
, 
b
, 
Aib
, 2, 2, 2, 1);

4833 
A_TperB
(
b
, 
Aib
, 
r1
, 2, 1, 2, 1);

4834 
	gr1
[1][1] = 
r1
[1][1] - 4 * 
Ao
;

4836 
AperB
(
Ai
, 
u
, 
Aiu
, 2, 2, 2, 
npts
);

4837 for (
	gi
 = 1; i <= 2; i++)

4838 for (
	gj
 = 1; j <= 
npts
; j++)

4839 
	guAiu
[
i
][
j
] = 
u
[i][j] * 
Aiu
[i][j];

4841 for (
	gj
 = 1; j <= 
npts
; j++)

4843 if ((
	gkk
 = (
r1
[1][1] / (
uAiu
[1][
j
] + uAiu[2][j]))) >= 0.0)

4844 
lambda
[
j
] = 
sqrt
(
kk
);

4846 
	glambda
[
j
] = -1.0;

4850 for (
	gj
 = 1; j <= 
npts
; j++)

4851 
	gL
[1][
j
] = 
L
[2][j] = 
lambda
[j];

4852 for (
	gj
 = 1; j <= 
npts
; j++)

4854 
	gB
[1][
j
] = 
b
[1][1];

4855 
	gB
[2][
j
] = 
b
[2][1];

4858 for (
	gj
 = 1; j <= 
npts
; j++)

4860 
	gss1
[1][
j
] = 0.5 * (
L
[1][j] * 
u
[1][j] - 
B
[1][j]);

4861 
	gss1
[2][
j
] = 0.5 * (
L
[2][j] * 
u
[2][j] - 
B
[2][j]);

4862 
	gss2
[1][
j
] = 0.5 * (-
L
[1][j] * 
u
[1][j] - 
B
[1][j]);

4863 
	gss2
[2][
j
] = 0.5 * (-
L
[2][j] * 
u
[2][j] - 
B
[2][j]);

4866 
AperB
(
Ai
, 
ss1
, 
Xpos
, 2, 2, 2, 
npts
);

4867 
AperB
(
Ai
, 
ss2
, 
Xneg
, 2, 2, 2, 
npts
);

4869 for (
	gj
 = 1; j <= 
npts
; j++)

4871 if (
	glambda
[
j
] == -1.0)

4873 
px
[
j
 - 1] = -1;

4874 
	gpy
[
j
 - 1] = -1;

4875 
	gpx
[
j
 - 1 + 
npts
] = -1;

4876 
	gpy
[
j
 - 1 + 
npts
] = -1;

4880 
	gpx
[
j
 - 1] = 
Xpos
[1][j];

4881 
	gpy
[
j
 - 1] = 
Xpos
[2][j];

4882 
	gpx
[
j
 - 1 + 
npts
] = 
Xneg
[1][j];

4883 
	gpy
[
j
 - 1 + 
npts
] = 
Xneg
[2][j];

4887 
DeallocateMatrix
(
u
, 3);

4888 
DeallocateMatrix
(
Aiu
, 3);

4889 
DeallocateMatrix
(
L
, 3);

4890 
DeallocateMatrix
(
B
, 3);

4891 
DeallocateMatrix
(
Xpos
, 3);

4892 
DeallocateMatrix
(
Xneg
, 3);

4893 
DeallocateMatrix
(
ss1
, 3);

4894 
DeallocateMatrix
(
ss2
, 3);

4895 
	gdelete
[] 
	glambda
;

4896 
DeallocateMatrix
(
uAiu
, 3);

4897 
DeallocateMatrix
(
A
, 3);

4898 
DeallocateMatrix
(
Ai
, 3);

4899 
DeallocateMatrix
(
Aib
, 3);

4900 
DeallocateMatrix
(
b
, 3);

4901 
DeallocateMatrix
(
r1
, 2);

4910 void 
	gEdgeDrawingImpl
::
joinLastTwoArcs
(
MyArc
* 
arcs
, int& 
noArcs
)

4912 if (
	gnoArcs
 < 2)

4915 int 
	gprev
 = 
noArcs
 - 2;

4916 int 
	glast
 = 
noArcs
 - 1;

4918 if (
	garcs
[
prev
].
	gsegmentNo
 != 
arcs
[
last
].
segmentNo
)

4920 if (
	garcs
[
prev
].
	gturn
 != 
arcs
[
last
].
turn
)

4922 if (
	garcs
[
prev
].
	gisEllipse
 || arcs[
last
].isEllipse)

4926 double 
	gminR
 = 
MIN
(
arcs
[
prev
].
r
, arcs[
last
].r);

4927 double 
	gradiusDiffThreshold
 = 
minR
 * 0.25;

4929 double 
	gdiff
 = 
fabs
(
arcs
[
prev
].
r
 - arcs[
last
].r);

4930 if (
	gdiff
 > 
	gradiusDiffThreshold
)

4934 double 
	gdx
 = 
arcs
[
prev
].
ex
 - arcs[
last
].
sx
;

4935 double 
	gdy
 = 
arcs
[
prev
].
ey
 - arcs[
last
].
sy
;

4936 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy);

4938 double 
	gendPointDiffThreshold
 = 10;

4939 if (
	gd
 > 
	gendPointDiffThreshold
)

4943 int 
	gnoPixels
 = 
arcs
[
prev
].
noPixels
 + arcs[
last
].noPixels;

4945 double 
	gxc
, 
	gyc
, 
	gr
, 
	gcircleFitError
;

4946 
CircleFit
(
arcs
[
prev
].
x
, arcs[prev].
y
, 
noPixels
, &
xc
, &
yc
, &
r
, &
circleFitError
);

4948 if (
	gcircleFitError
 <= 
LONG_ARC_ERROR
)

4950 
arcs
[
prev
].
noPixels
 = noPixels;

4951 
	garcs
[
prev
].
	gcircleFitError
 = 
circleFitError
;

4953 
	garcs
[
prev
].
	gxc
 = 
xc
;

4954 
	garcs
[
prev
].
	gyc
 = 
yc
;

4955 
	garcs
[
prev
].
	gr
 = 
r
;

4956 
	garcs
[
prev
].
	gex
 = 
arcs
[
last
].
ex
;

4957 
	garcs
[
prev
].
	gey
 = 
arcs
[
last
].
ey
;

4959 
AngleSet
 
	gangles
;

4960 
	gangles
.
set
(
arcs
[
prev
].
sTheta
, arcs[prev].
eTheta
);

4961 
	gangles
.
set
(
arcs
[
last
].
sTheta
, arcs[last].
eTheta
);

4962 
	gangles
.
computeStartEndTheta
(
arcs
[
prev
].
sTheta
, arcs[prev].
eTheta
);

4964 
	garcs
[
prev
].
	gcoverRatio
 = 
ArcLength
(
arcs
[prev].
sTheta
, arcs[prev].
eTheta
) / (
	gCV_2PI
);

4966 
	gnoArcs
--;

4974 void 
	gEdgeDrawingImpl
::
addArc
(
MyArc
* 
arcs
, int& 
noArcs
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, double 
sTheta
, double 
eTheta
, int 
turn
, int 
segmentNo
, int 
sx
, int 
sy
, int 
ex
, int 
ey
, double* 
x
, double* 
y
, int 
noPixels
, double 
overlapRatio
)

4976 
CV_UNUSED
(
overlapRatio
);

4977 
	garcs
[
noArcs
].
	gxc
 = 
xc
;

4978 
	garcs
[
noArcs
].
	gyc
 = 
yc
;

4979 
	garcs
[
noArcs
].
	gr
 = 
r
;

4980 
	garcs
[
noArcs
].
	gcircleFitError
 = 
circleFitError
;

4982 
	garcs
[
noArcs
].
	gsTheta
 = 
sTheta
;

4983 
	garcs
[
noArcs
].
	geTheta
 = 
eTheta
;

4984 
	garcs
[
noArcs
].
	gcoverRatio
 = 
ArcLength
(
sTheta
, 
eTheta
) / 
	gCV_2PI
;

4986 
	garcs
[
noArcs
].
	gturn
 = 
turn
;

4988 
	garcs
[
noArcs
].
	gsegmentNo
 = 
segmentNo
;

4990 
	garcs
[
noArcs
].
	gisEllipse
 = 
false
;

4992 
	garcs
[
noArcs
].
	gsx
 = 
sx
;

4993 
	garcs
[
noArcs
].
	gsy
 = 
sy
;

4994 
	garcs
[
noArcs
].
	gex
 = 
ex
;

4995 
	garcs
[
noArcs
].
	gey
 = 
ey
;

4997 
	garcs
[
noArcs
].
	gx
 = 
x
;

4998 
	garcs
[
noArcs
].
	gy
 = 
y
;

4999 
	garcs
[
noArcs
].
	gnoPixels
 = 
noPixels
;

5001 
	gnoArcs
++;

5004 
joinLastTwoArcs
(
arcs
, 
noArcs
);

5010 void 
	gEdgeDrawingImpl
::
addArc
(
MyArc
* 
arcs
, int& 
noArcs
, double 
xc
, double 
yc
, double 
r
, double 
circleFitError
, double 
sTheta
, double 
eTheta
, int 
turn
, int 
segmentNo
, 
EllipseEquation
* 
pEq
, double 
ellipseFitError
, int 
sx
, int 
sy
, int 
ex
, int 
ey
, double* 
x
, double* 
y
, int 
noPixels
, double 
overlapRatio
)

5012 
	garcs
[
noArcs
].
	gxc
 = 
xc
;

5013 
	garcs
[
noArcs
].
	gyc
 = 
yc
;

5014 
	garcs
[
noArcs
].
	gr
 = 
r
;

5015 
	garcs
[
noArcs
].
	gcircleFitError
 = 
circleFitError
;

5017 
	garcs
[
noArcs
].
	gsTheta
 = 
sTheta
;

5018 
	garcs
[
noArcs
].
	geTheta
 = 
eTheta
;

5019 
	garcs
[
noArcs
].
	gcoverRatio
 = (double)((1.0 - 
overlapRatio
) * 
noPixels
) / 
computeEllipsePerimeter
(
pEq
);

5020 
	garcs
[
noArcs
].
	gturn
 = 
turn
;

5022 
	garcs
[
noArcs
].
	gsegmentNo
 = 
segmentNo
;

5024 
	garcs
[
noArcs
].
	gisEllipse
 = 
true
;

5025 
	garcs
[
noArcs
].
	geq
 = *
pEq
;

5026 
	garcs
[
noArcs
].
	gellipseFitError
 = 
ellipseFitError
;

5028 
	garcs
[
noArcs
].
	gsx
 = 
sx
;

5029 
	garcs
[
noArcs
].
	gsy
 = 
sy
;

5030 
	garcs
[
noArcs
].
	gex
 = 
ex
;

5031 
	garcs
[
noArcs
].
	gey
 = 
ey
;

5033 
	garcs
[
noArcs
].
	gx
 = 
x
;

5034 
	garcs
[
noArcs
].
	gy
 = 
y
;

5035 
	garcs
[
noArcs
].
	gnoPixels
 = 
noPixels
;

5037 
	gnoArcs
++;

5043 void 
	gEdgeDrawingImpl
::
ComputeStartAndEndAngles
(double 
xc
, double 
yc
, double 
r
, double* 
x
, double* 
y
, int 
len
, double* 
psTheta
, double* 
peTheta
)

5045 double 
	gsx
 = 
x
[0];

5046 double 
	gsy
 = 
y
[0];

5047 double 
	gex
 = 
x
[
len
 - 1];

5048 double 
	gey
 = 
y
[
len
 - 1];

5049 double 
	gmx
 = 
x
[
len
 / 2];

5050 double 
	gmy
 = 
y
[
len
 / 2];

5052 double 
	gd
 = (
sx
 - 
xc
) / 
r
;

5053 if (
	gd
 > 1.0)

5054 
	gd
 = 1.0;

5055 else if (
	gd
 < -1.0)

5056 
	gd
 = -1.0;

5057 double 
	gtheta1
 = 
acos
(
d
);

5059 double 
	gsTheta
;

5060 if (
	gsx
 >= 
xc
)

5062 if (
sy
 >= 
yc
)

5065 
sTheta
 = 
theta1
;

5070 
	gsTheta
 = 
CV_2PI
 - 
theta1
;

5075 if (
	gsy
 >= 
yc
)

5078 
sTheta
 = 
theta1
;

5083 
	gsTheta
 = 
CV_2PI
 - 
theta1
;

5087 
	gd
 = (
ex
 - 
xc
) / 
r
;

5088 if (
	gd
 > 1.0)

5089 
	gd
 = 1.0;

5090 else if (
	gd
 < -1.0)

5091 
	gd
 = -1.0;

5092 
	gtheta1
 = 
acos
(
d
);

5094 double 
	geTheta
;

5095 if (
	gex
 >= 
xc
)

5097 if (
ey
 >= 
yc
)

5100 
eTheta
 = 
theta1
;

5105 
	geTheta
 = 
CV_2PI
 - 
theta1
;

5110 if (
	gey
 >= 
yc
)

5113 
eTheta
 = 
theta1
;

5118 
	geTheta
 = 
CV_2PI
 - 
theta1
;

5123 double 
	gcircumference
 = 
CV_2PI
 * 
r
;

5124 double 
	gratio
 = 
len
 / 
circumference
;

5126 if (
	gratio
 <= 0.25 || 
ratio
 >= 0.75)

5128 double 
angle1
, 
angle2
;

5130 if (
	geTheta
 > 
	gsTheta
)

5132 
	gangle1
 = 
eTheta
 - 
sTheta
;

5133 
	gangle2
 = 
CV_2PI
 - 
eTheta
 + 
sTheta
;

5137 
	gangle1
 = 
sTheta
 - 
eTheta
;

5138 
	gangle2
 = 
CV_2PI
 - 
sTheta
 + 
eTheta
;

5141 
	gangle1
 = 
angle1
 / 
CV_2PI
;

5142 
	gangle2
 = 
angle2
 / 
CV_2PI
;

5144 double 
	gdiff1
 = 
fabs
(
ratio
 - 
angle1
);

5145 double 
	gdiff2
 = 
fabs
(
ratio
 - 
angle2
);

5147 if (
	gdiff1
 < 
	gdiff2
)

5150 if (
	geTheta
 > 
	gsTheta
)

5156 double 
	gtmp
 = 
sTheta
;

5157 
	gsTheta
 = 
eTheta
;

5158 
	geTheta
 = 
tmp
;

5164 if (
	geTheta
 > 
	gsTheta
)

5166 double 
	gtmp
 = 
sTheta
;

5167 
	gsTheta
 = 
eTheta
;

5168 
	geTheta
 = 
tmp
;

5174 double 
	gv1x
 = 
mx
 - 
sx
;

5175 double 
	gv1y
 = 
my
 - 
sy
;

5176 double 
	gv2x
 = 
ex
 - 
mx
;

5177 double 
	gv2y
 = 
ey
 - 
my
;

5180 double 
	gcross
 = 
v1x
 * 
v2y
 - 
v1y
 * 
v2x
;

5181 if (
	gcross
 < 0)

5184 double 
	gtmp
 = 
sTheta
;

5185 
	gsTheta
 = 
eTheta
;

5186 
	geTheta
 = 
tmp
;

5190 double 
	gdiff
 = 
fabs
(
sTheta
 - 
eTheta
);

5191 if (
	gdiff
 < (
	gCV_2PI
 / 120))

5193 
	gsTheta
 = 0;

5194 
	geTheta
 = 6.26;

5198 if (
	gsTheta
 >= 6.26)

5199 
sTheta
 = 0;

5200 if (
	geTheta
 < 1.0 / 
	gCV_2PI
)

5201 
	geTheta
 = 6.28;

5203 *
	gpsTheta
 = 
sTheta
;

5204 *
	gpeTheta
 = 
eTheta
;

5207 void 
	gEdgeDrawingImpl
::
sortArc
(
MyArc
* 
arcs
, int 
noArcs
)

5209 for (int 
	gi
 = 0; i < 
	gnoArcs
 - 1; i++)

5211 int 
	gmax
 = 
i
;

5212 for (int 
	gj
 = 
i
 + 1; j < 
	gnoArcs
; j++)

5214 if (
	garcs
[
j
].
	gcoverRatio
 > arcs[
max
].coverRatio)

5215 
	gmax
 = 
j
;

5218 if (
	gmax
 != 
i
)

5220 
MyArc
 
t
 = 
arcs
[
i
];

5221 
	garcs
[
i
] = 
arcs
[
max
];

5222 
	garcs
[
max
] = 
t
;

5233 
bool
 
	gEdgeDrawingImpl
::
CircleFit
(double* 
x
, double* 
y
, int 
N
, double* 
pxc
, double* 
pyc
, double* 
pr
, double* 
pe
)

5235 *
	gpe
 = 1e20;

5236 if (
	gN
 < 3)

5237 return 
	gfalse
;

5239 double 
	gxAvg
 = 0;

5240 double 
	gyAvg
 = 0;

5242 for (int 
	gi
 = 0; i < 
	gN
; i++)

5244 
	gxAvg
 += 
x
[
i
];

5245 
	gyAvg
 += 
y
[
i
];

5248 
	gxAvg
 /= 
N
;

5249 
	gyAvg
 /= 
N
;

5251 double 
	gSuu
 = 0;

5252 double 
	gSuv
 = 0;

5253 double 
	gSvv
 = 0;

5254 double 
	gSuuu
 = 0;

5255 double 
	gSuvv
 = 0;

5256 double 
	gSvvv
 = 0;

5257 double 
	gSvuu
 = 0;

5259 for (int 
	gi
 = 0; i < 
	gN
; i++)

5261 double 
	gu
 = 
x
[
i
] - 
xAvg
;

5262 double 
	gv
 = 
y
[
i
] - 
yAvg
;

5264 
	gSuu
 += 
u
 * u;

5265 
	gSuv
 += 
u
 * 
v
;

5266 
	gSvv
 += 
v
 * v;

5267 
	gSuuu
 += 
u
 * u * u;

5268 
	gSuvv
 += 
u
 * 
v
 * v;

5269 
	gSvvv
 += 
v
 * v * v;

5270 
	gSvuu
 += 
v
 * 
u
 * u;

5281 double 
	gdetA
 = 
Suu
 * 
Svv
 - 
Suv
 * Suv;

5282 if (
	gdetA
 == 0)

5283 return 
false
;

5285 double 
	gb1
 = 0.5 * (
Suuu
 + 
Suvv
);

5286 double 
	gb2
 = 0.5 * (
Svvv
 + 
Svuu
);

5288 double 
	guc
 = (
Svv
 * 
b1
 - 
Suv
 * 
b2
) / 
detA
;

5289 double 
	gvc
 = (
Suu
 * 
b2
 - 
Suv
 * 
b1
) / 
detA
;

5291 double 
	gR
 = 
sqrt
(
uc
 * uc + 
vc
 * vc + (
Suu
 + 
Svv
) / 
N
);

5293 *
	gpxc
 = 
uc
 + 
xAvg
;

5294 *
	gpyc
 = 
vc
 + 
yAvg
;

5297 double 
	gerror
 = 0;

5298 for (int 
	gi
 = 0; i < 
	gN
; i++)

5300 double 
	gdx
 = 
x
[
i
] - *
pxc
;

5301 double 
	gdy
 = 
y
[
i
] - *
pyc
;

5302 double 
	gd
 = 
sqrt
(
dx
 * dx + 
dy
 * dy) - 
R
;

5303 
	gerror
 += 
d
 * d;

5306 *
	gpr
 = 
R
;

5307 *
	gpe
 = 
sqrt
(
error
 / 
N
);

5309 return 
	gtrue
;

5316 void 
	gEdgeDrawingImpl
::
ComputeCirclePoints
(double 
xc
, double 
yc
, double 
r
, double* 
px
, double* 
py
, int* 
noPoints
)

5318 int 
	glen
 = (int)(
CV_2PI
 * 
r
 + 0.5);

5319 double 
	gangleInc
 = 
CV_2PI
 / 
len
;

5320 double 
	gangle
 = 0;

5322 int 
	gcount
 = 0;

5324 while (
	gangle
 < 
	gCV_2PI
)

5326 int 
	gx
 = (int)(
cos
(
angle
) * 
r
 + 
xc
 + 0.5);

5327 int 
	gy
 = (int)(
sin
(
angle
) * 
r
 + 
yc
 + 0.5);

5329 
	gangle
 += 
angleInc
;

5331 
	gpx
[
count
] = 
x
;

5332 
	gpy
[
count
] = 
y
;

5333 
	gcount
++;

5336 *
	gnoPoints
 = 
count
;

5339 
bool
 
	gEdgeDrawingImpl
::
EllipseFit
(double* 
x
, double* 
y
, int 
noPoints
, 
EllipseEquation
* 
pResult
, int 
mode
)

5341 double** 
	gD
 = 
AllocateMatrix
(
noPoints
 + 1, 7);

5342 double** 
	gS
 = 
AllocateMatrix
(7, 7);

5343 double** 
	gConst
 = 
AllocateMatrix
(7, 7);

5344 double** 
	gtemp
 = 
AllocateMatrix
(7, 7);

5345 double** 
	gL
 = 
AllocateMatrix
(7, 7);

5346 double** 
	gC
 = 
AllocateMatrix
(7, 7);

5348 double** 
	ginvL
 = 
AllocateMatrix
(7, 7);

5349 double* 
	gd
 = 
new
 double[7];

5350 double** 
	gV
 = 
AllocateMatrix
(7, 7);

5351 double** 
	gsol
 = 
AllocateMatrix
(7, 7);

5352 double 
	gtx
, 
	gty
;

5354 
memset
(
d
, 0, sizeof(double) * 7);

5356 switch (
	gmode
)

5358 case (
	gFPF
):

5359 
Const
[1][3] = -2;

5360 
	gConst
[2][2] = 1;

5361 
	gConst
[3][1] = -2;

5363 case (
	gBOOKSTEIN
):

5364 
Const
[1][1] = 2;

5365 
	gConst
[2][2] = 1;

5366 
	gConst
[3][3] = 2;

5369 if (
	gnoPoints
 < 6)

5370 return 
	gfalse
;

5373 for (int 
	gi
 = 1; i <= 
noPoints
; i++)

5375 
	gtx
 = 
x
[
i
 - 1];

5376 
	gty
 = 
y
[
i
 - 1];

5378 
	gD
[
i
][1] = 
tx
 * tx;

5379 
	gD
[
i
][2] = 
tx
 * 
ty
;

5380 
	gD
[
i
][3] = 
ty
 * ty;

5381 
	gD
[
i
][4] = 
tx
;

5382 
	gD
[
i
][5] = 
ty
;

5383 
	gD
[
i
][6] = 1.0;

5387 
A_TperB
(
D
, D, 
S
, 
noPoints
, 6, noPoints, 6);

5389 
choldc
(
S
, 6, 
L
);

5391 
inverse
(
L
, 
invL
, 6);

5393 
AperB_T
(
Const
, 
invL
, 
temp
, 6, 6, 6, 6);

5394 
AperB
(
invL
, 
temp
, 
C
, 6, 6, 6, 6);

5396 
jacobi
(
C
, 6, 
d
, 
V
);

5398 
A_TperB
(
invL
, 
V
, 
sol
, 6, 6, 6, 6);

5401 for (int 
	gj
 = 1; j <= 6; j++)

5403 double 
	gmod
 = 0.0;

5404 for (int 
	gi
 = 1; i <= 6; i++)

5405 
	gmod
 += 
sol
[
i
][
j
] * sol[i][j];

5406 for (int 
	gi
 = 1; i <= 6; i++)

5407 
	gsol
[
i
][
j
] /= 
sqrt
(
mod
);

5410 double 
	gzero
 = 10e-20;

5411 double 
	gminev
 = 10e+20;

5412 int 
	gsolind
 = 0;

5413 int 
	gi
;

5414 switch (
	gmode
)

5416 case (
	gBOOKSTEIN
):

5417 for (
i
 = 1; 
	gi
 <= 6; i++)

5418 if (
	gd
[
i
] < 
	gminev
 && 
fabs
(
d
[i]) > 
	gzero
)

5419 
	gsolind
 = 
i
;

5421 case (
	gFPF
):

5422 for (
i
 = 1; 
	gi
 <= 6; i++)

5423 if (
	gd
[
i
] < 0 && 
fabs
(
d
[i]) > 
	gzero
)

5424 
	gsolind
 = 
i
;

5427 
bool
 
	gvalid
 = 
true
;

5428 if (
	gsolind
 == 0)

5429 
valid
 = 
false
;

5431 if (
	gvalid
)

5434 for (int 
	gj
 = 1; j <= 6; j++)

5436 
	gpResult
->
	gcoeff
[
j
] = 
sol
[j][
solind
];

5440 
DeallocateMatrix
(
D
, 
noPoints
 + 1);

5441 
DeallocateMatrix
(
S
, 7);

5442 
DeallocateMatrix
(
Const
, 7);

5443 
DeallocateMatrix
(
temp
, 7);

5444 
DeallocateMatrix
(
L
, 7);

5445 
DeallocateMatrix
(
C
, 7);

5446 
DeallocateMatrix
(
invL
, 7);

5447 
	gdelete
[] 
	gd
;

5448 
DeallocateMatrix
(
V
, 7);

5449 
DeallocateMatrix
(
sol
, 7);

5451 if (
	gvalid
)

5453 int 
	glen
 = (int)
computeEllipsePerimeter
(
pResult
);

5454 if (
	glen
 <= 0 || 
len
 > 50000)

5455 
valid
 = 
false
;

5458 return 
	gvalid
;

5461 double** 
	gEdgeDrawingImpl
::
AllocateMatrix
(int 
noRows
, int 
noColumns
)

5463 double** 
	gm
 = 
new
 double* [
noRows
];

5465 for (int 
	gi
 = 0; i < 
	gnoRows
; i++)

5467 
	gm
[
i
] = 
new
 double[
noColumns
];

5468 
memset
(
m
[
i
], 0, sizeof(double) * 
noColumns
);

5471 return 
	gm
;

5474 void 
	gEdgeDrawingImpl
::
A_TperB
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
)

5476 
CV_UNUSED
(
_righB
);

5477 int 
	gp
, 
	gq
, 
	gl
;

5478 for (
	gp
 = 1; p <= 
_colA
; p++)

5479 for (
	gq
 = 1; q <= 
_colB
; q++)

5481 
	g_res
[
p
][
q
] = 0.0;

5482 for (
	gl
 = 1; l <= 
_righA
; l++)

5483 
	g_res
[
p
][
q
] = 
_res
[p][q] + 
A_
[
l
][p] * 
B_
[l][q];

5491 void 
	gEdgeDrawingImpl
::
choldc
(double** 
a
, int 
n
, double** 
l
)

5493 int 
	gi
, 
	gj
, 
	gk
;

5494 double 
	gsum
;

5495 double* 
	gp
 = 
new
 double[
n
 + 1];

5496 
memset
(
p
, 0, sizeof(double) * (
n
 + 1));

5498 for (
	gi
 = 1; i <= 
n
; i++)

5500 for (
	gj
 = 
i
; j <= 
n
; j++)

5502 for (
	gsum
 = 
a
[
i
][
j
], 
	gk
 = i - 1; k >= 1; k--)

5503 
	gsum
 -= 
a
[
i
][
k
] * a[
j
][k];

5504 if (
	gi
 == 
j
)

5506 if (
sum
 <= 0.0)

5510 
p
[
i
] = 
sqrt
(
sum
);

5514 
	ga
[
j
][
i
] = 
sum
 / 
p
[i];

5519 for (
	gi
 = 1; i <= 
n
; i++)

5521 for (
	gj
 = 
i
; j <= 
n
; j++)

5523 if (
	gi
 == 
j
)

5524 
l
[
i
][i] = 
p
[i];

5527 
	gl
[
j
][
i
] = 
a
[j][i];

5528 
	gl
[
i
][
j
] = 0.0;

5533 
	gdelete
[] 
	gp
;

5536 int 
	gEdgeDrawingImpl
::
inverse
(double** 
TB
, double** 
InvB
, int 
N
)

5538 int 
	gk
, 
	gi
, 
	gj
, 
	gp
, 
	gq
;

5539 double 
	gmult
;

5540 double 
	gD
, 
	gtemp
;

5541 double 
	gmaxpivot
;

5542 int 
	gnpivot
;

5543 double** 
	gB
 = 
AllocateMatrix
(
N
 + 1, N + 2);

5544 double** 
	gA
 = 
AllocateMatrix
(
N
 + 1, 2 * N + 2);

5545 double** 
	gC
 = 
AllocateMatrix
(
N
 + 1, N + 1);

5546 double 
	geps
 = 10e-20;

5548 for (
	gk
 = 1; k <= 
N
; k++)

5549 for (
	gj
 = 1; j <= 
N
; j++)

5550 
	gB
[
k
][
j
] = 
TB
[k][j];

5552 for (
	gk
 = 1; k <= 
N
; k++)

5554 for (
	gj
 = 1; j <= 
N
 + 1; j++)

5555 
	gA
[
k
][
j
] = 
B
[k][j];

5556 for (
	gj
 = 
N
 + 2; j <= 2 * N + 1; j++)

5557 
	gA
[
k
][
j
] = (double)0;

5558 
	gA
[
k
][k - 1 + 
N
 + 2] = (double)1;

5560 for (
	gk
 = 1; k <= 
N
; k++)

5562 
	gmaxpivot
 = 
fabs
((double)
A
[
k
][k]);

5563 
	gnpivot
 = 
k
;

5564 for (
	gi
 = 
k
; i <= 
N
; i++)

5565 if (
	gmaxpivot
 < 
fabs
((double)
A
[
i
][
k
]))

5567 
	gmaxpivot
 = 
fabs
((double)
A
[
i
][
k
]);

5568 
	gnpivot
 = 
i
;

5570 if (
	gmaxpivot
 >= 
eps
)

5572 if (
npivot
 != 
k
)

5573 for (
j
 = 
k
; 
	gj
 <= 2 * 
N
 + 1; j++)

5575 
	gtemp
 = 
A
[
npivot
][
j
];

5576 
	gA
[
npivot
][
j
] = 
A
[
k
][j];

5577 
	gA
[
k
][
j
] = 
temp
;

5579 
	gD
 = 
A
[
k
][k];

5580 for (
	gj
 = 2 * 
N
 + 1; j >= 
k
; j--)

5581 
	gA
[
k
][
j
] = 
A
[k][j] / 
D
;

5582 for (
	gi
 = 1; i <= 
N
; i++)

5584 if (
	gi
 != 
k
)

5586 
mult
 = 
A
[
i
][
k
];

5587 for (
	gj
 = 2 * 
N
 + 1; j >= 
k
; j--)

5588 
	gA
[
i
][
j
] = 
A
[i][j] - 
mult
 * A[
k
][j];

5594 
DeallocateMatrix
(
B
, 
N
 + 1);

5595 
DeallocateMatrix
(
A
, 
N
 + 1);

5596 
DeallocateMatrix
(
C
, 
N
 + 1);

5602 for (
	gk
 = 1, 
	gp
 = 1; k <= 
N
; k++, p++)

5603 for (
	gj
 = 
N
 + 2, 
	gq
 = 1; j <= 2 * N + 1; j++, q++)

5604 
	gInvB
[
p
][
q
] = 
A
[
k
][
j
];

5606 
DeallocateMatrix
(
B
, 
N
 + 1);

5607 
DeallocateMatrix
(
A
, 
N
 + 1);

5608 
DeallocateMatrix
(
C
, 
N
 + 1);

5613 void 
	gEdgeDrawingImpl
::
DeallocateMatrix
(double** 
m
, int 
noRows
)

5615 for (int 
	gi
 = 0; i < 
	gnoRows
; i++)

5616 
	gdelete
[] 
	gm
[
i
];

5617 
	gdelete
[] 
	gm
;

5620 void 
	gEdgeDrawingImpl
::
AperB_T
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
)

5622 
CV_UNUSED
(
_righB
);

5623 int 
	gp
, 
	gq
, 
	gl
;

5624 for (
	gp
 = 1; p <= 
_colA
; p++)

5625 for (
	gq
 = 1; q <= 
_colB
; q++)

5627 
	g_res
[
p
][
q
] = 0.0;

5628 for (
	gl
 = 1; l <= 
_righA
; l++)

5629 
	g_res
[
p
][
q
] = 
_res
[p][q] + 
A_
[p][
l
] * 
B_
[q][l];

5633 void 
	gEdgeDrawingImpl
::
AperB
(double** 
A_
, double** 
B_
, double** 
_res
, int 
_righA
, int 
_colA
, int 
_righB
, int 
_colB
)

5635 
CV_UNUSED
(
_righB
);

5636 int 
	gp
, 
	gq
, 
	gl
;

5637 for (
	gp
 = 1; p <= 
_righA
; p++)

5638 for (
	gq
 = 1; q <= 
_colB
; q++)

5640 
	g_res
[
p
][
q
] = 0.0;

5641 for (
	gl
 = 1; l <= 
_colA
; l++)

5642 
	g_res
[
p
][
q
] = 
_res
[p][q] + 
A_
[p][
l
] * 
B_
[l][q];

5646 void 
	gEdgeDrawingImpl
::
jacobi
(double** 
a
, int 
n
, double 
d
[], double** 
v
)

5648 int 
	gj
, 
	giq
, 
	gip
, 
	gi
;

5649 double 
	gtresh
, 
	gtheta
, 
	gtau
, 
	gt
, 
	gsm
, 
	gs
, 
	gh
, 
	gg
, 
	gc
;

5651 double* 
	gb
 = 
new
 double[
n
 + 1];

5652 double* 
	gz
 = 
new
 double[
n
 + 1];

5653 
memset
(
b
, 0, sizeof(double) * (
n
 + 1));

5654 
memset
(
z
, 0, sizeof(double) * (
n
 + 1));

5656 for (
	gip
 = 1; ip <= 
n
; ip++)

5658 for (
	giq
 = 1; iq <= 
n
; iq++)

5659 
	gv
[
ip
][
iq
] = 0.0;

5660 
	gv
[
ip
][ip] = 1.0;

5662 for (
	gip
 = 1; ip <= 
n
; ip++)

5664 
	gb
[
ip
] = 
d
[ip] = 
a
[ip][ip];

5665 
	gz
[
ip
] = 0.0;

5667 for (
	gi
 = 1; i <= 50; i++)

5669 
	gsm
 = 0.0;

5670 for (
	gip
 = 1; ip <= 
n
 - 1; ip++)

5672 for (
	giq
 = 
ip
 + 1; iq <= 
n
; iq++)

5673 
	gsm
 += 
fabs
(
a
[
ip
][
iq
]);

5675 if (
	gsm
 == 0.0)

5677 
delete
[] 
b
;

5678 
	gdelete
[] 
	gz
;

5681 if (
	gi
 < 4)

5682 
	gtresh
 = 0.2 * 
sm
 / (
n
 * n);

5684 
	gtresh
 = 0.0;

5685 for (
	gip
 = 1; ip <= 
n
 - 1; ip++)

5687 for (
	giq
 = 
ip
 + 1; iq <= 
n
; iq++)

5689 
	gg
 = 100.0 * 
fabs
(
a
[
ip
][
iq
]);

5691 if (
	gi
 > 4 && 
	gg
 == 0.0)

5692 
a
[
ip
][
iq
] = 0.0;

5693 else if (
fabs
(
a
[
ip
][
iq
]) > 
	gtresh
)

5695 
	gh
 = 
d
[
iq
] - d[
ip
];

5696 if (
	gg
 == 0.0)

5697 
t
 = (
a
[
ip
][
iq
]) / 
h
;

5700 
	gtheta
 = 0.5 * 
h
 / (
a
[
ip
][
iq
]);

5701 
	gt
 = 1.0 / (
fabs
(
theta
) + 
sqrt
(1.0 + theta * theta));

5702 if (
	gtheta
 < 0.0)

5703 
	gt
 = -
t
;

5705 
	gc
 = 1.0 / 
sqrt
(1 + 
t
 * t);

5706 
	gs
 = 
t
 * 
c
;

5707 
	gtau
 = 
s
 / (1.0 + 
c
);

5708 
	gh
 = 
t
 * 
a
[
ip
][
iq
];

5709 
	gz
[
ip
] -= 
h
;

5710 
	gz
[
iq
] += 
h
;

5711 
	gd
[
ip
] -= 
h
;

5712 
	gd
[
iq
] += 
h
;

5713 
	ga
[
ip
][
iq
] = 0.0;

5714 for (
	gj
 = 1; j <= 
ip
 - 1; j++)

5716 
ROTATE
(
a
, 
j
, 
ip
, j, 
iq
, 
tau
, 
s
);

5718 for (
	gj
 = 
ip
 + 1; j <= 
iq
 - 1; j++)

5720 
ROTATE
(
a
, 
ip
, 
j
, j, 
iq
, 
tau
, 
s
);

5722 for (
	gj
 = 
iq
 + 1; j <= 
n
; j++)

5724 
ROTATE
(
a
, 
ip
, 
j
, 
iq
, j, 
tau
, 
s
);

5726 for (
	gj
 = 1; j <= 
n
; j++)

5728 
ROTATE
(
v
, 
j
, 
ip
, j, 
iq
, 
tau
, 
s
);

5734 for (
	gip
 = 1; ip <= 
n
; ip++)

5736 
	gb
[
ip
] += 
z
[ip];

5737 
	gd
[
ip
] = 
b
[ip];

5738 
	gz
[
ip
] = 0.0;

5741 
	gdelete
[] 
	gb
;

5742 
	gdelete
[] 
	gz
;

5745 void 
	gEdgeDrawingImpl
::
ROTATE
(double** 
a
, int 
i
, int 
j
, int 
k
, int 
l
, double 
tau
, double 
s
)

5747 double 
	gg
, 
	gh
;

5748 
	gg
 = 
a
[
i
][
j
];

5749 
	gh
 = 
a
[
k
][
l
];

5750 
	ga
[
i
][
j
] = 
g
 - 
s
 * (
h
 + g * 
tau
);

5751 
	ga
[
k
][
l
] = 
h
 + 
s
 * (
g
 - h * 
tau
);

	@ximgproc/src/edge_drawing_common.hpp

5 #ifndef 
__OPENCV_EDGE_DRAWING_COMMON_HPP__


6 #define 
	#__OPENCV_EDGE_DRAWING_COMMON_HPP__


	)

8 #include 
	~<opencv2/core.hpp
>

10 #define 
	#EDGE_VERTICAL
 1

	)

11 #define 
	#EDGE_HORIZONTAL
 2

	)

13 #define 
	#ANCHOR_PIXEL
 254

	)

14 #define 
	#EDGE_PIXEL
 255

	)

16 #define 
	#LEFT
 1

	)

17 #define 
	#RIGHT
 2

	)

18 #define 
	#UP
 3

	)

19 #define 
	#DOWN
 4

	)

21 #define 
	#SOUTH_SOUTH
 0

	)

22 #define 
	#SOUTH_EAST
 1

	)

23 #define 
	#EAST_SOUTH
 2

	)

24 #define 
	#EAST_EAST
 3

	)

27 #define 
	#VERY_SHORT_ARC_ERROR
 0.40

28 #define 
	#SHORT_ARC_ERROR
 1.00

29 #define 
	#HALF_ARC_ERROR
 1.25

30 #define 
	#LONG_ARC_ERROR
 1.50

31 

	)

32 #define 
	#CANDIDATE_CIRCLE_RATIO1
 0.25

33 #define 
	#CANDIDATE_CIRCLE_RATIO2
 0.33

34 #define 
	#HALF_CIRCLE_RATIO
 0.50

35 #define 
	#FULL_CIRCLE_RATIO
 0.67

36 

	)

38 #define 
	#CANDIDATE_ELLIPSE_RATIO
 0.50

39 #define 
	#ELLIPSE_ERROR
 1.50

40 #define 
	#MAX_GRAD_VALUE
 128*256

	)

42 
using
 
namespace
 
	gstd
;

43 
using
 
namespace
 
	gcv
;

45 class 
	cNFALUT


47 
	mpublic
:

49 
NFALUT
(int 
size
, double 
_prob
, int 
_w
, int 
_h
);

50 ~
NFALUT
();

52 int* 
	mLUT
;

53 int 
	mLUTSize
;

55 double 
	mprob
;

56 int 
	mw
, 
	mh
;

58 
bool
 
checkValidationByNFA
(int 
n
, int 
k
);

59 static double 
myAtan2
(double 
yy
, double 
xx
);

61 
	mprivate
:

62 double 
nfa
(int 
n
, int 
k
);

63 static double 
Comb
(double 
n
, double 
k
);

66 
	gNFALUT
::
	$NFALUT
(int 
size
, double 
_prob
, int 
_w
, int 
_h
)

68 
LUTSize
 = 
size
 > 60 ? 60 : size;

69 
LUT
 = 
new
 int[
LUTSize
];

70 
w
 = 
_w
;

71 
h
 = 
_h
;

72 
prob
 = 
_prob
;

74 
LUT
[0] = 1;

75 int 
j
 = 1;

76 for (int 
i
 = 1; i < 
LUTSize
; i++)

78 
LUT
[
i
] = 
LUTSize
 + 1;

79 double 
ret
 = 
	`nfa
(
i
, 
j
);

80 if (
ret
 >= 1.0)

82 while (
j
 < 
i
)

84 
j
++;

85 
ret
 = 
	`nfa
(
i
, 
j
);

86 if (
ret
 <= 1.0)

90 if (
ret
 >= 1.0)

93 
LUT
[
i
] = 
j
;

95 
	}
}

98 
	gNFALUT
::~
	$NFALUT
()

100 
delete
[] 
LUT
;

101 
	}
}

103 
bool
 
	gNFALUT
::
	$checkValidationByNFA
(int 
n
, int 
k
)

105 if (
n
 >= 
LUTSize
)

106 return 
	`nfa
(
n
, 
k
) <= 1.0;

108 return 
k
 >= 
LUT
[
n
];

109 
	}
}

111 double 
	gNFALUT
::
	$myAtan2
(double 
yy
, double 
xx
)

113 double 
angle
 = 
	`fastAtan2
((float)
yy
, (float)
xx
);

115 if (
angle
 > 180)

116 
angle
 = angle - 180;

118 return 
angle
 / 180 * 
CV_PI
;

119 
	}
}

121 double 
	gNFALUT
::
	$Comb
(double 
n
, double 
k
)

123 if (
k
 > 
n
)

126 double 
r
 = 1;

127 for (double 
d
 = 1; d <= 
k
; ++d)

129 
r
 *= 
n
--;

130 
r
 /= 
d
;

132 return 
r
;

133 
	}
}

135 double 
	gNFALUT
::
	$nfa
(int 
n
, int 
k
)

137 double 
sum
 = 0;

138 double 
p
 = 0.125;

139 for (int 
i
 = 
k
; i <= 
n
; i++)

140 
sum
 += 
	`Comb
(
n
, 
i
) * 
	`pow
(
p
, i) * pow(1 - p, n - i);

142 return 
sum
 * 
w
 * w * 
h
 * h;

143 
	}
}

145 struct 
	sStackNode


147 int 
	mr
, 
	mc
;

148 int 
	mparent
;

149 int 
	mdir
;

153 struct 
	sChain


155 int 
	mdir
;

156 int 
	mlen
;

157 int 
	mparent
;

158 int 
	mchildren
[2];

159 
Point
 *
	mpixels
;

163 struct 
	sLS


165 
Point2d
 
	mstart
;

166 
Point2d
 
	mend
;

168 
LS
(
Point2d
 
_start
, Point2d 
_end
)

170 
	mstart
 = 
_start
;

171 
	mend
 = 
_end
;

176 struct 
	sEDLineSegment


178 double 
	ma
, 
	mb
;

179 int 
	minvert
;

181 double 
	msx
, 
	msy
;

182 double 
	mex
, 
	mey
;

184 int 
	msegmentNo
;

185 int 
	mfirstPixelIndex
;

186 int 
	mlen
;

188 
EDLineSegment
(double 
_a
, double 
_b
, int 
_invert
, double 
_sx
, double 
_sy
, double 
_ex
, double 
_ey
, int 
_segmentNo
, int 
_firstPixelIndex
, int 
_len
)

190 
	ma
 = 
_a
;

191 
	mb
 = 
_b
;

192 
	minvert
 = 
_invert
;

193 
	msx
 = 
_sx
;

194 
	msy
 = 
_sy
;

195 
	mex
 = 
_ex
;

196 
	mey
 = 
_ey
;

197 
	msegmentNo
 = 
_segmentNo
;

198 
	mfirstPixelIndex
 = 
_firstPixelIndex
;

199 
	mlen
 = 
_len
;

204 struct 
	smCircle
 {

205 
Point2d
 
	mcenter
;

206 double 
	mr
;

207 
mCircle
(
Point2d
 
_center
, double 
_r
) { 
	mcenter
 = _center; 
	mr
 = _r; }

211 struct 
	smEllipse
 {

212 
Point2d
 
	mcenter
;

213 
Size
 
	maxes
;

214 double 
	mtheta
;

215 
mEllipse
(
Point2d
 
_center
, 
Size
 
_axes
, double 
_theta
) { 
	mcenter
 = _center; 
	maxes
 = _axes; 
	mtheta
 = _theta; }

222 struct 
	sEllipseEquation
 {

223 double 
	mcoeff
[7];

225 
EllipseEquation
() {

226 for (int 
	mi
 = 0; i<7; i++) 
	mcoeff
[
i
] = 0;

229 double 
A
() { return 
	mcoeff
[1]; }

230 double 
B
() { return 
	mcoeff
[2]; }

231 double 
C
() { return 
	mcoeff
[3]; }

232 double 
D
() { return 
	mcoeff
[4]; }

233 double 
E
() { return 
	mcoeff
[5]; }

234 double 
F
() { return 
	mcoeff
[6]; }

238 struct 
	sCircle
 {

239 double 
	mxc
, 
	myc
, 
	mr
;

240 double 
	mcircleFitError
;

241 double 
	mcoverRatio
;

243 double *
	mx
, *
	my
;

244 int 
	mnoPixels
;

247 
EllipseEquation
 
	meq
;

248 double 
	mellipseFitError
;

249 
bool
 
	misEllipse
;

250 double 
	mmajorAxisLength
;

251 double 
	mminorAxisLength
;

255 struct 
	sMyArc
 {

256 double 
	mxc
, 
	myc
, 
	mr
;

257 double 
	mcircleFitError
;

259 double 
	msTheta
, 
	meTheta
;

260 double 
	mcoverRatio
;

262 int 
	mturn
;

264 int 
	msegmentNo
;

266 int 
	msx
, 
	msy
;

267 int 
	mex
, 
	mey
;

269 double *
	mx
, *
	my
;

270 int 
	mnoPixels
;

272 
bool
 
	misEllipse
;

273 
EllipseEquation
 
	meq
;

274 double 
	mellipseFitError
;

280 
inline
 double 
	$ArcLength
(double 
sTheta
, double 
eTheta
)

282 if (
eTheta
 > 
sTheta
)

283 return 
eTheta
 - 
sTheta
;

285 return 
CV_2PI
 - 
sTheta
 + 
eTheta
;

286 
	}
}

289 struct 
	sAngleSetArc
 {

290 double 
	msTheta
;

291 double 
	meTheta
;

292 int 
	mnext
;

295 struct 
	sAngleSet
 {

296 
AngleSetArc
 
	mangles
[360];

297 int 
	mhead
;

298 int 
	mnext
;

299 double 
	moverlapAmount
;

301 
AngleSet
() { 
clear
(); }

302 void 
clear
() { 
	mhead
 = -1; 
	mnext
 = 0; 
	moverlapAmount
 = 0; }

303 double 
overlapRatio
() { return 
	moverlapAmount
 / 
	mCV_2PI
; }

305 void 
_set
(double 
sTheta
, double 
eTheta
);

306 void 
set
(double 
sTheta
, double 
eTheta
);

308 double 
_overlap
(double 
sTheta
, double 
eTheta
);

309 double 
overlap
(double 
sTheta
, double 
eTheta
);

311 void 
computeStartEndTheta
(double& 
sTheta
, double& 
eTheta
);

312 double 
coverRatio
();

315 void 
	gAngleSet
::
	$_set
(double 
sTheta
, double 
eTheta
)

317 int 
arc
 = 
next
++;

319 
angles
[
arc
].
sTheta
 = sTheta;

320 
angles
[
arc
].
eTheta
 = eTheta;

321 
angles
[
arc
].
next
 = -1;

324 int 
prev
 = -1;

325 int 
current
 = 
head
;

329 if (
head
 < 0)

331 
head
 = 
arc
;

336 if (
current
 < 0)

338 
	`CV_Assert
(
prev
 >= 0);

339 
angles
[
prev
].
next
 = 
arc
;

343 if (
angles
[
arc
].
eTheta
 <= angles[
current
].
sTheta
)

346 if (
prev
 < 0)

348 
angles
[
arc
].
next
 = 
current
;

349 
head
 = 
arc
;

353 
angles
[
arc
].
next
 = 
current
;

354 
angles
[
prev
].
next
 = 
arc
;

358 else if (
angles
[
arc
].
sTheta
 >= angles[
current
].
eTheta
)

361 
prev
 = 
current
;

362 
current
 = 
angles
[current].
next
;

365 if (
current
 < 0)

367 
angles
[
prev
].
next
 = 
arc
;

375 if (
prev
 < 0)

376 
head
 = 
angles
[head].
next
;

378 
angles
[
prev
].
next
 = angles[
current
].next;

381 if (
angles
[
arc
].
eTheta
 < angles[
current
].eTheta)

383 
overlapAmount
 += 
angles
[
arc
].
eTheta
 - angles[
current
].
sTheta
;

387 
overlapAmount
 += 
angles
[
current
].
eTheta
 - angles[
arc
].
sTheta
;

391 if (
angles
[
current
].
sTheta
 < angles[
arc
].sTheta)

392 
angles
[
arc
].
sTheta
 = angles[
current
].sTheta;

393 if (
angles
[
current
].
eTheta
 > angles[
arc
].eTheta)

394 
angles
[
arc
].
eTheta
 = angles[
current
].eTheta;

395 
current
 = 
angles
[current].
next
;

398 
	}
}

400 void 
	gAngleSet
::
	$set
(double 
sTheta
, double 
eTheta
)

402 if (
eTheta
 > 
sTheta
)

404 
	`_set
(
sTheta
, 
eTheta
);

408 
	`_set
(
sTheta
, 
CV_2PI
);

409 
	`_set
(0, 
eTheta
);

411 
	}
}

413 double 
	gAngleSet
::
	$_overlap
(double 
sTheta
, double 
eTheta
)

415 double 
o
 = 0;

417 int 
current
 = 
head
;

418 while (
current
 >= 0)

420 if (
sTheta
 > 
angles
[
current
].
eTheta
)

422 
current
 = 
angles
[current].
next
;

425 else if (
eTheta
 < 
angles
[
current
].
sTheta
)

429 if (
sTheta
 < 
angles
[
current
].sTheta && 
eTheta
 > angles[current].eTheta)

431 
o
 += 
angles
[
current
].
eTheta
 - angles[current].
sTheta
;

434 else if (
sTheta
 < 
angles
[
current
].sTheta)

436 
o
 += 
eTheta
 - 
angles
[
current
].
sTheta
;

440 
o
 += 
angles
[
current
].
eTheta
 - 
sTheta
;

443 
current
 = 
angles
[current].
next
;

445 return 
o
;

446 
	}
}

448 double 
	gAngleSet
::
	$overlap
(double 
sTheta
, double 
eTheta
)

450 double 
o
;

452 if (
eTheta
 > 
sTheta
)

454 
o
 = 
	`_overlap
(
sTheta
, 
eTheta
);

458 
o
 = 
	`_overlap
(
sTheta
, 
CV_2PI
);

459 
o
 += 
	`_overlap
(0, 
eTheta
);

461 return 
o
 / 
	`ArcLength
(
sTheta
, 
eTheta
);

462 
	}
}

464 void 
	gAngleSet
::
	$computeStartEndTheta
(double& 
sTheta
, double& 
eTheta
)

467 if (
angles
[
head
].
next
 < 0)

469 
sTheta
 = 
angles
[
head
].sTheta;

470 
eTheta
 = 
angles
[
head
].eTheta;

476 int 
current
 = 
head
;

477 int 
nextArc
 = 
angles
[
current
].
next
;

479 double 
biggestGapSTheta
 = 
angles
[
current
].
eTheta
;

480 double 
biggestGapEtheta
 = 
angles
[
nextArc
].
sTheta
;

481 double 
biggestGapLength
 = 
biggestGapEtheta
 - 
biggestGapSTheta
;

483 double 
start
, 
end
, 
len
;

486 
current
 = 
nextArc
;

487 
nextArc
 = 
angles
[nextArc].
next
;

488 if (
nextArc
 < 0)

491 
start
 = 
angles
[
current
].
eTheta
;

492 
end
 = 
angles
[
nextArc
].
sTheta
;

493 
len
 = 
end
 - 
start
;

495 if (
len
 > 
biggestGapLength
)

497 
biggestGapSTheta
 = 
start
;

498 
biggestGapEtheta
 = 
end
;

499 
biggestGapLength
 = 
len
;

504 
start
 = 
angles
[
current
].
eTheta
;

505 
end
 = 
angles
[
head
].
sTheta
;

506 
len
 = 
CV_2PI
 - 
start
 + 
end
;

507 if (
len
 > 
biggestGapLength
)

509 
biggestGapSTheta
 = 
start
;

510 
biggestGapEtheta
 = 
end
;

512 
sTheta
 = 
biggestGapEtheta
;

513 
eTheta
 = 
biggestGapSTheta
;

514 
	}
}

516 double 
	gAngleSet
::
	$coverRatio
()

518 int 
current
 = 
head
;

520 double 
total
 = 0;

521 while (
current
 >= 0)

523 
total
 += 
angles
[
current
].
eTheta
 - angles[current].
sTheta
;

524 
current
 = 
angles
[current].
next
;

526 return 
total
 / 
CV_2PI
;

527 
	}
}

529 struct 
	sEDArcs
 {

530 
MyArc
 *
	marcs
;

531 int 
	mnoArcs
;

533 
	mpublic
:

534 
EDArcs
(int 
size
 = 10000) {

535 
arcs
 = 
new
 
MyArc
[
size
];

536 
	mnoArcs
 = 0;

539 ~
EDArcs
() {

540 
	mdelete
[] 
	marcs
;

544 struct 
	sBufferManager
 {

545 double *
	mx
, *
	my
;

546 int 
	mindex
;

548 
BufferManager
(int 
maxSize
) {

549 
	mx
 = 
new
 double[
maxSize
];

550 
	my
 = 
new
 double[
maxSize
];

551 
	mindex
 = 0;

554 ~
BufferManager
() {

555 
	mdelete
[] 
	mx
;

556 
	mdelete
[] 
	my
;

559 double *
getX
() { return &
	mx
[
index
]; }

560 double *
getY
() { return &
	my
[
index
]; }

561 void 
move
(int 
size
) { 
	mindex
 += size; }

564 struct 
	sInfo
 {

565 int 
	msign
;

566 double 
	mangle
;

567 
bool
 
	mtaken
;

	@ximgproc/src/find_ellipses.cpp

5 #include 
	~"precomp.hpp
"

6 #include 
	~<opencv2/core.hpp
>

7 #include 
	~<unordered_map
>

8 #include 
	~<numeric
>

10 
namespace
 
	gcv
 {

11 
namespace
 
	gximgproc
 {

14 typedef 
	gstd
::
	tvector
<
	tPoint
> 
	tVP
;

15 typedef 
	gstd
::
	tvector
<
	tVP
> 
	tVVP
;

16 typedef unsigned int 
	tuint
;

19 struct 
	sEllipse
 {

20 
Point2f
 
	gcenter
;

21 float 
	ga
, 
	gb
;

22 float 
	gradius
;

23 float 
	gscore
;

25 
Ellipse
() {

26 
	gcenter
 = 
Point2f
(0, 0);

27 
	ga
 = 0.f, 
	gb
 = 0.f;

28 
	gradius
 = 0.f, 
	gscore
 = 0.f;

31 
Ellipse
(
Point2f
 
_center
, float 
_a
, float 
_b
, float 
_radius
,

32 float 
_score
 = 0.f) {

33 
center
 = 
_center
;

34 
	gthis
->
	ga
 = 
_a
, this->
	gb
 = 
_b
;

35 
	gthis
->
	gradius
 = 
_radius
, this->
	gscore
 = 
_score
;

38 
Ellipse
(float 
_center_x
, float 
_center_y
, float 
_a
, float 
_b
, float 
_radius
,

39 float 
_score
 = 0.f) {

40 
center
 = 
Point2f
(
_center_x
, 
_center_y
);

41 
	gthis
->
	ga
 = 
_a
, this->
	gb
 = 
_b
;

42 
	gthis
->
	gradius
 = 
_radius
, this->
	gscore
 = 
_score
;

45 
Ellipse
(const Ellipse &
other
) {

46 
	gcenter
 = 
other
.
center
;

47 
	ga
 = 
other
.
a
, 
	gb
 = other.
b
;

48 
	gradius
 = 
other
.
radius
, 
	gscore
 = other.
score
;

51 
bool
 
	goperator
<(const 
	gEllipse
 &
	gother
) const {

52 if (
	gscore
 == 
other
.
score
) {

53 float 
lhs_e
 = 
b
 / 
a
;

54 float 
	grhs_e
 = 
other
.
b
 / other.
a
;

55 if (
	glhs_e
 == 
rhs_e
)

56 return 
false
;

57 return 
	glhs_e
 > 
	grhs_e
;

59 return 
	gscore
 > 
	gother
.score;

62 
	gvirtual
 ~
Ellipse
() = default;

65 static int 
inline
 
signal
(float 
val
) {

66 return 
	gval
 > 0.f ? 1 : -1;

69 static 
bool
 
sortPoint
(const 
Point
 &
lhs
, const Point &
rhs
) {

70 if (
	glhs
.
	gx
 == 
rhs
.
x
) {

71 return 
lhs
.
y
 < 
rhs
.y;

73 return 
	glhs
.
	gx
 < 
	grhs
.x;

76 static 
Point2f
 
lineCrossPoint
(Point2f 
l1p1
, Point2f 
l1p2
, Point2f 
l2p1
, Point2f 
l2p2
) {

77 
Point2f
 
	gcrossPoint
;

78 float 
	gk1
, 
	gk2
, 
	gb1
, 
	gb2
;

79 if (
	gl1p1
.
	gx
 == 
l1p2
.
x
 && 
l2p1
.x == 
l2p2
.x) {

80 
crossPoint
 = 
Point2f
(0, 0);

81 return 
	gcrossPoint
;

83 if (
	gl1p1
.
	gx
 == 
l1p2
.
x
) {

84 
crossPoint
.
x
 = 
l1p1
.x;

85 
	gk2
 = (
l2p2
.
y
 - 
l2p1
.y) / (l2p2.
x
 - l2p1.x);

86 
	gb2
 = 
l2p1
.
y
 - 
k2
 * l2p1.
x
;

87 
	gcrossPoint
.
	gy
 = 
k2
 * 
crossPoint
.
x
 + 
b2
;

88 return 
	gcrossPoint
;

90 if (
	gl2p1
.
	gx
 == 
l2p2
.
x
) {

91 
crossPoint
.
x
 = 
l2p1
.x;

92 
	gk2
 = (
l1p2
.
y
 - 
l1p1
.y) / (l1p2.
x
 - l1p1.x);

93 
	gb2
 = 
l1p1
.
y
 - 
k2
 * l1p1.
x
;

94 
	gcrossPoint
.
	gy
 = 
k2
 * 
crossPoint
.
x
 + 
b2
;

95 return 
	gcrossPoint
;

98 
	gk1
 = (
l1p2
.
y
 - 
l1p1
.y) / (l1p2.
x
 - l1p1.x);

99 
	gk2
 = (
l2p2
.
y
 - 
l2p1
.y) / (l2p2.
x
 - l2p1.x);

100 
	gb1
 = 
l1p1
.
y
 - 
k1
 * l1p1.
x
;

101 
	gb2
 = 
l2p1
.
y
 - 
k2
 * l2p1.
x
;

102 if (
	gk1
 == 
k2
)

103 
crossPoint
 = 
Point2f
(0, 0);

105 
	gcrossPoint
.
	gx
 = (
b2
 - 
b1
) / (
k1
 - 
k2
);

106 
	gcrossPoint
.
	gy
 = 
k1
 * 
crossPoint
.
x
 + 
b1
;

108 return 
	gcrossPoint
;

111 static void 
pointToMat
(
Point2f
 
p1
, Point2f 
p2
, 
Mat
& 
mat
) {

112 
	gmat
.
	gat
<float>(0, 0) = 
p1
.
x
;

113 
	gmat
.
	gat
<float>(0, 1) = 
p1
.
y
;

114 
	gmat
.
	gat
<float>(1, 0) = 
p2
.
x
;

115 
	gmat
.
	gat
<float>(1, 1) = 
p2
.
y
;

118 static float 
valueOfPoints
(
Point2f
 
p3
, Point2f 
p2
, Point2f 
p1
, Point2f 
p4
, Point2f 
p5
, Point2f 
p6
) {

119 float 
	gresult
 = 1;

121 
Point2f
 
	gv
 = 
lineCrossPoint
(
p1
, 
p2
, 
p3
, 
p4
);

122 
Point2f
 
	gw
 = 
lineCrossPoint
(
p5
, 
p6
, 
p3
, 
p4
);

123 
Point2f
 
	gu
 = 
lineCrossPoint
(
p5
, 
p6
, 
p1
, 
p2
);

125 
Mat
 
	gB
 = Mat(2, 2, 
CV_32F
);

126 
Mat
 
	gC
 = Mat(2, 2, 
CV_32F
);

128 
pointToMat
(
u
, 
v
, 
B
);

129 
pointToMat
(
p1
, 
p2
, 
C
);

130 
Mat
 
	gA
 = 
C
 * 
B
.
inv
();

131 
	gresult
 *=

132 
A
.
at
<float>(0, 0) * 
	gA
.
	gat
<float>(1, 0) / (A.at<float>(0, 1) * A.at<float>(1, 1));

134 
pointToMat
(
p3
, 
p4
, 
C
);

135 
pointToMat
(
v
, 
w
, 
B
);

136 
	gA
 = 
C
 * 
B
.
inv
();

137 
	gresult
 *=

138 
A
.
at
<float>(0, 0) * 
	gA
.
	gat
<float>(1, 0) / (A.at<float>(0, 1) * A.at<float>(1, 1));

140 
pointToMat
(
p5
, 
p6
, 
C
);

141 
pointToMat
(
w
, 
u
, 
B
);

142 
	gA
 = 
C
 * 
B
.
inv
();

143 
	gresult
 *=

144 
A
.
at
<float>(0, 0) * 
	gA
.
	gat
<float>(1, 0) / (A.at<float>(0, 1) * A.at<float>(1, 1));

145 return 
	gresult
;

148 static float 
inline
 
pointDistance2
(const 
Point
 &
A
, const Point &
B
) {

149 return float(((
	gB
.
	gx
 - 
	gA
.x) * (B.x - A.x) + (B.
	gy
 - A.y) * (B.y - A.y)));

152 static float 
getMinAnglePI
(float 
alpha
, float 
beta
) {

153 auto 
	gpi
 = float(
CV_PI
);

154 auto 
	gpi2
 = float(2.0 * 
CV_PI
);

157 float 
	ga
 = 
fmod
(
alpha
 + 
pi2
, pi2);

158 float 
	gb
 = 
fmod
(
beta
 + 
pi2
, pi2);

161 if (
	ga
 > 
	gpi
)

162 
	ga
 -= 
pi
;

163 if (
	gb
 > 
	gpi
)

164 
	gb
 -= 
pi
;

166 if (
	ga
 > 
	gb
)

167 
swap
(
a
, 
b
);

169 float 
	gdiff1
 = 
b
 - 
a
;

170 float 
	gdiff2
 = 
pi
 - 
diff1
;

172 return 
min
(
diff1
, 
diff2
);

176 struct 
	sEllipseData
 {

177 
bool
 
	gisValid
;

178 float 
	gta
, 
	gtb
;

179 float 
	gra
, 
	grb
;

180 
Point2f
 
	gMa
, 
	gMb
, 
	gCab
;

181 
	gstd
::
vector
<float> 
Sa
, 
	gSb
;

185 class 
	cEllipseDetectorImpl
 {

188 
Size
 
	g_kernelSize
;

189 double 
	g_sigma
;

192 int 
	g_minEdgeLength
;

193 float 
	g_minOrientedRectSide
;

196 float 
	g_positionThreshold
;

199 unsigned 
	g_uNs
;

202 float 
	g_maxCenterDistance
;

203 float 
	g_maxCenterDistance2
;

206 float 
	g_maxDistanceToEllipseContour
;

209 float 
	g_minScore
;

210 float 
	g_minReliability
;

213 
Size
 
	g_imgSize
;

215 int 
	gACC_N_SIZE
, 
	gACC_R_SIZE
, 
	gACC_A_SIZE
;

216 int *
	gaccN
, *
	gaccR
, *
	gaccA
;

218 
	gpublic
:

219 float 
countsOfFindEllipse
;

220 float 
	gcountsOfGetFastCenter
;

222 
EllipseDetectorImpl
();

224 ~
EllipseDetectorImpl
() = default;

227 void 
detect
(
Mat1b
 &
image
, 
std
::
vector
<
Ellipse
> &
ellipses
);

230 void 
setParameters
(float 
maxCenterDistance
, float 
minScore
, float 
minReliability
);

232 
	gprivate
:

234 static const 
ushort
 
PAIR_12
 = 0x00;

235 static const 
ushort
 
	gPAIR_23
 = 0x01;

236 static const 
ushort
 
	gPAIR_34
 = 0x02;

237 static const 
ushort
 
	gPAIR_14
 = 0x03;

239 static 
uint
 
inline
 
generateKey
(
uchar
 
pair
, 
ushort
 
u
, ushort 
v
);

241 void 
preProcessing
(
Mat1b
 &
image
, Mat1b &
dp
, Mat1b &
dn
);

243 void 
clusterEllipses
(
std
::
vector
<
Ellipse
> &
ellipses
);

246 
getMedianSlope
(
std
::
vector
<
Point2f
> &
med
, Point2f &
centers
, std::vector<float> &
slopes
);

248 void 
getFastCenter
(
std
::
vector
<
Point
> &
e1
, std::vector<Point> &
e2
, 
EllipseData
 &
data
);

250 void 
detectEdges13
(
Mat1b
 &
DP
, 
VVP
 &
points_1
, VVP &
points_3
);

252 void 
detectEdges24
(
Mat1b
 &
DN
, 
VVP
 &
points_2
, VVP &
points_4
);

255 
findEllipses
(
Point2f
 &
center
, 
VP
 &
edge_i
, VP &
edge_j
, VP &
edge_k
, 
EllipseData
 &
data_ij
,

256 
EllipseData
 &
data_ik
, 
std
::
vector
<
Ellipse
> &
ellipses
);

258 static 
Point2f
 
getCenterCoordinates
(
EllipseData
 &
data_ij
, EllipseData &
data_ik
);

261 
getTriplets124
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
, 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

262 
std
::
vector
<
Ellipse
> &
ellipses
);

265 
getTriplets231
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
, 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

266 
std
::
vector
<
Ellipse
> &
ellipses
);

269 
getTriplets342
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
, 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

270 
std
::
vector
<
Ellipse
> &
ellipses
);

273 
getTriplets413
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
, 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

274 
std
::
vector
<
Ellipse
> &
ellipses
);

276 static void 
labeling
(
Mat1b
 &
image
, 
VVP
 &
segments
, int 
minLength
);

279 
	gEllipseDetectorImpl
::
EllipseDetectorImpl
() {

281 
_kernelSize
 = 
Size
(5, 5);

282 
	g_sigma
 = 1.0;

283 
	g_positionThreshold
 = 1.0f;

284 
	g_maxCenterDistance
 = 100.0f * 0.05f;

285 
	g_maxCenterDistance2
 = 
_maxCenterDistance
 * _maxCenterDistance;

286 
	g_minEdgeLength
 = 16;

287 
	g_minOrientedRectSide
 = 3.0f;

288 
	g_maxDistanceToEllipseContour
 = 0.1f;

289 
	g_minScore
 = 0.7f;

290 
	g_minReliability
 = 0.5;

291 
	g_uNs
 = 16;

294 void 
	gEllipseDetectorImpl
::
setParameters
(float 
maxCenterDistance
, float 
minScore
,

295 float 
minReliability
) {

296 
	g_maxCenterDistance
 = 
maxCenterDistance
;

297 
	g_minScore
 = 
minScore
;

298 
	g_minReliability
 = 
minReliability
;

300 
	g_maxCenterDistance2
 = 
_maxCenterDistance
 * _maxCenterDistance;

303 
uint
 
inline
 
	gEllipseDetectorImpl
::
generateKey
(
uchar
 
pair
, 
ushort
 
u
, ushort 
v
) {

304 return (
	gpair
 << 30) + (
	gu
 << 15) + 
	gv
;

307 float 
	gEllipseDetectorImpl
::
getMedianSlope
(
std
::
vector
<
Point2f
> &
med
, Point2f &
centers
,

308 
std
::
vector
<float> &
slopes
) {

313 
size_t
 
pointCount
 = 
med
.
size
();

316 
size_t
 
	ghalfSize
 = 
pointCount
 >> 1;

317 
size_t
 
	gquarterSize
 = 
halfSize
 >> 1;

319 
	gstd
::
vector
<float> 
xx
, 
	gyy
;

320 
	gslopes
.
reserve
(
halfSize
);

321 
	gxx
.
reserve
(
pointCount
);

322 
	gyy
.
reserve
(
pointCount
);

324 for (unsigned 
	gi
 = 0; i < 
	ghalfSize
; i++) {

325 
	gPoint2f
 &
	gp1
 = 
med
[
i
];

326 
	gPoint2f
 &
	gp2
 = 
med
[
halfSize
 + 
i
];

328 
	gxx
.
push_back
(
p1
.
x
);

329 
	gxx
.
push_back
(
p2
.
x
);

330 
	gyy
.
push_back
(
p1
.
y
);

331 
	gyy
.
push_back
(
p2
.
y
);

333 float 
	gden
 = (
p2
.
x
 - 
p1
.x);

334 float 
	gnum
 = (
p2
.
y
 - 
p1
.y);

336 
	gden
 = (
std
::
fabs
(
den
) >= 1e-5) ? den : 0.00001f;

338 
	gslopes
.
push_back
(
num
 / 
den
);

341 
	gstd
::
nth_element
(
slopes
.
begin
(), slopes.begin() + 
quarterSize
, slopes.
end
());

342 
	gstd
::
nth_element
(
xx
.
begin
(), xx.begin() + 
halfSize
, xx.
end
());

343 
	gstd
::
nth_element
(
yy
.
begin
(), yy.begin() + 
halfSize
, yy.
end
());

344 
	gcenters
.
	gx
 = 
xx
[
halfSize
];

345 
	gcenters
.
	gy
 = 
yy
[
halfSize
];

347 return 
	gslopes
[
quarterSize
];

350 void 
	gEllipseDetectorImpl
::
getFastCenter
(
std
::
vector
<
Point
> &
e1
, std::vector<Point> &
e2
,

351 
EllipseData
 &
data
) {

352 
	gcountsOfGetFastCenter
++;

353 
	gdata
.
	gisValid
 = 
true
;

355 auto 
	gsize_1
 = unsigned(
e1
.
size
());

356 auto 
	gsize_2
 = unsigned(
e2
.
size
());

358 unsigned 
	ghsize_1
 = 
size_1
 >> 1;

359 unsigned 
	ghsize_2
 = 
size_2
 >> 1;

361 
	gPoint
 &
	gmed1
 = 
e1
[
hsize_1
];

362 
	gPoint
 &
	gmed2
 = 
e2
[
hsize_2
];

364 
Point2f
 
	gM12
, 
	gM34
;

365 float 
	gq2
, 
	gq4
;

368 auto 
	gdx_ref
 = float(
e1
[0].
x
 - 
med2
.x);

369 auto 
	gdy_ref
 = float(
e1
[0].
y
 - 
med2
.y);

371 if (
	gdx_ref
 == 0)

372 
dx_ref
 = 0.00001f;

374 float 
	gm_ref
 = 
dy_ref
 / 
dx_ref
;

375 
	gdata
.
	gra
 = 
m_ref
;

378 
	gstd
::
vector
<
Point2f
> 
med
;

379 
	gmed
.
reserve
(
hsize_2
);

381 unsigned 
	gminPoints
 = (
_uNs
 < 
hsize_2
) ? _uNs : hsize_2;

383 
	gstd
::
vector
<
uint
> 
indexes
(
minPoints
);

384 if (
	g_uNs
 < 
	ghsize_2
) {

385 unsigned 
	giSzBin
 = 
hsize_2
 / unsigned(
_uNs
);

386 unsigned 
	giIdx
 = 
hsize_2
 + (
iSzBin
 / 2);

388 for (unsigned 
	gi
 = 0; i < 
	g_uNs
; i++) {

389 
	gindexes
[
i
] = 
iIdx
;

390 
	giIdx
 += 
iSzBin
;

393 
	gstd
::
iota
(
indexes
.
begin
(), indexes.
end
(), 
hsize_2
);

395 for (
uint
 
	gii
 = 0; ii < 
	gminPoints
; ii++) {

396 
uint
 
	gi
 = 
indexes
[
ii
];

398 auto 
	gx1
 = float(
e2
[
i
].
x
);

399 auto 
	gy1
 = float(
e2
[
i
].
y
);

401 
uint
 
	gbegin
 = 0;

402 
uint
 
	gend
 = 
size_1
 - 1;

404 auto 
	gxb
 = float(
e1
[
begin
].
x
);

405 auto 
	gyb
 = float(
e1
[
begin
].
y
);

406 float 
	gres_begin
 = ((
xb
 - 
x1
) * 
dy_ref
) - ((
yb
 - 
y1
) * 
dx_ref
);

407 int 
	gsign_begin
 = 
signal
(
res_begin
);

408 if (
	gsign_begin
 == 0) {

409 
med
.
emplace_back
((
xb
 + 
x1
) * 0.5f, (
yb
 + 
y1
) * 0.5f);

413 auto 
	gxe
 = float(
e1
[
end
].
x
);

414 auto 
	gye
 = float(
e1
[
end
].
y
);

415 float 
	gres_end
 = ((
xe
 - 
x1
) * 
dy_ref
) - ((
ye
 - 
y1
) * 
dx_ref
);

416 int 
	gsign_end
 = 
signal
(
res_end
);

417 if (
	gsign_end
 == 0) {

418 
med
.
emplace_back
((
xe
 + 
x1
) * 0.5f, (
ye
 + 
y1
) * 0.5f);

422 if ((
	gsign_begin
 + 
	gsign_end
) != 0)

427 
uint
 
	gj
 = (
begin
 + 
end
) >> 1;

428 while (
	gend
 - 
	gbegin
 > 2) {

429 auto 
	gx2
 = float(
e1
[
j
].
x
);

430 auto 
	gy2
 = float(
e1
[
j
].
y
);

431 float 
	gres
 = ((
x2
 - 
x1
) * 
dy_ref
) - ((
y2
 - 
y1
) * 
dx_ref
);

432 int 
	gsign_res
 = 
signal
(
res
);

434 if (
	gsign_res
 == 0) {

435 
med
.
emplace_back
((
x2
 + 
x1
) * 0.5f, (
y2
 + 
y1
) * 0.5f);

439 if (
	gsign_res
 + 
	gsign_begin
 == 0) {

440 
sign_end
 = 
sign_res
;

441 
	gend
 = 
j
;

443 
	gsign_begin
 = 
sign_res
;

444 
	gbegin
 = 
j
;

446 
	gj
 = (
begin
 + 
end
) >> 1;

449 
	gmed
.
emplace_back
((
e1
[
j
].
x
 + 
x1
) * 0.5f, (e1[j].
y
 + 
y1
) * 0.5f);

452 if (
	gmed
.
size
() < 2) {

453 
	gdata
.
	gisValid
 = 
false
;

457 
	gq2
 = 
getMedianSlope
(
med
, 
M12
, 
data
.
Sa
);

461 auto 
	gdx_ref
 = float(
med1
.
x
 - 
e2
[0].x);

462 auto 
	gdy_ref
 = float(
med1
.
y
 - 
e2
[0].y);

464 if (
	gdx_ref
 == 0)

465 
dx_ref
 = 0.00001f;

467 float 
	gm_ref
 = 
dy_ref
 / 
dx_ref
;

468 
	gdata
.
	grb
 = 
m_ref
;

471 
	gstd
::
vector
<
Point2f
> 
med
;

472 
	gmed
.
reserve
(
hsize_1
);

474 
uint
 
	gminPoints
 = (
_uNs
 < 
hsize_1
) ? _uNs : hsize_1;

476 
	gstd
::
vector
<
uint
> 
indexes
(
minPoints
);

477 if (
	g_uNs
 < 
	ghsize_1
) {

478 unsigned 
	giSzBin
 = 
hsize_1
 / unsigned(
_uNs
);

479 unsigned 
	giIdx
 = 
hsize_1
 + (
iSzBin
 / 2);

481 for (unsigned 
	gi
 = 0; i < 
	g_uNs
; i++) {

482 
	gindexes
[
i
] = 
iIdx
;

483 
	giIdx
 += 
iSzBin
;

486 
	gstd
::
iota
(
indexes
.
begin
(), indexes.
end
(), 
hsize_1
);

489 for (
uint
 
	gii
 = 0; ii < 
	gminPoints
; ii++) {

490 
uint
 
	gi
 = 
indexes
[
ii
];

492 auto 
	gx1
 = float(
e1
[
i
].
x
);

493 auto 
	gy1
 = float(
e1
[
i
].
y
);

495 
uint
 
	gbegin
 = 0;

496 
uint
 
	gend
 = 
size_2
 - 1;

498 auto 
	gxb
 = float(
e2
[
begin
].
x
);

499 auto 
	gyb
 = float(
e2
[
begin
].
y
);

500 float 
	gres_begin
 = ((
xb
 - 
x1
) * 
dy_ref
) - ((
yb
 - 
y1
) * 
dx_ref
);

501 int 
	gsign_begin
 = 
signal
(
res_begin
);

502 if (
	gsign_begin
 == 0) {

503 
med
.
emplace_back
((
xb
 + 
x1
) * 0.5f, (
yb
 + 
y1
) * 0.5f);

507 auto 
	gxe
 = float(
e2
[
end
].
x
);

508 auto 
	gye
 = float(
e2
[
end
].
y
);

509 float 
	gres_end
 = ((
xe
 - 
x1
) * 
dy_ref
) - ((
ye
 - 
y1
) * 
dx_ref
);

510 int 
	gsign_end
 = 
signal
(
res_end
);

511 if (
	gsign_end
 == 0) {

512 
med
.
emplace_back
((
xe
 + 
x1
) * 0.5f, (
ye
 + 
y1
) * 0.5f);

516 if ((
	gsign_begin
 + 
	gsign_end
) != 0)

519 
uint
 
	gj
 = (
begin
 + 
end
) >> 1;

521 while (
	gend
 - 
	gbegin
 > 2) {

522 auto 
	gx2
 = float(
e2
[
j
].
x
);

523 auto 
	gy2
 = float(
e2
[
j
].
y
);

524 float 
	gres
 = ((
x2
 - 
x1
) * 
dy_ref
) - ((
y2
 - 
y1
) * 
dx_ref
);

525 int 
	gsign_res
 = 
signal
(
res
);

527 if (
	gsign_res
 == 0) {

528 
med
.
emplace_back
((
x2
 + 
x1
) * 0.5f, (
y2
 + 
y1
) * 0.5f);

532 if (
	gsign_res
 + 
	gsign_begin
 == 0) {

533 
sign_end
 = 
sign_res
;

534 
	gend
 = 
j
;

536 
	gsign_begin
 = 
sign_res
;

537 
	gbegin
 = 
j
;

539 
	gj
 = (
begin
 + 
end
) >> 1;

542 
	gmed
.
emplace_back
((
e2
[
j
].
x
 + 
x1
) * 0.5f, (e2[j].
y
 + 
y1
) * 0.5f);

545 if (
	gmed
.
size
() < 2) {

546 
	gdata
.
	gisValid
 = 
false
;

549 
	gq4
 = 
getMedianSlope
(
med
, 
M34
, 
data
.
Sb
);

552 if (
	gq2
 == 
q4
) {

553 
data
.
isValid
 = 
false
;

557 float 
	ginvDen
 = 1 / (
q2
 - 
q4
);

558 
	gdata
.
	gCab
.
	gx
 = (
M34
.
y
 - 
q4
 * M34.
x
 - 
M12
.y + 
q2
 * M12.x) * 
invDen
;

559 
	gdata
.
	gCab
.
	gy
 = (
q2
 * 
M34
.
y
 - 
q4
 * 
M12
.y + q2 * q4 * (M12.
x
 - M34.x)) * 
invDen
;

560 
	gdata
.
	gta
 = 
q2
;

561 
	gdata
.
	gtb
 = 
q4
;

562 
	gdata
.
	gMa
 = 
M12
;

563 
	gdata
.
	gMb
 = 
M34
;

566 
Point2f


567 
	gEllipseDetectorImpl
::
getCenterCoordinates
(
EllipseData
 &
data_ij
, EllipseData &
data_ik
) {

568 float 
	gxx
[7];

569 float 
	gyy
[7];

571 
	gxx
[0] = 
data_ij
.
Cab
.
x
;

572 
	gxx
[1] = 
data_ik
.
Cab
.
x
;

573 
	gyy
[0] = 
data_ij
.
Cab
.
y
;

574 
	gyy
[1] = 
data_ik
.
Cab
.
y
;

578 float 
	gq2
 = 
data_ij
.
ta
;

579 float 
	gq4
 = 
data_ik
.
ta
;

580 
	gPoint2f
 &
	gM12
 = 
data_ij
.
Ma
;

581 
	gPoint2f
 &
	gM34
 = 
data_ik
.
Ma
;

583 float 
	ginvDen
 = 1 / (
q2
 - 
q4
);

584 
	gxx
[2] = (
M34
.
y
 - 
q4
 * M34.
x
 - 
M12
.y + 
q2
 * M12.x) * 
invDen
;

585 
	gyy
[2] = (
q2
 * 
M34
.
y
 - 
q4
 * 
M12
.y + q2 * q4 * (M12.
x
 - M34.x)) * 
invDen
;

590 float 
	gq2
 = 
data_ij
.
ta
;

591 float 
	gq4
 = 
data_ik
.
tb
;

592 
	gPoint2f
 &
	gM12
 = 
data_ij
.
Ma
;

593 
	gPoint2f
 &
	gM34
 = 
data_ik
.
Mb
;

595 float 
	ginvDen
 = 1 / (
q2
 - 
q4
);

596 
	gxx
[3] = (
M34
.
y
 - 
q4
 * M34.
x
 - 
M12
.y + 
q2
 * M12.x) * 
invDen
;

597 
	gyy
[3] = (
q2
 * 
M34
.
y
 - 
q4
 * 
M12
.y + q2 * q4 * (M12.
x
 - M34.x)) * 
invDen
;

602 float 
	gq2
 = 
data_ij
.
tb
;

603 float 
	gq4
 = 
data_ik
.
tb
;

604 
	gPoint2f
 &
	gM12
 = 
data_ij
.
Mb
;

605 
	gPoint2f
 &
	gM34
 = 
data_ik
.
Mb
;

607 float 
	ginvDen
 = 1 / (
q2
 - 
q4
);

608 
	gxx
[4] = (
M34
.
y
 - 
q4
 * M34.
x
 - 
M12
.y + 
q2
 * M12.x) * 
invDen
;

609 
	gyy
[4] = (
q2
 * 
M34
.
y
 - 
q4
 * 
M12
.y + q2 * q4 * (M12.
x
 - M34.x)) * 
invDen
;

614 float 
	gq2
 = 
data_ij
.
tb
;

615 float 
	gq4
 = 
data_ik
.
ta
;

616 
	gPoint2f
 &
	gM12
 = 
data_ij
.
Mb
;

617 
	gPoint2f
 &
	gM34
 = 
data_ik
.
Ma
;

619 float 
	ginvDen
 = 1 / (
q2
 - 
q4
);

620 
	gxx
[5] = (
M34
.
y
 - 
q4
 * M34.
x
 - 
M12
.y + 
q2
 * M12.x) * 
invDen
;

621 
	gyy
[5] = (
q2
 * 
M34
.
y
 - 
q4
 * 
M12
.y + q2 * q4 * (M12.
x
 - M34.x)) * 
invDen
;

624 
	gxx
[6] = (
xx
[0] + xx[1]) * 0.5f;

625 
	gyy
[6] = (
yy
[0] + yy[1]) * 0.5f;

629 
	gstd
::
nth_element
(
xx
, xx + 3, xx + 7);

630 
	gstd
::
nth_element
(
yy
, yy + 3, yy + 7);

631 float 
	gxc
 = 
xx
[3];

632 float 
	gyc
 = 
yy
[3];

634 return {
	gxc
, 
	gyc
};

638 void 
	gEllipseDetectorImpl
::
labeling
(
Mat1b
 &
image
, 
VVP
 &
segments
, int 
minLength
) {

639 const int 
	gRG_STACK_SIZE
 = 2048;

640 int 
	gstackInt
[
RG_STACK_SIZE
];

641 
Point
 
	gstackPoint
[
RG_STACK_SIZE
];

643 
	gMat_
<
	guchar
> 
	gimage_clone
 = 
image
.
clone
();

644 
Size
 
	gimgSize
 = 
image
.
size
();

645 int 
	gh
 = 
imgSize
.
height
, 
	gw
 = imgSize.
width
;

647 
Point
 
	gpoint
;

648 for (int 
	gy
 = 0; y < 
	gh
; ++y) {

649 for (int 
	gx
 = 0; x < 
	gw
; ++x) {

650 if ((
image_clone
(
y
, 
x
)) != 0) {

652 int 
curInt
 = 0;

653 int 
	gi
 = 
x
 + 
y
 * 
w
;

654 
	gstackInt
[
curInt
] = 
i
;

655 
	gcurInt
++;

658 int 
	gcurPoint
 = 0;

659 while (
	gcurInt
 > 0) {

660 
	gcurInt
--;

661 
	gi
 = 
stackInt
[
curInt
];

662 int 
	gx2
 = 
i
 % 
w
;

663 int 
	gy2
 = 
i
 / 
w
;

665 
	gpoint
.
	gx
 = 
x2
;

666 
	gpoint
.
	gy
 = 
y2
;

668 if ((
image_clone
(
y2
, 
x2
))) {

669 
	gstackPoint
[
curPoint
] = 
point
;

670 
	gcurPoint
++;

671 
image_clone
(
y2
, 
x2
) = 0;

675 if (
	gx2
 > 0 && (
image_clone
(
y2
, 
x2
 - 1) != 0)) {

676 
stackInt
[
curInt
] = 
i
 - 1;

677 
	gcurInt
++;

679 if (
	gy2
 > 0 && (
image_clone
(
y2
 - 1, 
x2
) != 0)) {

680 
stackInt
[
curInt
] = 
i
 - 
w
;

681 
	gcurInt
++;

683 if (
	gy2
 < 
	gh
 - 1 && (
image_clone
(
y2
 + 1, 
x2
) != 0)) {

684 
stackInt
[
curInt
] = 
i
 + 
w
;

685 
	gcurInt
++;

687 if (
	gx2
 < 
	gw
 - 1 && (
image_clone
(
y2
, 
x2
 + 1) != 0)) {

688 
stackInt
[
curInt
] = 
i
 + 1;

689 
	gcurInt
++;

693 if (
	gx2
 > 0 && 
	gy2
 > 0 && (
image_clone
(
y2
 - 1, 
x2
 - 1) != 0)) {

694 
stackInt
[
curInt
] = 
i
 - 
w
 - 1;

695 
	gcurInt
++;

697 if (
	gx2
 > 0 && 
	gy2
 < 
	gh
 - 1 && (
image_clone
(
y2
 + 1, 
x2
 - 1) != 0)) {

698 
stackInt
[
curInt
] = 
i
 + 
w
 - 1;

699 
	gcurInt
++;

701 if (
	gx2
 < 
	gw
 - 1 && 
	gy2
 > 0 && (
image_clone
(
y2
 - 1, 
x2
 + 1) != 0)) {

702 
stackInt
[
curInt
] = 
i
 - 
w
 + 1;

703 
	gcurInt
++;

705 if (
	gx2
 < 
	gw
 - 1 && 
	gy2
 < 
	gh
 - 1 && (
image_clone
(
y2
 + 1, 
x2
 + 1) != 0)) {

706 
stackInt
[
curInt
] = 
i
 + 
w
 + 1;

707 
	gcurInt
++;

711 if (
	gcurPoint
 >= 
minLength
) {

712 
std
::
vector
<
Point
> 
component
;

713 
	gcomponent
.
reserve
(
curPoint
);

714 for (int 
	gj
 = 0; j < 
	gcurPoint
; j++)

715 
	gcomponent
.
push_back
(
stackPoint
[
j
]);

716 
	gsegments
.
push_back
(
component
);

723 void 
	gEllipseDetectorImpl
::
detectEdges13
(
Mat1b
 &
DP
, 
VVP
 &
points_1
, VVP &
points_3
) {

725 
VVP
 
	gcontours
;

727 
labeling
(
DP
, 
contours
, 
_minEdgeLength
);

728 int 
	gcontourSize
 = int(
contours
.
size
());

731 for (int 
	gi
 = 0; i < 
	gcontourSize
; i++) {

732 
	gVP
 &
	gedgeSegment
 = 
contours
[
i
];

735 
RotatedRect
 
	goriented
 = 
minAreaRect
(
edgeSegment
);

736 float 
	gorMin
 = 
min
(
oriented
.
size
.
width
, oriented.size.
height
);

738 if (
	gorMin
 < 
	g_minOrientedRectSide
) {

743 
	gstd
::
sort
(
edgeSegment
.
begin
(), edgeSegment.
end
(), 
sortPoint
);

744 int 
	gedgeSegmentSize
 = unsigned(
edgeSegment
.
size
());

747 
	gPoint
 &
	gleft
 = 
edgeSegment
[0];

748 
	gPoint
 &
	gright
 = 
edgeSegment
[
edgeSegmentSize
 - 1];

751 int 
	gcountTop
 = 0;

752 int 
	glx
 = 
left
.
x
;

753 for (int 
	gk
 = 1; k < 
	gedgeSegmentSize
; ++k) {

754 if (
	gedgeSegment
[
k
].
	gx
 == 
lx
)

756 
	gcountTop
 += (
edgeSegment
[
k
].
y
 - 
left
.y);

757 
	glx
 = 
edgeSegment
[
k
].
x
;

760 int 
	gwidth
 = 
abs
(
right
.
x
 - 
left
.x) + 1;

761 int 
	gheight
 = 
abs
(
right
.
y
 - 
left
.y) + 1;

762 int 
	gcountBottom
 = (
width
 * 
height
) - 
edgeSegmentSize
 - 
countTop
;

764 if (
	gcountBottom
 > 
	gcountTop
)

765 
	gpoints_1
.
push_back
(
edgeSegment
);

766 else if (
	gcountBottom
 < 
	gcountTop
)

767 
	gpoints_3
.
push_back
(
edgeSegment
);

771 void 
	gEllipseDetectorImpl
::
detectEdges24
(
Mat1b
 &
DN
, 
VVP
 &
points_2
, VVP &
points_4
) {

773 
VVP
 
	gcontours
;

775 
labeling
(
DN
, 
contours
, 
_minEdgeLength
);

776 int 
	gcontourSize
 = int(
contours
.
size
());

779 for (int 
	gi
 = 0; i < 
	gcontourSize
; i++) {

780 
	gVP
 &
	gedgeSegment
 = 
contours
[
i
];

783 
RotatedRect
 
	goriented
 = 
minAreaRect
(
edgeSegment
);

784 float 
	gorMin
 = 
min
(
oriented
.
size
.
width
, oriented.size.
height
);

786 if (
	gorMin
 < 
	g_minOrientedRectSide
) {

791 
	gstd
::
sort
(
edgeSegment
.
begin
(), edgeSegment.
end
(), 
sortPoint
);

792 int 
	gedgeSegmentSize
 = unsigned(
edgeSegment
.
size
());

795 
	gPoint
 &
	gleft
 = 
edgeSegment
[0];

796 
	gPoint
 &
	gright
 = 
edgeSegment
[
edgeSegmentSize
 - 1];

799 int 
	gcountBottom
 = 0;

800 int 
	glx
 = 
left
.
x
;

801 for (int 
	gk
 = 0; k < 
	gedgeSegmentSize
; ++k) {

802 if (
	gedgeSegment
[
k
].
	gx
 == 
lx
)

804 
	gcountBottom
 += (
left
.
y
 - 
edgeSegment
[
k
].y);

805 
	glx
 = 
edgeSegment
[
k
].
x
;

808 int 
	gwidth
 = 
abs
(
right
.
x
 - 
left
.x) + 1;

809 int 
	gheight
 = 
abs
(
right
.
y
 - 
left
.y) + 1;

810 int 
	gcountTop
 = (
width
 * 
height
) - 
edgeSegmentSize
 - 
countBottom
;

812 if (
	gcountBottom
 > 
	gcountTop
)

813 
	gpoints_2
.
push_back
(
edgeSegment
);

814 else if (
	gcountBottom
 < 
	gcountTop
)

815 
	gpoints_4
.
push_back
(
edgeSegment
);

819 #define 
	#T124
 
pjf
,
pjm
,
pjl
,
pif
,
pim
,
pil


	)

820 #define 
	#T231
 
pil
,
pim
,
pif
,
pjf
,
pjm
,
pjl


	)

821 #define 
	#T342
 
pif
,
pim
,
pil
,
pjf
,
pjm
,
pjl


	)

822 #define 
	#T413
 
pif
,
pim
,
pil
,
pjl
,
pjm
,
pjf


	)

824 void 
	gEllipseDetectorImpl
::
getTriplets124
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
,

825 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

826 
std
::
vector
<
Ellipse
> &
ellipses
) {

828 auto 
sz_i
 = 
ushort
(
pi
.
size
());

829 auto 
	gsz_j
 = 
ushort
(
pj
.
size
());

830 auto 
	gsz_k
 = 
ushort
(
pk
.
size
());

833 for (
ushort
 
	gi
 = 0; i < 
	gsz_i
; i++) {

834 
	gVP
 &
	gedge_i
 = 
pi
[
i
];

835 auto 
	gsz_ei
 = 
ushort
(
edge_i
.
size
());

837 
	gPoint
 &
	gpif
 = 
edge_i
[0];

838 
	gPoint
 &
	gpim
 = 
edge_i
[
sz_ei
 / 2];

839 
	gPoint
 &
	gpil
 = 
edge_i
[
sz_ei
 - 1];

842 
VP
 
rev_i
(
edge_i
.
size
());

843 
	gstd
::
reverse_copy
(
edge_i
.
begin
(), edge_i.
end
(), 
rev_i
.begin());

846 for (
ushort
 
	gj
 = 0; j < 
	gsz_j
; ++j) {

847 
	gVP
 &
	gedge_j
 = 
pj
[
j
];

848 auto 
	gsz_ej
 = 
ushort
(
edge_j
.
size
());

850 
	gPoint
 &
	gpjf
 = 
edge_j
[0];

851 
	gPoint
 &
	gpjm
 = 
edge_j
[
sz_ej
 / 2];

852 
	gPoint
 &
	gpjl
 = 
edge_j
[
sz_ej
 - 1];

855 if (
	gpjl
.
	gx
 > 
	gpif
.x + 
	g_positionThreshold
)

859 const float 
	gCNC_THRESHOLD
 = 0.3f;

860 if (
fabs
(
valueOfPoints
(
T124
) - 1) > 
	gCNC_THRESHOLD
)

863 
uint
 
	gkey_ij
 = 
generateKey
(
PAIR_12
, 
i
, 
j
);

866 for (
ushort
 
	gk
 = 0; k < 
	gsz_k
; ++k) {

867 
	gVP
 &
	gedge_k
 = 
pk
[
k
];

868 auto 
	gsz_ek
 = 
ushort
(
edge_k
.
size
());

870 
	gPoint
 &
	gpkl
 = 
edge_k
[
sz_ek
 - 1];

873 if (
	gpkl
.
	gy
 < 
	gpil
.y - 
	g_positionThreshold
)

876 
uint
 
	gkey_ik
 = 
generateKey
(
PAIR_14
, 
i
, 
k
);

879 
EllipseData
 
	gdata_ij
, 
	gdata_ik
;

882 if (
	gdata
.
count
(
key_ij
) == 0) {

883 
getFastCenter
(
edge_j
, 
rev_i
, 
data_ij
);

885 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ij
, 
data_ij
));

888 
	gdata_ij
 = 
data
.
at
(
key_ij
);

892 if (
	gdata
.
count
(
key_ik
) == 0) {

893 
getFastCenter
(
edge_i
, 
edge_k
, 
data_ik
);

895 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ik
, 
data_ik
));

898 
	gdata_ik
 = 
data
.
at
(
key_ik
);

902 if (!
	gdata_ij
.
	gisValid
 || !
	gdata_ik
.isValid)

907 if (
pointDistance2
(
data_ij
.
Cab
, 
data_ik
.Cab) > 
	g_maxCenterDistance2
)

912 
Point2f
 
	gcenter
 = 
getCenterCoordinates
(
data_ij
, 
data_ik
);

914 
findEllipses
(
center
, 
edge_i
, 
edge_j
, 
edge_k
, 
data_ij
, 
data_ik
, 
ellipses
);

920 void 
	gEllipseDetectorImpl
::
getTriplets231
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
,

921 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

922 
std
::
vector
<
Ellipse
> &
ellipses
) {

924 auto 
sz_i
 = 
ushort
(
pi
.
size
());

925 auto 
	gsz_j
 = 
ushort
(
pj
.
size
());

926 auto 
	gsz_k
 = 
ushort
(
pk
.
size
());

929 for (
ushort
 
	gi
 = 0; i < 
	gsz_i
; i++) {

930 
	gVP
 &
	gedge_i
 = 
pi
[
i
];

931 auto 
	gsz_ei
 = 
ushort
(
edge_i
.
size
());

933 
	gPoint
 &
	gpif
 = 
edge_i
[0];

934 
	gPoint
 &
	gpim
 = 
edge_i
[
sz_ei
 / 2];

935 
	gPoint
 &
	gpil
 = 
edge_i
[
sz_ei
 - 1];

938 
VP
 
rev_i
(
edge_i
.
size
());

939 
	gstd
::
reverse_copy
(
edge_i
.
begin
(), edge_i.
end
(), 
rev_i
.begin());

942 for (
ushort
 
	gj
 = 0; j < 
	gsz_j
; ++j) {

943 
	gVP
 &
	gedge_j
 = 
pj
[
j
];

944 auto 
	gsz_ej
 = 
ushort
(
edge_j
.
size
());

946 
	gPoint
 &
	gpjf
 = 
edge_j
[0];

947 
	gPoint
 &
	gpjm
 = 
edge_j
[
sz_ej
 / 2];

948 
	gPoint
 &
	gpjl
 = 
edge_j
[
sz_ej
 - 1];

951 if (
	gpjf
.
	gy
 < 
	gpif
.y - 
	g_positionThreshold
)

955 const float 
	gCNC_THRESHOLD
 = 0.3f;

956 if (
fabs
(
valueOfPoints
(
T231
) - 1) > 
	gCNC_THRESHOLD
)

960 
VP
 
rev_j
(
edge_j
.
size
());

961 
	gstd
::
reverse_copy
(
edge_j
.
begin
(), edge_j.
end
(), 
rev_j
.begin());

963 
uint
 
	gkey_ij
 = 
generateKey
(
PAIR_23
, 
i
, 
j
);

966 for (
ushort
 
	gk
 = 0; k < 
	gsz_k
; ++k) {

967 
	gVP
 &
	gedge_k
 = 
pk
[
k
];

969 
	gPoint
 &
	gpkf
 = 
edge_k
[0];

972 if (
	gpkf
.
	gx
 < 
	gpil
.x - 
	g_positionThreshold
)

975 
uint
 
	gkey_ik
 = 
generateKey
(
PAIR_12
, 
k
, 
i
);

978 
EllipseData
 
	gdata_ij
, 
	gdata_ik
;

981 if (
	gdata
.
count
(
key_ij
) == 0) {

982 
getFastCenter
(
rev_i
, 
rev_j
, 
data_ij
);

984 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ij
, 
data_ij
));

987 
	gdata_ij
 = 
data
.
at
(
key_ij
);

991 if (
	gdata
.
count
(
key_ik
) == 0) {

993 
VP
 
rev_k
(
edge_k
.
size
());

994 
	gstd
::
reverse_copy
(
edge_k
.
begin
(), edge_k.
end
(), 
rev_k
.begin());

996 
getFastCenter
(
edge_i
, 
rev_k
, 
data_ik
);

997 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ik
, 
data_ik
));

1000 
	gdata_ik
 = 
data
.
at
(
key_ik
);

1004 if (!
	gdata_ij
.
	gisValid
 || !
	gdata_ik
.isValid)

1009 if (
pointDistance2
(
data_ij
.
Cab
, 
data_ik
.Cab) > 
	g_maxCenterDistance2
)

1014 
Point2f
 
	gcenter
 = 
getCenterCoordinates
(
data_ij
, 
data_ik
);

1016 
findEllipses
(
center
, 
edge_i
, 
edge_j
, 
edge_k
, 
data_ij
, 
data_ik
, 
ellipses
);

1022 void 
	gEllipseDetectorImpl
::
getTriplets342
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
,

1023 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

1024 
std
::
vector
<
Ellipse
> &
ellipses
) {

1026 auto 
sz_i
 = 
ushort
(
pi
.
size
());

1027 auto 
	gsz_j
 = 
ushort
(
pj
.
size
());

1028 auto 
	gsz_k
 = 
ushort
(
pk
.
size
());

1031 for (
ushort
 
	gi
 = 0; i < 
	gsz_i
; i++) {

1032 
	gVP
 &
	gedge_i
 = 
pi
[
i
];

1033 auto 
	gsz_ei
 = 
ushort
(
edge_i
.
size
());

1035 
	gPoint
 &
	gpif
 = 
edge_i
[0];

1036 
	gPoint
 &
	gpim
 = 
edge_i
[
sz_ei
 / 2];

1037 
	gPoint
 &
	gpil
 = 
edge_i
[
sz_ei
 - 1];

1040 
VP
 
rev_i
(
edge_i
.
size
());

1041 
	gstd
::
reverse_copy
(
edge_i
.
begin
(), edge_i.
end
(), 
rev_i
.begin());

1044 for (
ushort
 
	gj
 = 0; j < 
	gsz_j
; ++j) {

1045 
	gVP
 &
	gedge_j
 = 
pj
[
j
];

1046 auto 
	gsz_ej
 = 
ushort
(
edge_j
.
size
());

1048 
	gPoint
 &
	gpjf
 = 
edge_j
[0];

1049 
	gPoint
 &
	gpjm
 = 
edge_j
[
sz_ej
 / 2];

1050 
	gPoint
 &
	gpjl
 = 
edge_j
[
sz_ej
 - 1];

1053 if (
	gpjf
.
	gx
 < 
	gpil
.x - 
	g_positionThreshold
)

1057 const float 
	gCNC_THRESHOLD
 = 0.3f;

1058 if (
fabs
(
valueOfPoints
(
T342
) - 1) > 
	gCNC_THRESHOLD
)

1062 
VP
 
rev_j
(
edge_j
.
size
());

1063 
	gstd
::
reverse_copy
(
edge_j
.
begin
(), edge_j.
end
(), 
rev_j
.begin());

1065 
uint
 
	gkey_ij
 = 
generateKey
(
PAIR_34
, 
i
, 
j
);

1068 for (
ushort
 
	gk
 = 0; k < 
	gsz_k
; ++k) {

1069 
	gVP
 &
	gedge_k
 = 
pk
[
k
];

1071 
	gPoint
 &
	gpkf
 = 
edge_k
[0];

1074 if (
	gpkf
.
	gy
 > 
	gpif
.y + 
	g_positionThreshold
)

1077 
uint
 
	gkey_ik
 = 
generateKey
(
PAIR_23
, 
k
, 
i
);

1080 
EllipseData
 
	gdata_ij
, 
	gdata_ik
;

1083 if (
	gdata
.
count
(
key_ij
) == 0) {

1084 
getFastCenter
(
edge_i
, 
rev_j
, 
data_ij
);

1086 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ij
, 
data_ij
));

1089 
	gdata_ij
 = 
data
.
at
(
key_ij
);

1093 if (
	gdata
.
count
(
key_ik
) == 0) {

1095 
VP
 
rev_k
(
edge_k
.
size
());

1096 
	gstd
::
reverse_copy
(
edge_k
.
begin
(), edge_k.
end
(), 
rev_k
.begin());

1098 
getFastCenter
(
rev_i
, 
rev_k
, 
data_ik
);

1099 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ik
, 
data_ik
));

1102 
	gdata_ik
 = 
data
.
at
(
key_ik
);

1106 if (!
	gdata_ij
.
	gisValid
 || !
	gdata_ik
.isValid)

1111 if (
pointDistance2
(
data_ij
.
Cab
, 
data_ik
.Cab) > 
	g_maxCenterDistance2
)

1116 
Point2f
 
	gcenter
 = 
getCenterCoordinates
(
data_ij
, 
data_ik
);

1118 
findEllipses
(
center
, 
edge_i
, 
edge_j
, 
edge_k
, 
data_ij
, 
data_ik
, 
ellipses
);

1125 void 
	gEllipseDetectorImpl
::
getTriplets413
(
VVP
 &
pi
, VVP &
pj
, VVP &
pk
,

1126 
std
::
unordered_map
<
uint
, 
EllipseData
> &
data
,

1127 
std
::
vector
<
Ellipse
> &
ellipses
) {

1129 auto 
sz_i
 = 
ushort
(
pi
.
size
());

1130 auto 
	gsz_j
 = 
ushort
(
pj
.
size
());

1131 auto 
	gsz_k
 = 
ushort
(
pk
.
size
());

1134 for (
ushort
 
	gi
 = 0; i < 
	gsz_i
; i++) {

1135 
	gVP
 &
	gedge_i
 = 
pi
[
i
];

1136 auto 
	gsz_ei
 = 
ushort
(
edge_i
.
size
());

1138 
	gPoint
 &
	gpif
 = 
edge_i
[0];

1139 
	gPoint
 &
	gpim
 = 
edge_i
[
sz_ei
 / 2];

1140 
	gPoint
 &
	gpil
 = 
edge_i
[
sz_ei
 - 1];

1143 
VP
 
rev_i
(
edge_i
.
size
());

1144 
	gstd
::
reverse_copy
(
edge_i
.
begin
(), edge_i.
end
(), 
rev_i
.begin());

1147 for (
ushort
 
	gj
 = 0; j < 
	gsz_j
; ++j) {

1148 
	gVP
 &
	gedge_j
 = 
pj
[
j
];

1149 auto 
	gsz_ej
 = 
ushort
(
edge_j
.
size
());

1151 
	gPoint
 &
	gpjf
 = 
edge_j
[0];

1152 
	gPoint
 &
	gpjm
 = 
edge_j
[
sz_ej
 / 2];

1153 
	gPoint
 &
	gpjl
 = 
edge_j
[
sz_ej
 - 1];

1156 if (
	gpjl
.
	gy
 > 
	gpil
.y + 
	g_positionThreshold
)

1160 const float 
	gCNC_THRESHOLD
 = 0.3f;

1161 if (
fabs
(
valueOfPoints
(
T413
) - 1) > 
	gCNC_THRESHOLD
)

1164 
uint
 
	gkey_ij
 = 
generateKey
(
PAIR_14
, 
j
, 
i
);

1167 for (
ushort
 
	gk
 = 0; k < 
	gsz_k
; ++k) {

1168 
	gVP
 &
	gedge_k
 = 
pk
[
k
];

1169 auto 
	gsz_ek
 = 
ushort
(
edge_k
.
size
());

1171 
	gPoint
 &
	gpkl
 = 
edge_k
[
sz_ek
 - 1];

1174 if (
	gpkl
.
	gx
 > 
	gpif
.x + 
	g_positionThreshold
)

1177 
uint
 
	gkey_ik
 = 
generateKey
(
PAIR_34
, 
k
, 
i
);

1180 
EllipseData
 
	gdata_ij
, 
	gdata_ik
;

1183 if (
	gdata
.
count
(
key_ij
) == 0) {

1184 
getFastCenter
(
edge_i
, 
edge_j
, 
data_ij
);

1186 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ij
, 
data_ij
));

1189 
	gdata_ij
 = 
data
.
at
(
key_ij
);

1193 if (
	gdata
.
count
(
key_ik
) == 0) {

1194 
getFastCenter
(
rev_i
, 
edge_k
, 
data_ik
);

1195 
	gdata
.
insert
(
std
::
pair
<
uint
, 
EllipseData
>(
key_ik
, 
data_ik
));

1198 
	gdata_ik
 = 
data
.
at
(
key_ik
);

1202 if (!
	gdata_ij
.
	gisValid
 || !
	gdata_ik
.isValid)

1207 if (
pointDistance2
(
data_ij
.
Cab
, 
data_ik
.Cab) > 
	g_maxCenterDistance2
)

1212 
Point2f
 
	gcenter
 = 
getCenterCoordinates
(
data_ij
, 
data_ik
);

1214 
findEllipses
(
center
, 
edge_i
, 
edge_j
, 
edge_k
, 
data_ij
, 
data_ik
, 
ellipses
);

1221 void 
	gEllipseDetectorImpl
::
preProcessing
(
Mat1b
 &
image
, Mat1b &
dp
, Mat1b &
dn
) {

1223 
GaussianBlur
(
image
, image, 
_kernelSize
, 
_sigma
);

1226 
Mat1b
 
	gedges
;

1227 
Mat1s
 
	gdx
, 
	gdy
;

1230 
Sobel
(
image
, 
dx
, 
CV_16S
, 1, 0, 3, 1, 0, 
BORDER_REPLICATE
);

1231 
Sobel
(
image
, 
dy
, 
CV_16S
, 0, 1, 3, 1, 0, 
BORDER_REPLICATE
);

1234 
Size
 
	gimgSize
 = 
image
.
size
();

1235 
	gedges
.
create
(
imgSize
);

1236 
Mat1f
 
magGrad
(
imgSize
.
height
, imgSize.
width
, 0.f);

1237 float 
maxGrad
(0);

1238 for (int 
	gi
 = 0; i < 
	gimgSize
.
	gheight
; i++) {

1239 auto *
	gtmpMag
 = 
magGrad
.
ptr
<float>(
i
);

1240 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++) {

1241 auto 
	gval
 = float(
abs
(
dx
[
i
][
j
]) + abs(
dy
[i][j]));

1242 
	gtmpMag
[
j
] = 
val
;

1243 
	gmaxGrad
 = (
val
 > 
maxGrad
) ? val : maxGrad;

1248 const int 
	gNUM_BINS
 = 64;

1249 const double 
	gPERCENT_OF_PIXEL_NOT_EDGES
 = 0.9f, 
	gRATIO_THRESHOLD
 = 0.3f;

1252 int 
	gbinSize
 = 
cvFloor
(
maxGrad
 / float(
NUM_BINS
) + 0.5f) + 1;

1253 
	gbinSize
 = 
max
(1, 
binSize
);

1254 int 
	gbins
[
NUM_BINS
] = {0};

1255 for (int 
	gi
 = 0; i < 
	gimgSize
.
	gheight
; i++) {

1256 auto *
	gtmpMag
 = 
magGrad
.
ptr
<float>(
i
);

1257 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++)

1258 
	gbins
[int(
tmpMag
[
j
]) / 
	gbinSize
]++;

1262 float 
	gtotal
 = 0.f;

1263 auto 
	gtarget
 = float(
imgSize
.
height
 * imgSize.
width
 * 
PERCENT_OF_PIXEL_NOT_EDGES
);

1264 int 
	glowTh
, 
highTh
(0);

1266 while (
	gtotal
 < 
	gtarget
) {

1267 
	gtotal
 += 
bins
[
highTh
];

1268 
	ghighTh
++;

1270 
	ghighTh
 = 
cvFloor
(
highTh
 * 
binSize
);

1271 
	glowTh
 = 
cvFloor
(
RATIO_THRESHOLD
 * float(
highTh
));

1274 int *
	gmagBuffer
[3];

1275 
	gAutoBuffer
<int> 
buffer
((
imgSize
.
width
 + 2) * (imgSize.
height
 + 2) +

1276 (
imgSize
.
width
 + 2) * 3);

1277 
	gmagBuffer
[0] = 
buffer
.
data
();

1278 
	gmagBuffer
[1] = 
magBuffer
[0] + 
imgSize
.
width
 + 2;

1279 
	gmagBuffer
[2] = 
magBuffer
[1] + 
imgSize
.
width
 + 2;

1280 
uchar
 *
	gmap
 = (uchar *) (
magBuffer
[2] + 
imgSize
.
width
 + 2);

1281 
ptrdiff_t
 
	gmapStep
 = 
imgSize
.
width
 + 2;

1283 int 
	gmaxSize
 = 
MAX
(1 << 10, 
imgSize
.
width
 * imgSize.
height
 / 10);

1284 
	gstd
::
vector
<
uchar
 *> 
stack
;

1285 
	gstack
.
resize
(
maxSize
);

1286 
uchar
 **
	gstackTop
 = 0, **
	gstackBottom
 = 0;

1287 
	gstackTop
 = 
stackBottom
 = &
stack
[0];

1289 
memset
(
magBuffer
[0], 0, (
imgSize
.
width
 + 2) * sizeof(int));

1290 
memset
(
map
, 1, 
mapStep
);

1291 
memset
(
map
 + 
mapStep
 * (
imgSize
.
height
 + 1), 1, mapStep);

1293 
Mat
 
	gmagRow
;

1294 
	gmagRow
.
create
(1, 
imgSize
.
width
, 
CV_32F
);

1301 for (int 
	gi
 = 0; i <= 
imgSize
.
height
; i++) {

1302 int *
	gtmpMag
 = 
magBuffer
[(
i
 > 0) + 1] + 1;

1303 const short *
	gtmpDx
 = 
dx
.
ptr
<short>(
i
);

1304 const short *
	gtmpDy
 = 
dy
.
ptr
<short>(
i
);

1305 
uchar
 *
	gtmpMap
;

1306 int 
	gprevFlag
 = 0;

1308 if (
	gi
 < 
	gimgSize
.
	gheight
) {

1309 
	gtmpMag
[-1] = 
tmpMag
[
imgSize
.
width
] = 0;

1310 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++)

1311 
	gtmpMag
[
j
] = 
abs
(
tmpDx
[j]) + abs(
tmpDy
[j]);

1313 
memset
(
tmpMag
 - 1, 0, (
imgSize
.
width
 + 2) * sizeof(int));

1317 if (
	gi
 == 0)

1320 
	gtmpMap
 = 
map
 + 
mapStep
 * 
i
 + 1;

1321 
	gtmpMap
[-1] = 
tmpMap
[
imgSize
.
width
] = 1;

1323 
	gtmpMag
 = 
magBuffer
[1] + 1;

1324 
	gtmpDx
 = (short *) (
dx
[
i
 - 1]);

1325 
	gtmpDy
 = (short *) (
dy
[
i
 - 1]);

1327 
ptrdiff_t
 
	gmagStep1
, 
	gmagStep2
;

1328 
	gmagStep1
 = 
magBuffer
[2] - magBuffer[1];

1329 
	gmagStep2
 = 
magBuffer
[0] - magBuffer[1];

1331 if ((
	gstackTop
 - 
	gstackBottom
) + 
	gimgSize
.
	gwidth
 > 
	gmaxSize
) {

1332 int 
	gstackSize
 = (int) (
stackTop
 - 
stackBottom
);

1333 
	gmaxSize
 = 
MAX
(
maxSize
 * 3 / 2, maxSize + 8);

1334 
	gstack
.
resize
(
maxSize
);

1335 
	gstackBottom
 = &
stack
[0];

1336 
	gstackTop
 = 
stackBottom
 + 
stackSize
;

1339 const int 
	gCANNY_SHIFT
 = 15;

1340 const float 
	gTAN22_5
 = 0.4142135623730950488016887242097f;

1341 const int 
	gTG22
 = (int) (
TAN22_5
 * (1 << 
CANNY_SHIFT
) + 0.5);

1346 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++) {

1347 int 
	gx
 = 
tmpDx
[
j
], 
	gy
 = 
tmpDy
[j];

1348 int 
	gs
 = 
x
 ^ 
y
;

1349 int 
	gm
 = 
tmpMag
[
j
];

1350 
	gx
 = 
abs
(
x
), 
	gy
 = abs(
y
);

1351 if (
	gm
 > 
	glowTh
) {

1352 int 
	gtg22x
 = 
x
 * 
TG22
;

1353 int 
	gtg67x
 = 
tg22x
 + ((
x
 + x) << 
CANNY_SHIFT
);

1355 
	gy
 <<= 
CANNY_SHIFT
;

1356 if (
	gy
 < 
	gtg22x
) {

1357 if (
	gm
 > 
	gtmpMag
[
j
 - 1] && m >= 
tmpMag
[j + 1]) {

1358 if (
m
 > 
highTh
 && !
prevFlag
 && 
tmpMap
[
j
 - 
mapStep
] != 2) {

1359 
tmpMap
[
j
] = (
uchar
) 2;

1360 *
	gstackTop
++ = (
tmpMap
 + 
j
);

1361 
	gprevFlag
 = 1;

1363 
	gtmpMap
[
j
] = (
uchar
) 0;

1366 } else if (
	gy
 > 
	gtg67x
) {

1367 if (
	gm
 > 
	gtmpMag
[
j
 + 
magStep2
] && m >= 
tmpMag
[j + 
magStep1
]) {

1368 if (
m
 > 
highTh
 && !
prevFlag
 && 
tmpMap
[
j
 - 
mapStep
] != 2) {

1369 
tmpMap
[
j
] = (
uchar
) 2;

1370 *
	gstackTop
++ = (
tmpMap
 + 
j
);

1371 
	gprevFlag
 = 1;

1373 
	gtmpMap
[
j
] = (
uchar
) 0;

1377 
	gs
 = 
s
 < 0 ? -1 : 1;

1378 if (
	gm
 > 
	gtmpMag
[
j
 + 
magStep2
 - 
s
] && m > tmpMag[j + 
magStep1
 + s]) {

1379 if (
	gm
 > 
	ghighTh
 && !
	gprevFlag
 && 
	gtmpMap
[
j
 - 
mapStep
] != 2) {

1380 
tmpMap
[
j
] = (
uchar
) 2;

1381 *
	gstackTop
++ = (
tmpMap
 + 
j
);

1382 
	gprevFlag
 = 1;

1384 
	gtmpMap
[
j
] = (
uchar
) 0;

1389 
	gprevFlag
 = 0;

1390 
	gtmpMap
[
j
] = (
uchar
) 1;

1394 
	gtmpMag
 = 
magBuffer
[0];

1395 
	gmagBuffer
[0] = 
magBuffer
[1];

1396 
	gmagBuffer
[1] = 
magBuffer
[2];

1397 
	gmagBuffer
[2] = 
tmpMag
;

1401 while (
	gstackTop
 > 
	gstackBottom
) {

1402 
uchar
 *
	gm
;

1403 if ((
	gstackTop
 - 
	gstackBottom
) + 8 > 
	gmaxSize
) {

1404 int 
	gstackSize
 = (int) (
stackTop
 - 
stackBottom
);

1405 
	gmaxSize
 = 
MAX
(
maxSize
 * 3 / 2, maxSize + 8);

1406 
	gstack
.
resize
(
maxSize
);

1407 
	gstackBottom
 = &
stack
[0];

1408 
	gstackTop
 = 
stackBottom
 + 
stackSize
;

1411 
	gm
 = *--
stackTop
;

1412 if (!
	gm
[-1]) {

1413 *(
	gm
 - 1) = (
uchar
) 2;

1414 *
	gstackTop
++ = 
m
 - 1;

1416 if (!
	gm
[1]) {

1417 *(
	gm
 + 1) = (
uchar
) 2;

1418 *
	gstackTop
++ = 
m
 + 1;

1420 if (!
	gm
[-
mapStep
 - 1]) {

1421 *(
	gm
 - 
	gmapStep
 - 1) = (
uchar
) 2;

1422 *
	gstackTop
++ = 
m
 - 
mapStep
 - 1;

1424 if (!
	gm
[-
mapStep
]) {

1425 *(
	gm
 - 
	gmapStep
) = (
uchar
) 2;

1426 *
	gstackTop
++ = 
m
 - 
mapStep
;

1428 if (!
	gm
[-
mapStep
 + 1]) {

1429 *(
	gm
 - 
	gmapStep
 + 1) = (
uchar
) 2;

1430 *
	gstackTop
++ = 
m
 - 
mapStep
 + 1;

1432 if (!
	gm
[
mapStep
 - 1]) {

1433 *(
	gm
 + 
	gmapStep
 - 1) = (
uchar
) 2;

1434 *
	gstackTop
++ = 
m
 + 
mapStep
 - 1;

1436 if (!
	gm
[
mapStep
]) {

1437 *(
	gm
 + 
	gmapStep
) = (
uchar
) 2;

1438 *
	gstackTop
++ = 
m
 + 
mapStep
;

1440 if (!
	gm
[
mapStep
 + 1]) {

1441 *(
	gm
 + 
	gmapStep
 + 1) = (
uchar
) 2;

1442 *
	gstackTop
++ = 
m
 + 
mapStep
 + 1;

1447 for (int 
	gi
 = 0; i < 
	gimgSize
.
	gheight
; i++) {

1448 const 
uchar
 *
	gtmpMap
 = 
map
 + 
mapStep
 * (
i
 + 1) + 1;

1449 
uchar
 *
	gtmpDst
 = 
edges
[
i
];

1450 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++)

1451 
	gtmpDst
[
j
] = (
uchar
) -(
tmpMap
[j] >> 1);

1455 for (int 
	gi
 = 0; i < 
	gimgSize
.
	gheight
; i++) {

1456 auto *
	gtmpDx
 = 
dx
.
ptr
<short>(
i
);

1457 auto *
	gtmpDy
 = 
dy
.
ptr
<short>(
i
);

1458 auto *
	gtmpE
 = 
edges
.
ptr
<
uchar
>(
i
);

1459 auto *
	gtmpDp
 = 
dp
.
ptr
<
uchar
>(
i
);

1460 auto *
	gtmpDn
 = 
dn
.
ptr
<
uchar
>(
i
);

1462 for (int 
	gj
 = 0; j < 
	gimgSize
.
	gwidth
; j++) {

1463 if (!((
	gtmpE
[
j
] <= 0) || (
tmpDx
[j] == 0) || (
tmpDy
[j] == 0))) {

1465 float 
phi
 = -(float(
tmpDx
[
j
])) / float(
tmpDy
[j]);

1467 if (
	gphi
 > 0)

1468 
	gtmpDp
[
j
] = (
uchar
) 255;

1469 else if (
	gphi
 < 0)

1470 
	gtmpDn
[
j
] = (
uchar
) 255;

1476 void 
	gEllipseDetectorImpl
::
detect
(
Mat1b
 &
image
, 
std
::
vector
<
Ellipse
> &
ellipses
) {

1477 
countsOfFindEllipse
 = 0, 
	gcountsOfGetFastCenter
 = 0;

1480 
	g_imgSize
 = 
image
.
size
();

1483 
Mat1b
 
	gdp
 = Mat1b::
zeros
(
_imgSize
);

1484 
Mat1b
 
	gdn
 = Mat1b::
zeros
(
_imgSize
);

1487 
	gACC_N_SIZE
 = 101, 
	gACC_R_SIZE
 = 180, 
	gACC_A_SIZE
 = 
max
(
_imgSize
.
height
, _imgSize.
width
);

1490 
	gaccN
 = 
new
 int[
ACC_N_SIZE
], 
	gaccR
 = new int[
ACC_R_SIZE
], 
	gaccA
 = new int[
ACC_A_SIZE
];

1493 
VVP
 
	gpoints_1
, 
	gpoints_2
, 
	gpoints_3
, 
	gpoints_4
;

1494 
	gstd
::
unordered_map
<
uint
, 
	gEllipseData
> 
	gcenters
;

1498 
preProcessing
(
image
, 
dp
, 
dn
);

1501 
detectEdges13
(
dp
, 
points_1
, 
points_3
);

1502 
detectEdges24
(
dn
, 
points_2
, 
points_4
);

1505 
getTriplets124
(
points_1
, 
points_2
, 
points_4
, 
centers
, 
ellipses
);

1506 
getTriplets231
(
points_2
, 
points_3
, 
points_1
, 
centers
, 
ellipses
);

1507 
getTriplets342
(
points_3
, 
points_4
, 
points_2
, 
centers
, 
ellipses
);

1508 
getTriplets413
(
points_4
, 
points_1
, 
points_3
, 
centers
, 
ellipses
);

1511 
	gstd
::
sort
(
ellipses
.
begin
(), ellipses.
end
());

1514 
	gdelete
[]
	gaccN
;

1515 
	gdelete
[]
	gaccR
;

1516 
	gdelete
[]
	gaccA
;

1519 
clusterEllipses
(
ellipses
);

1522 void 
	gEllipseDetectorImpl
::
findEllipses
(
Point2f
 &
center
, 
VP
 &
edge_i
, VP &
edge_j
, VP &
edge_k
,

1523 
EllipseData
 &
data_ij
, EllipseData &
data_ik
,

1524 
std
::
vector
<
Ellipse
> &
ellipses
) {

1525 
countsOfFindEllipse
++;

1529 
memset
(
accN
, 0, sizeof(int) * 
ACC_N_SIZE
);

1530 
memset
(
accR
, 0, sizeof(int) * 
ACC_R_SIZE
);

1531 
memset
(
accA
, 0, sizeof(int) * 
ACC_A_SIZE
);

1535 int 
	gsz_ij1
 = int(
data_ij
.
Sa
.
size
());

1536 int 
	gsz_ij2
 = int(
data_ij
.
Sb
.
size
());

1537 int 
	gsz_ik1
 = int(
data_ik
.
Sa
.
size
());

1538 int 
	gsz_ik2
 = int(
data_ik
.
Sb
.
size
());

1541 
size_t
 
	gsz_ei
 = 
edge_i
.
size
();

1542 
size_t
 
	gsz_ej
 = 
edge_j
.
size
();

1543 
size_t
 
	gsz_ek
 = 
edge_k
.
size
();

1546 float 
	ga0
 = 
center
.
x
;

1547 float 
	gb0
 = 
center
.
y
;

1553 float 
	gq1
 = 
data_ij
.
ra
;

1554 float 
	gq3
 = 
data_ik
.
ra
;

1555 float 
	gq5
 = 
data_ik
.
rb
;

1557 for (int 
	gij1
 = 0; ij1 < 
	gsz_ij1
; ij1++) {

1558 float 
	gq2
 = 
data_ij
.
Sa
[
ij1
];

1560 float 
	gq1xq2
 = 
q1
 * 
q2
;

1562 for (int 
	gik1
 = 0; ik1 < 
	gsz_ik1
; ik1++) {

1563 float 
	gq4
 = 
data_ik
.
Sa
[
ik1
];

1565 float 
	gq3xq4
 = 
q3
 * 
q4
;

1569 float 
	ga
 = (
q1xq2
 - 
q3xq4
);

1570 float 
	gb
 = (
q3xq4
 + 1) * (
q1
 + 
q2
) - (
q1xq2
 + 1) * (
q3
 + 
q4
);

1571 float 
	gKp
 = (-
b
 + 
sqrt
(b * b + 4 * 
a
 * a)) / (2 * a);

1572 float 
	gzplus
 = ((
q1
 - 
Kp
) * (
q2
 - Kp)) / ((1 + q1 * Kp) * (1 + q2 * Kp));

1575 if (
	gzplus
 >= 0.0f) continue;

1577 float 
	gNp
 = 
sqrt
(-
zplus
);

1578 float 
	grho
 = 
atan
(
Kp
);

1579 int 
	grhoDeg
;

1580 if (
	gNp
 > 1.f) {

1582 
	gNp
 = 1.f / 
Np
;

1583 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 180) % 180;

1586 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 90) % 180;

1589 int 
	giNp
 = 
cvRound
(
Np
 * 100);

1591 if (0 <= 
iNp
 && iNp < 
ACC_N_SIZE
 && 0 <= 
rhoDeg
 && rhoDeg < 
ACC_R_SIZE
) {

1592 ++
accN
[
iNp
];

1593 ++
	gaccR
[
rhoDeg
];

1598 for (int 
	gik2
 = 0; ik2 < 
	gsz_ik2
; ik2++) {

1599 float 
	gq4
 = 
data_ik
.
Sb
[
ik2
];

1601 float 
	gq5xq4
 = 
q5
 * 
q4
;

1605 float 
	ga
 = (
q1xq2
 - 
q5xq4
);

1606 float 
	gb
 = (
q5xq4
 + 1) * (
q1
 + 
q2
) - (
q1xq2
 + 1) * (
q5
 + 
q4
);

1607 float 
	gKp
 = (-
b
 + 
sqrt
(b * b + 4 * 
a
 * a)) / (2 * a);

1608 float 
	gzplus
 = ((
q1
 - 
Kp
) * (
q2
 - Kp)) / ((1 + q1 * Kp) * (1 + q2 * Kp));

1610 if (
	gzplus
 >= 0.0f)

1613 float 
	gNp
 = 
sqrt
(-
zplus
);

1614 float 
	grho
 = 
atan
(
Kp
);

1615 int 
	grhoDeg
;

1616 if (
	gNp
 > 1.f) {

1618 
	gNp
 = 1.f / 
Np
;

1619 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 180) % 180;

1622 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 90) % 180;

1625 int 
	giNp
 = 
cvRound
(
Np
 * 100);

1627 if (0 <= 
iNp
 && iNp < 
ACC_N_SIZE
 && 0 <= 
rhoDeg
 && rhoDeg < 
ACC_R_SIZE
) {

1628 ++
accN
[
iNp
];

1629 ++
	gaccR
[
rhoDeg
];

1638 float 
	gq1
 = 
data_ij
.
rb
;

1639 float 
	gq3
 = 
data_ik
.
rb
;

1640 float 
	gq5
 = 
data_ik
.
ra
;

1642 for (int 
	gij2
 = 0; ij2 < 
	gsz_ij2
; ij2++) {

1643 float 
	gq2
 = 
data_ij
.
Sb
[
ij2
];

1645 float 
	gq1xq2
 = 
q1
 * 
q2
;

1647 for (int 
	gik2
 = 0; ik2 < 
	gsz_ik2
; ik2++) {

1648 float 
	gq4
 = 
data_ik
.
Sb
[
ik2
];

1650 float 
	gq3xq4
 = 
q3
 * 
q4
;

1654 float 
	ga
 = (
q1xq2
 - 
q3xq4
);

1655 float 
	gb
 = (
q3xq4
 + 1) * (
q1
 + 
q2
) - (
q1xq2
 + 1) * (
q3
 + 
q4
);

1656 float 
	gKp
 = (-
b
 + 
sqrt
(b * b + 4 * 
a
 * a)) / (2 * a);

1657 float 
	gzplus
 = ((
q1
 - 
Kp
) * (
q2
 - Kp)) / ((1 + q1 * Kp) * (1 + q2 * Kp));

1659 if (
	gzplus
 >= 0.0f)

1662 float 
	gNp
 = 
sqrt
(-
zplus
);

1663 float 
	grho
 = 
atan
(
Kp
);

1664 int 
	grhoDeg
;

1665 if (
	gNp
 > 1.f) {

1667 
	gNp
 = 1.f / 
Np
;

1668 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 180) % 180;

1671 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 90) % 180;

1674 int 
	giNp
 = 
cvRound
(
Np
 * 100);

1676 if (0 <= 
iNp
 && iNp < 
ACC_N_SIZE
 && 0 <= 
rhoDeg
 && rhoDeg < 
ACC_R_SIZE
) {

1677 ++
accN
[
iNp
];

1678 ++
	gaccR
[
rhoDeg
];

1683 for (int 
	gik1
 = 0; ik1 < 
	gsz_ik1
; ik1++) {

1684 float 
	gq4
 = 
data_ik
.
Sa
[
ik1
];

1686 float 
	gq5xq4
 = 
q5
 * 
q4
;

1690 float 
	ga
 = (
q1xq2
 - 
q5xq4
);

1691 float 
	gb
 = (
q5xq4
 + 1) * (
q1
 + 
q2
) - (
q1xq2
 + 1) * (
q5
 + 
q4
);

1692 float 
	gKp
 = (-
b
 + 
sqrt
(b * b + 4 * 
a
 * a)) / (2 * a);

1693 float 
	gzplus
 = ((
q1
 - 
Kp
) * (
q2
 - Kp)) / ((1 + q1 * Kp) * (1 + q2 * Kp));

1695 if (
	gzplus
 >= 0.0f) {

1699 float 
	gNp
 = 
sqrt
(-
zplus
);

1700 float 
	grho
 = 
atan
(
Kp
);

1701 int 
	grhoDeg
;

1702 if (
	gNp
 > 1.f) {

1704 
	gNp
 = 1.f / 
Np
;

1705 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 180) % 180;

1708 
	grhoDeg
 = 
cvRound
((
rho
 * 180 / 
CV_PI
) + 90) % 180;

1711 int 
	giNp
 = 
cvRound
(
Np
 * 100);

1713 if (0 <= 
iNp
 && iNp < 
ACC_N_SIZE
 && 0 <= 
rhoDeg
 && rhoDeg < 
ACC_R_SIZE
) {

1714 ++
accN
[
iNp
];

1715 ++
	gaccR
[
rhoDeg
];

1722 int 
	giN
 = (int)
std
::
distance
(
accN
, std::
max_element
(accN, accN + 
ACC_N_SIZE
));

1723 int 
	giK
 = (int)
std
::
distance
(
accR
, std::
max_element
(accR, accR + 
ACC_R_SIZE
)) + 90;

1726 auto 
	gfK
 = float(
iK
);

1727 float 
	gNp
 = float(
iN
) * 0.01f;

1728 float 
	grho
 = 
fK
 * float(
CV_PI
) / 180.f;

1729 float 
	gKp
 = 
tan
(
rho
);

1732 for (
ushort
 
	gl
 = 0; l < 
	gsz_ei
; ++l) {

1733 
	gPoint
 &
	gpp
 = 
edge_i
[
l
];

1734 float 
	gsk
 = 1.f / 
sqrt
(
Kp
 * Kp + 1.f);

1735 float 
	gx0
 = ((
pp
.
x
 - 
a0
) * 
sk
) + (((pp.
y
 - 
b0
) * 
Kp
) * sk);

1736 float 
	gy0
 = -(((
pp
.
x
 - 
a0
) * 
Kp
) * 
sk
) + ((pp.
y
 - 
b0
) * sk);

1737 float 
	gAx
 = 
sqrt
((
x0
 * x0 * 
Np
 * Np + 
y0
 * y0) / ((Np * Np) * (1.f + 
Kp
 * Kp)));

1738 int 
	gA
 = 
cvRound
(
abs
(
Ax
 / 
cos
(
rho
)));

1739 if ((0 <= 
A
) && (A < 
ACC_A_SIZE
))

1740 ++
accA
[
A
];

1743 for (
ushort
 
	gl
 = 0; l < 
	gsz_ej
; ++l) {

1744 
	gPoint
 &
	gpp
 = 
edge_j
[
l
];

1745 float 
	gsk
 = 1.f / 
sqrt
(
Kp
 * Kp + 1.f);

1746 float 
	gx0
 = ((
pp
.
x
 - 
a0
) * 
sk
) + (((pp.
y
 - 
b0
) * 
Kp
) * sk);

1747 float 
	gy0
 = -(((
pp
.
x
 - 
a0
) * 
Kp
) * 
sk
) + ((pp.
y
 - 
b0
) * sk);

1748 float 
	gAx
 = 
sqrt
((
x0
 * x0 * 
Np
 * Np + 
y0
 * y0) / ((Np * Np) * (1.f + 
Kp
 * Kp)));

1749 int 
	gA
 = 
cvRound
(
abs
(
Ax
 / 
cos
(
rho
)));

1750 if ((0 <= 
A
) && (A < 
ACC_A_SIZE
))

1751 ++
accA
[
A
];

1754 for (
ushort
 
	gl
 = 0; l < 
	gsz_ek
; ++l) {

1755 
	gPoint
 &
	gpp
 = 
edge_k
[
l
];

1756 float 
	gsk
 = 1.f / 
sqrt
(
Kp
 * Kp + 1.f);

1757 float 
	gx0
 = ((
pp
.
x
 - 
a0
) * 
sk
) + (((pp.
y
 - 
b0
) * 
Kp
) * sk);

1758 float 
	gy0
 = -(((
pp
.
x
 - 
a0
) * 
Kp
) * 
sk
) + ((pp.
y
 - 
b0
) * sk);

1759 float 
	gAx
 = 
sqrt
((
x0
 * x0 * 
Np
 * Np + 
y0
 * y0) / ((Np * Np) * (1.f + 
Kp
 * Kp)));

1760 int 
	gA
 = 
cvRound
(
abs
(
Ax
 / 
cos
(
rho
)));

1761 if ((0 <= 
A
) && (A < 
ACC_A_SIZE
))

1762 ++
accA
[
A
];

1766 int 
	gA
 = (int)
std
::
distance
(
accA
, std::
max_element
(accA, accA + 
ACC_A_SIZE
));

1767 auto 
	gfA
 = float(
A
);

1770 float 
	gfB
 = 
abs
(
fA
 * 
Np
);

1773 
Ellipse
 
ell
(
a0
, 
b0
, 
fA
, 
fB
, 
fmod
(
rho
 + float(
CV_PI
) * 2.f, float(CV_PI)));

1778 float 
	g_cos
 = 
cos
(-
ell
.
radius
);

1779 float 
	g_sin
 = 
sin
(-
ell
.
radius
);

1781 float 
	ginvA2
 = 1.f / (
ell
.
a
 * ell.a);

1782 float 
	ginvB2
 = 1.f / (
ell
.
b
 * ell.b);

1784 float 
	ginvNofPoints
 = 1.f / float(
sz_ei
 + 
sz_ej
 + 
sz_ek
);

1785 int 
	gcounter_on_perimeter
 = 0;

1787 for (
ushort
 
	gl
 = 0; l < 
	gsz_ei
; ++l) {

1788 float 
	gtx
 = float(
edge_i
[
l
].
x
) - 
ell
.
center
.x;

1789 float 
	gty
 = float(
edge_i
[
l
].
y
) - 
ell
.
center
.y;

1790 float 
	grx
 = (
tx
 * 
_cos
 - 
ty
 * 
_sin
);

1791 float 
	gry
 = (
tx
 * 
_sin
 + 
ty
 * 
_cos
);

1793 float 
	gh
 = (
rx
 * rx) * 
invA2
 + (
ry
 * ry) * 
invB2
;

1794 if (
abs
(
h
 - 1.f) < 
	g_maxDistanceToEllipseContour
)

1795 ++
	gcounter_on_perimeter
;

1798 for (
ushort
 
	gl
 = 0; l < 
	gsz_ej
; ++l) {

1799 float 
	gtx
 = float(
edge_j
[
l
].
x
) - 
ell
.
center
.x;

1800 float 
	gty
 = float(
edge_j
[
l
].
y
) - 
ell
.
center
.y;

1801 float 
	grx
 = (
tx
 * 
_cos
 - 
ty
 * 
_sin
);

1802 float 
	gry
 = (
tx
 * 
_sin
 + 
ty
 * 
_cos
);

1804 float 
	gh
 = (
rx
 * rx) * 
invA2
 + (
ry
 * ry) * 
invB2
;

1805 if (
abs
(
h
 - 1.f) < 
	g_maxDistanceToEllipseContour
)

1806 ++
	gcounter_on_perimeter
;

1809 for (
ushort
 
	gl
 = 0; l < 
	gsz_ek
; ++l) {

1810 float 
	gtx
 = float(
edge_k
[
l
].
x
) - 
ell
.
center
.x;

1811 float 
	gty
 = float(
edge_k
[
l
].
y
) - 
ell
.
center
.y;

1812 float 
	grx
 = (
tx
 * 
_cos
 - 
ty
 * 
_sin
);

1813 float 
	gry
 = (
tx
 * 
_sin
 + 
ty
 * 
_cos
);

1815 float 
	gh
 = (
rx
 * rx) * 
invA2
 + (
ry
 * ry) * 
invB2
;

1816 if (
abs
(
h
 - 1.f) < 
	g_maxDistanceToEllipseContour
)

1817 ++
	gcounter_on_perimeter
;

1821 if (
	gcounter_on_perimeter
 <= 0)

1825 float 
	gscore
 = float(
counter_on_perimeter
) * 
invNofPoints
;

1826 if (
	gscore
 < 
	g_minScore
)

1830 float 
	gdi
, 
	gdj
, 
	gdk
;

1832 
Point2f
 
p1
(float(
edge_i
[0].
x
), float(edge_i[0].
y
));

1833 
Point2f
 
p2
(float(
edge_i
[
sz_ei
 - 1].
x
), float(edge_i[sz_ei - 1].
y
));

1834 
	gp1
.
	gx
 -= 
ell
.
center
.
x
;

1835 
	gp1
.
	gy
 -= 
ell
.
center
.
y
;

1836 
	gp2
.
	gx
 -= 
ell
.
center
.
x
;

1837 
	gp2
.
	gy
 -= 
ell
.
center
.
y
;

1838 
Point2f
 
r1
((
p1
.
x
 * 
_cos
 - p1.
y
 * 
_sin
), (p1.x * _sin + p1.y * _cos));

1839 
Point2f
 
r2
((
p2
.
x
 * 
_cos
 - p2.
y
 * 
_sin
), (p2.x * _sin + p2.y * _cos));

1840 
	gdi
 = 
abs
(
r2
.
x
 - 
r1
.x) + abs(r2.
y
 - r1.y);

1843 
Point2f
 
p1
(float(
edge_j
[0].
x
), float(edge_j[0].
y
));

1844 
Point2f
 
p2
(float(
edge_j
[
sz_ej
 - 1].
x
), float(edge_j[sz_ej - 1].
y
));

1845 
	gp1
.
	gx
 -= 
ell
.
center
.
x
;

1846 
	gp1
.
	gy
 -= 
ell
.
center
.
y
;

1847 
	gp2
.
	gx
 -= 
ell
.
center
.
x
;

1848 
	gp2
.
	gy
 -= 
ell
.
center
.
y
;

1849 
Point2f
 
r1
((
p1
.
x
 * 
_cos
 - p1.
y
 * 
_sin
), (p1.x * _sin + p1.y * _cos));

1850 
Point2f
 
r2
((
p2
.
x
 * 
_cos
 - p2.
y
 * 
_sin
), (p2.x * _sin + p2.y * _cos));

1851 
	gdj
 = 
abs
(
r2
.
x
 - 
r1
.x) + abs(r2.
y
 - r1.y);

1854 
Point2f
 
p1
(float(
edge_k
[0].
x
), float(edge_k[0].
y
));

1855 
Point2f
 
p2
(float(
edge_k
[
sz_ek
 - 1].
x
), float(edge_k[sz_ek - 1].
y
));

1856 
	gp1
.
	gx
 -= 
ell
.
center
.
x
;

1857 
	gp1
.
	gy
 -= 
ell
.
center
.
y
;

1858 
	gp2
.
	gx
 -= 
ell
.
center
.
x
;

1859 
	gp2
.
	gy
 -= 
ell
.
center
.
y
;

1860 
Point2f
 
r1
((
p1
.
x
 * 
_cos
 - p1.
y
 * 
_sin
), (p1.x * _sin + p1.y * _cos));

1861 
Point2f
 
r2
((
p2
.
x
 * 
_cos
 - p2.
y
 * 
_sin
), (p2.x * _sin + p2.y * _cos));

1862 
	gdk
 = 
abs
(
r2
.
x
 - 
r1
.x) + abs(r2.
y
 - r1.y);

1866 float 
	grel
 = 
min
(1.f, ((
di
 + 
dj
 + 
dk
) / (3 * (
ell
.
a
 + ell.
b
))));

1868 if (
	grel
 < 
	g_minReliability
)

1872 
	gell
.
	gscore
 = (
score
 + 
rel
) * 0.5f;

1875 
	gellipses
.
emplace_back
(
ell
);

1878 void 
	gEllipseDetectorImpl
::
clusterEllipses
(
std
::
vector
<
Ellipse
> &
ellipses
) {

1879 const float 
aDistanceThreshold
 = 0.1f, 
	gbDistanceThreshold
 = 0.1f;

1880 const float 
	grDistanceThreshold
 = 0.1f;

1881 const float 
	gDcRatioThreshold
 = 0.1f, 
	grCircleThreshold
 = 0.9f;

1883 int 
	gellipseCount
 = int(
ellipses
.
size
());

1884 if (
	gellipseCount
 == 0)

1888 
	gstd
::
vector
<
Ellipse
> 
clusters
;

1889 
	gclusters
.
emplace_back
(
ellipses
[0]);

1891 
bool
 
	gfoundCluster
 = 
false
;

1892 for (int 
	gi
 = 0; i < 
	gellipseCount
; i++) {

1893 int 
	gclusterSize
 = int(
clusters
.
size
());

1895 
	gEllipse
 &
	ge1
 = 
ellipses
[
i
];

1896 float 
	gba_e1
 = 
e1
.
b
 / e1.
a
;

1898 
	gfoundCluster
 = 
false
;

1899 for (int 
	gj
 = 0; j < 
	gclusterSize
; j++) {

1900 
	gEllipse
 &
	ge2
 = 
clusters
[
j
];

1901 float 
	gba_e2
 = 
e2
.
b
 / e2.
a
;

1903 float 
	gcDistanceThreshold
 = 
min
(
e1
.
b
, 
e2
.b) * 
	gDcRatioThreshold
;

1904 
	gcDistanceThreshold
 = 
cDistanceThreshold
 * cDistanceThreshold;

1907 float 
	gcDistance
 = ((
e1
.
center
.
x
 - 
e2
.center.x) * (e1.center.x - e2.center.x) +

1908 (
e1
.
center
.
y
 - 
e2
.center.y) * (e1.center.y - e2.center.y));

1909 if (
	gcDistance
 > 
	gcDistanceThreshold
)

1913 float 
	gaDistance
 = 
abs
(
e1
.
a
 - 
e2
.a) / 
max
(e1.a, e2.a);

1914 if (
	gaDistance
 > 
	gaDistanceThreshold
)

1918 float 
	gbDistance
 = 
abs
(
e1
.
b
 - 
e2
.b) / 
min
(e1.b, e2.b);

1919 if (
	gbDistance
 > 
	gbDistanceThreshold
)

1923 float 
	grDistance
 = 
getMinAnglePI
(
e1
.
radius
, 
e2
.radius) / float(
	gCV_PI
);

1924 if ((
	grDistance
 > 
	grDistanceThreshold
) && (
	gba_e1
 < 
	grCircleThreshold
) &&

1925 (
	gba_e2
 < 
	grCircleThreshold
))

1929 
	gfoundCluster
 = 
true
;

1934 if (!
	gfoundCluster
)

1935 
	gclusters
.
push_back
(
e1
);

1937 
	gclusters
.
swap
(
ellipses
);

1941 void 
findEllipses
(

1942 
InputArray
 
image
, 
OutputArray
 
ellipses
,

1943 float 
scoreThreshold
, float 
reliabilityThreshold
,

1944 float 
centerDistanceThreshold
) {

1947 
CV_Assert
(

1948 !
image
.
empty
() && (image.
isMat
() || image.
isUMat
()));

1951 int 
	gtype
 = 
CV_32FC
(6);

1952 if (
	gellipses
.
fixedType
()) {

1953 
	gtype
 = 
ellipses
.
type
();

1954 
CV_CheckType
(
type
, type == 
CV_32FC
(6), "Wrong type of output ellipses");

1958 
Size
 
	gimgSize
 = 
image
.
size
();

1959 float 
	gmaxCenterDistance
 =

1960 
sqrt
(float(
imgSize
.
width
 * imgSize.width + imgSize.
height
 * imgSize.height)) *

1961 
centerDistanceThreshold
;

1962 
EllipseDetectorImpl
 
	gedi
;

1963 
	gedi
.
setParameters
(
maxCenterDistance
, 
scoreThreshold
, 
reliabilityThreshold
);

1966 
	gstd
::
vector
<
Ellipse
> 
ellipseResults
;

1967 
Mat1b
 
	ggrayImage
 = 
image
.
getMat
();

1968 if (
	gimage
.
channels
() != 1)

1969 
cvtColor
(
image
, 
grayImage
, 
COLOR_BGR2GRAY
);

1970 
	gedi
.
detect
(
grayImage
, 
ellipseResults
);

1973 
	gstd
::
vector
<
Vec6f
> 
_ellipses
;

1974 for (
size_t
 
	gi
 = 0; i < 
	gellipseResults
.
size
(); i++) {

1975 
Ellipse
 
	gtmpEll
 = 
ellipseResults
[
i
];

1976 
Vec6f
 
tmpVec
(
tmpEll
.
center
.
x
, tmpEll.center.
y
, tmpEll.
a
, tmpEll.
b
, tmpEll.
score
,

1977 
tmpEll
.
radius
);

1978 
	g_ellipses
.
push_back
(
tmpVec
);

1980 
Mat
(
_ellipses
).
copyTo
(
ellipses
);

	@ximgproc/src/precomp.hpp

37 #ifndef 
_OPENCV_XIMGPROC_PRECOMP_HPP_


38 #define 
	#_OPENCV_XIMGPROC_PRECOMP_HPP_


	)

40 #include 
	~<opencv2/core.hpp
>

41 #include 
	~<opencv2/core/ocl.hpp
>

42 #include 
	~<opencv2/core/base.hpp
>

43 #include 
	~<opencv2/core/utility.hpp
>

44 #include 
	~<opencv2/imgproc.hpp
>

46 #include 
	~<opencv2/ximgproc.hpp
>

48 #include 
	~<algorithm
>

49 #include 
	~<map
>

	@
1
.
0
37
1782
CMakeFiles/3.27.1/CompilerIdC/CMakeCCompilerId.c
CMakeFiles/3.27.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
build/CMakeFiles/3.27.1/CompilerIdC/CMakeCCompilerId.c
build/CMakeFiles/3.27.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
main.cpp
test.cpp
ximgproc/include/opencv2/ximgproc.hpp
ximgproc/include/opencv2/ximgproc/brightedges.hpp
ximgproc/include/opencv2/ximgproc/color_match.hpp
ximgproc/include/opencv2/ximgproc/deriche_filter.hpp
ximgproc/include/opencv2/ximgproc/disparity_filter.hpp
ximgproc/include/opencv2/ximgproc/edge_drawing.hpp
ximgproc/include/opencv2/ximgproc/edge_filter.hpp
ximgproc/include/opencv2/ximgproc/edgeboxes.hpp
ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp
ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp
ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp
ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp
ximgproc/include/opencv2/ximgproc/find_ellipses.hpp
ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp
ximgproc/include/opencv2/ximgproc/lsc.hpp
ximgproc/include/opencv2/ximgproc/paillou_filter.hpp
ximgproc/include/opencv2/ximgproc/peilin.hpp
ximgproc/include/opencv2/ximgproc/radon_transform.hpp
ximgproc/include/opencv2/ximgproc/ridgefilter.hpp
ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp
ximgproc/include/opencv2/ximgproc/scansegment.hpp
ximgproc/include/opencv2/ximgproc/seeds.hpp
ximgproc/include/opencv2/ximgproc/segmentation.hpp
ximgproc/include/opencv2/ximgproc/slic.hpp
ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp
ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp
ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp
ximgproc/src/edge_drawing.cpp
ximgproc/src/edge_drawing_common.hpp
ximgproc/src/find_ellipses.cpp
ximgproc/src/precomp.hpp
